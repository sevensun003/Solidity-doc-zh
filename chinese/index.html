<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]--><!--[if gt IE 8]><!--><html class="no-js" lang="en"> <!--<![endif]-->
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Solidity 0.4.24 documentation</title>
<link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<script src="_static/js/modernizr.min.js"></script>
<!-- RTD Extra Head -->
<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link href="http://solidity.readthedocs.io/en/v0.4.23/" rel="canonical"/>
<link href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" rel="stylesheet" type="text/css"/>
<script src="_static/readthedocs-data.js" type="text/javascript"></script>
<!-- Add page-specific data, which must exist in the page js, not global -->
<script type="text/javascript">
READTHEDOCS_DATA['page'] = 'index'
</script>
<script src="https://media.readthedocs.org/javascript/readthedocs-analytics.js" type="text/javascript"></script>
<!-- end RTD <extrahead> -->
</head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="index.html#document-index"> Solidity
          

          
          </a>
<div class="version">
                latest
              </div>
<div role="search">
<form action="search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<!-- Local TOC -->
<div class="local-toc"><ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-introduction-to-smart-contracts">Introduction to Smart Contracts</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#a-simple-smart-contract">A Simple Smart Contract</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#blockchain-basics">Blockchain Basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#index-6">The Ethereum Virtual Machine</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-installing-solidity">Installing the Solidity Compiler</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#versioning">Versioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#remix">Remix</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#npm-node-js">npm / Node.js</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#docker">Docker</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#binary-packages">Binary Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#building-from-source">Building from Source</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cmake-options">CMake options</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#the-version-string-in-detail">The version string in detail</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#important-information-about-versioning">Important information about versioning</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-solidity-by-example">Solidity by Example</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#voting">Voting</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#blind-auction">Blind Auction</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#safe-remote-purchase">Safe Remote Purchase</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#micropayment-channel">Micropayment Channel</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-solidity-in-depth">Solidity in Depth</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-layout-of-source-files">Layout of a Solidity Source File</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-structure-of-a-contract">Structure of a Contract</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-units-and-global-variables">Units and Globally Available Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-control-structures">Expressions and Control Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-contracts">Contracts</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-assembly">Solidity Assembly</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#document-miscellaneous">Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-security-considerations">Security Considerations</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#pitfalls">Pitfalls</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#recommendations">Recommendations</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#formal-verification">Formal Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-using-the-compiler">Using the compiler</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#using-the-commandline-compiler">Using the Commandline Compiler</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#compiler-input-and-output-json-description">Compiler Input and Output JSON Description</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-metadata">Contract Metadata</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#encoding-of-the-metadata-hash-in-the-bytecode">Encoding of the Metadata Hash in the Bytecode</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#usage-for-automatic-interface-generation-and-natspec">Usage for Automatic Interface Generation and NatSpec</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#usage-for-source-code-verification">Usage for Source Code Verification</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-abi-spec">Application Binary Interface Specification</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#basic-design">Basic Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#function-selector">Function Selector</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#argument-encoding">Argument Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#types">Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#formal-specification-of-the-encoding">Formal Specification of the Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#function-selector-and-argument-encoding">Function Selector and Argument Encoding</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#examples">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#use-of-dynamic-types">Use of Dynamic Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#events">Events</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#json">JSON</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#non-standard-packed-mode">Non-standard Packed Mode</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-julia">Joyfully Universal Language for (Inline) Assembly</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#specification-of-julia">Specification of JULIA</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#specification-of-julia-object">Specification of JULIA Object</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-style-guide">Style Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#code-layout">Code Layout</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#naming-conventions">Naming Conventions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-common-patterns">Common Patterns</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#withdrawal-from-contracts">Withdrawal from Contracts</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#restricting-access">Restricting Access</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#state-machine">State Machine</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-bugs">List of Known Bugs</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-contributing">Contributing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#how-to-report-issues">How to Report Issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#workflow-for-pull-requests">Workflow for Pull Requests</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#running-the-compiler-tests">Running the compiler tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#running-the-fuzzer-via-afl">Running the Fuzzer via AFL</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#whiskers">Whiskers</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-frequently-asked-questions">Frequently Asked Questions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#basic-questions">Basic Questions</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#advanced-questions">Advanced Questions</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="index.html#document-index">Solidity</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a href="index.html#document-index">Docs</a> »</li>
<li>Solidity 0.4.24 documentation</li>
<li class="wy-breadcrumbs-aside">
<a class="fa fa-github" href="https://github.com/ethereum/solidity/blob/develop/docs/index.rst"> Edit on GitHub</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<div class="section" id="solidity">
<h1>Solidity<a class="headerlink" href="#solidity" title="Permalink to this headline">¶</a></h1>
<a class="reference internal image-reference" href="_images/logo.svg"><div align="center" class="align-center"><img alt="Solidity logo" src="_images/logo.svg" width="120px"/></div>
</a>
<p>Solidity是一种面向合约的高级语言，用于实现智能合约。它受c++、Python和JavaScriptand的影响，目的是针对Ethereum虚拟机(EVM)。</p>
<p>Solidity是静态类型的，它支持继承、库和复杂用户定义的类型。</p>
<p>如你所见，有可能创建投票、众筹、盲目拍卖、多签名钱包等合约。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">现在最好的方法是混合使用(它可能需要一段时间来加载，请耐心等待)。Remix是一个基于web浏览器的IDE，它允许您编写可靠的智能合约，然后部署和运行智能合约。<a class="reference external" href="https://remix.ethereum.org/">Remix</a></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">由于软件是由人编写的，所以它可能有bug。因此，应该按照众所周知的软件开发最佳实践来创建alsosmart合约。这包括代码审查、测试、审计和正确性证明。还要注意的是，用户有时比其作者更有信心。最后，区块链有他们自己的东西要小心，所以请看一看安全考虑。<a class="reference internal" href="index.html#security-considerations"><span class="std std-ref">Security Considerations</span></a></p>
</div>
<div class="section" id="translations">
<h2>Translations<a class="headerlink" href="#translations" title="Permalink to this headline">¶</a></h2>
<p>该文档由社区志愿者翻译成多种语言，但英文版本作为参考。</p>
<ul class="simple">
<li><a class="reference external" href="http://solidity-cn.readthedocs.io">Simplified Chinese</a> (in progress)</li>
<li><a class="reference external" href="https://solidity-es.readthedocs.io">Spanish</a></li>
<li><a class="reference external" href="https://github.com/ethereum/wiki/wiki/%5BRussian%5D-%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-%D0%BF%D0%BE-Solidity">Russian</a> (rather outdated)</li>
<li><a class="reference external" href="http://solidity-kr.readthedocs.io">Korean</a> (in progress)</li>
</ul>
</div>
<div class="section" id="useful-links">
<h2>Useful links<a class="headerlink" href="#useful-links" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://ethereum.org">Ethereum</a></li>
<li><a class="reference external" href="https://github.com/ethereum/solidity/blob/develop/Changelog.md">Changelog</a></li>
<li><a class="reference external" href="https://www.pivotaltracker.com/n/projects/1189488">Story Backlog</a></li>
<li><a class="reference external" href="https://github.com/ethereum/solidity/">Source Code</a></li>
<li><a class="reference external" href="https://ethereum.stackexchange.com/">Ethereum Stackexchange</a></li>
<li><a class="reference external" href="https://gitter.im/ethereum/solidity/">Gitter Chat</a></li>
</ul>
</div>
<div class="section" id="available-solidity-integrations">
<h2>Available Solidity Integrations<a class="headerlink" href="#available-solidity-integrations" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><dl class="first docutils">
<dt><a class="reference external" href="https://remix.ethereum.org/">Remix</a></dt>
<dd>Browser-based IDE with integrated compiler and Solidity runtime environment without server-side components.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://plugins.jetbrains.com/plugin/9475-intellij-solidity">IntelliJ IDEA plugin</a></dt>
<dd>Solidity plugin for IntelliJ IDEA (and all other JetBrains IDEs)</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://visualstudiogallery.msdn.microsoft.com/96221853-33c4-4531-bdd5-d2ea5acc4799/">Visual Studio Extension</a></dt>
<dd>Solidity plugin for Microsoft Visual Studio that includes the Solidity compiler.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://packagecontrol.io/packages/Ethereum/">Package for SublimeText — Solidity language syntax</a></dt>
<dd>Solidity syntax highlighting for SublimeText editor.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/0mkara/etheratom">Etheratom</a></dt>
<dd>Plugin for the Atom editor that features syntax highlighting, compilation and a runtime environment (Backend node &amp; VM compatible).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://atom.io/packages/linter-solidity">Atom Solidity Linter</a></dt>
<dd>Plugin for the Atom editor that provides Solidity linting.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://atom.io/packages/linter-solium">Atom Solium Linter</a></dt>
<dd>Configurable Solidty linter for Atom using Solium as a base.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/duaraghav8/Solium/">Solium</a></dt>
<dd>Linter to identify and fix style and security issues in Solidity.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/protofire/solhint">Solhint</a></dt>
<dd>Solidity linter that provides security, style guide and best practice rules for smart contract validation.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="http://juan.blanco.ws/solidity-contracts-in-visual-studio-code/">Visual Studio Code extension</a></dt>
<dd>Solidity plugin for Microsoft Visual Studio Code that includes syntax highlighting and the Solidity compiler.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/ethereum/emacs-solidity/">Emacs Solidity</a></dt>
<dd>Plugin for the Emacs editor providing syntax highlighting and compilation error reporting.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/tomlion/vim-solidity/">Vim Solidity</a></dt>
<dd>Plugin for the Vim editor providing syntax highlighting.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/scrooloose/syntastic">Vim Syntastic</a></dt>
<dd>Plugin for the Vim editor providing compile checking.</dd>
</dl>
</li>
</ul>
<p>停止:</p>
<ul class="simple">
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/ethereum/mix/">Mix IDE</a></dt>
<dd>Qt based IDE for designing, debugging and testing solidity smart contracts.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://live.ether.camp/">Ethereum Studio</a></dt>
<dd>Specialized web IDE that also provides shell access to a complete Ethereum environment.</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="solidity-tools">
<h2>Solidity Tools<a class="headerlink" href="#solidity-tools" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><dl class="first docutils">
<dt><a class="reference external" href="https://dapp.readthedocs.io">Dapp</a></dt>
<dd>Build tool, package manager, and deployment assistant for Solidity.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/raineorshine/solidity-repl">Solidity REPL</a></dt>
<dd>Try Solidity instantly with a command-line Solidity console.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/raineorshine/solgraph">solgraph</a></dt>
<dd>Visualize Solidity control flow and highlight potential security vulnerabilities.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/Arachnid/evmdis">evmdis</a></dt>
<dd>EVM Disassembler that performs static analysis on the bytecode to provide a higher level of abstraction than raw EVM operations.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/DigixGlobal/doxity">Doxity</a></dt>
<dd>Documentation Generator for Solidity.</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="third-party-solidity-parsers-and-grammars">
<h2>Third-Party Solidity Parsers and Grammars<a class="headerlink" href="#third-party-solidity-parsers-and-grammars" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/ConsenSys/solidity-parser">solidity-parser</a></dt>
<dd>Solidity parser for JavaScript</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference external" href="https://github.com/federicobond/solidity-antlr4">Solidity Grammar for ANTLR 4</a></dt>
<dd>Solidity grammar for the ANTLR 4 parser generator</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="language-documentation">
<h2>Language Documentation<a class="headerlink" href="#language-documentation" title="Permalink to this headline">¶</a></h2>
<p>在下一页中，我们将首先看到一个简单的智能合约，它的Solidity，然后是关于区块链and和Ethereum虚拟机的基础知识。<a class="reference internal" href="index.html#simple-smart-contract"><span class="std std-ref">simple smart contract</span></a><a class="reference internal" href="index.html#blockchain-basics"><span class="std std-ref">blockchains</span></a><a class="reference internal" href="index.html#the-ethereum-virtual-machine"><span class="std std-ref">Ethereum Virtual Machine</span></a></p>
<p>下一节将介绍一些有用的例子，例如，你可以在你的浏览器上试用一下。<em>features</em><a class="reference internal" href="index.html#voting"><span class="std std-ref">example contracts</span></a><a class="reference external" href="https://remix.ethereum.org">in your browser</a></p>
<p>最后和最广泛的部分将涉及到深度的所有方面。</p>
<p>如果你仍然有问题，你可以试着在以太的Stackexchangesite上搜索或者询问，或者到我们的gitter频道。关于提高可靠性和文档的想法总是受欢迎的!<a class="reference external" href="https://ethereum.stackexchange.com/">Ethereum Stackexchange</a><a class="reference external" href="https://gitter.im/ethereum/solidity/">gitter channel</a></p>
</div>
</div>
<div class="section" id="contents">
<h1>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h1>
<p><a class="reference internal" href="genindex.html"><span class="std std-ref">Keyword Index</span></a>关键词索引、搜索页面<a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p>
<div class="toctree-wrapper compound">
<span id="document-introduction-to-smart-contracts"></span><div class="section" id="introduction-to-smart-contracts">
<h2>Introduction to Smart Contracts<a class="headerlink" href="#introduction-to-smart-contracts" title="Permalink to this headline">¶</a></h2>
<div class="section" id="a-simple-smart-contract">
<span id="simple-smart-contract"></span><h3>A Simple Smart Contract<a class="headerlink" href="#a-simple-smart-contract" title="Permalink to this headline">¶</a></h3>
<p>让我们从最基本的例子开始。如果你现在不明白一切的话，那就好了，我们稍后再详细讨论。</p>
<div class="section" id="storage">
<h4>Storage<a class="headerlink" href="#storage" title="Permalink to this headline">¶</a></h4>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">SimpleStorage</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="nx">storedData</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">set</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">storedData</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">get</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">storedData</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>第一行简单地告诉我们，源代码是为solidity version 0.4.0编写的，或者任何不破坏功能的新版本(但不包括版本0.5.0)。这是为了确保在新的编译器版本中，它不会突然有不同的表现。关键字pragma是这样被调用的，因为在一般情况下，pragmas是关于如何处理这些源代码的编译器的指令(如，pragma once)。<code class="docutils literal"><span class="pre">pragma</span></code><a class="reference external" href="https://en.wikipedia.org/wiki/Pragma_once">pragma once</a></p>
<p>可靠性的合约是一组代码(它的函数)和数据(它的状态)，它驻留在Ethereumblockchain的特定地址上。线使用uint storedData;声明一个状态变量，名为uint类型的storedData(无符号整数256位)。您可以把它看作是一个单独的slotin数据库，它可以通过调用管理数据库的thecode函数来查询和更改。在以太的情况下，这始终是合约。在这种情况下，函数集和get可以用来修改变量的值。<em>functions</em><em>state</em><code class="docutils literal"><span class="pre">uint</span> <span class="pre">storedData;</span></code><code class="docutils literal"><span class="pre">storedData</span></code><code class="docutils literal"><span class="pre">uint</span></code><code class="docutils literal"><span class="pre">set</span></code><code class="docutils literal"><span class="pre">get</span></code></p>
<p>要访问一个状态变量，您不需要这个前缀。和其他语言一样。<code class="docutils literal"><span class="pre">this.</span></code></p>
<p>这个合约还没有做很多(由于Ethereum构建的基础设施)，除了允许任何人在没有(可行的)方法阻止你发布这个数字的情况下，存储一个可以被任何人访问的数字。当然，任何人都可以使用不同的valueand覆盖您的数字来调用set，但是这个数字仍然会存储在区块链的历史记录中。稍后，我们将看到如何强制限制访问限制，只有您可以更改这个数字。<code class="docutils literal"><span class="pre">set</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">所有的标识符(合约名称、函数名和变量名)都被限制在ASCII字符集上，可以在字符串变量中存储UTF-8编码的数据。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">要小心使用Unicode文本，因为相似的(甚至相同的)字符可以有不同的代码点，并且这些字符将被编码为一个不同的字节数组。</p>
</div>
</div>
<div class="section" id="subcurrency-example">
<span id="index-0"></span><h4>Subcurrency Example<a class="headerlink" href="#subcurrency-example" title="Permalink to this headline">¶</a></h4>
<p>下面的合约将执行最简单的一种丙烯货币。从稀薄的空气中产生硬币是可能的，但只有创造了合约的人才能做到这一点(trivialto实施了不同的发行计划)。此外，任何人都可以互相发送硬币，而无需注册用户名和密码——你所需要的只是一个以太的密钥对。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">21</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Coin</span> <span class="p">{</span>
    <span class="c1">// The keyword "public" makes those variables</span>
    <span class="c1">// readable from outside.</span>
    <span class="kt">address</span> <span class="k">public</span> <span class="nx">minter</span><span class="p">;</span>
    <span class="k">mapping</span> <span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="k">public</span> <span class="nx">balances</span><span class="p">;</span>

    <span class="c1">// Events allow light clients to react on</span>
    <span class="c1">// changes efficiently.</span>
    <span class="kd">event</span> <span class="nx">Sent</span><span class="p">(</span><span class="kt">address</span> <span class="nx">from</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">to</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">amount</span><span class="p">);</span>

    <span class="c1">// This is the constructor whose code is</span>
    <span class="c1">// run only when the contract is created.</span>
    <span class="kd">function</span> <span class="nx">Coin</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">minter</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">mint</span><span class="p">(</span><span class="kt">address</span> <span class="nx">receiver</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">amount</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">minter</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">balances</span><span class="p">[</span><span class="nx">receiver</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">amount</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">send</span><span class="p">(</span><span class="kt">address</span> <span class="nx">receiver</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">amount</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">balances</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">amount</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="nx">balances</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">amount</span><span class="p">;</span>
        <span class="nx">balances</span><span class="p">[</span><span class="nx">receiver</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">amount</span><span class="p">;</span>
        <span class="nx">emit</span> <span class="nx">Sent</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">receiver</span><span class="p">,</span> <span class="nx">amount</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这个合约介绍了一些新概念，让我们逐一介绍一下。</p>
<p>线路地址公众号;声明一个可公开访问的类型地址的状态变量。地址类型是一个160位的值，不允许任何算术运算。它适合存储属于外部人的合约或密钥对的地址。关键字public会自动生成一个函数，该函数允许您从合约外部访问状态变量的当前值。没有这个关键字，其他合约就无法访问变量。编译器生成的函数代码大致相当于以下内容:<code class="docutils literal"><span class="pre">address</span> <span class="pre">public</span> <span class="pre">minter;</span></code><code class="docutils literal"><span class="pre">address</span></code><code class="docutils literal"><span class="pre">public</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">minter</span><span class="p">()</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">minter</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>当然，添加一个完全相同的函数是行不通的，因为我们会有一个函数和一个同名的状态变量，但希望你能得到这个想法——编译器会为你计算出来。</p>
<p id="index-1">下一行，映射(地址=&gt; uint)公共余额;alsocreate是一个公共状态变量，但它是一个更复杂的数据类型。类型映射地址为无符号整数。映射可以看作是哈希表，它实际上是初始化的，这样每一个可能的键都存在，并被映射到avalue，它的字节表示都是零。不过，这个类比不太过分，因为它既不可能获得映射的所有键的列表，也不可能获得所有值的列表。因此，要么记住(更好的方法，保留一个列表，要么使用更高级的数据类型)，然后将其添加到映射中，或者在不需要的情况下使用它，比如这个。在这种情况下，由公共关键字创建的getter函数稍微复杂一些。大致如下:<code class="docutils literal"><span class="pre">mapping</span> <span class="pre">(address</span> <span class="pre">=&gt;</span> <span class="pre">uint)</span> <span class="pre">public</span> <span class="pre">balances;</span></code><a class="reference external" href="https://en.wikipedia.org/wiki/Hash_table">hash tables</a><a class="reference internal" href="index.html#getter-functions"><span class="std std-ref">getter function</span></a><code class="docutils literal"><span class="pre">public</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">balances</span><span class="p">(</span><span class="kt">address</span> <span class="nx">_account</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">balances</span><span class="p">[</span><span class="nx">_account</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如您所见，您可以使用该函数轻松查询asingle帐户的余额。</p>
<p id="index-2">发送的行事件(地址、地址、uint数量);在functionsend的最后一行中发出的所谓“事件”。用户界面(当然还有服务器应用程序)可以监听那些在区块链上被释放的事件，而不需要付出太多代价。一旦它发出，侦听器也将接收来自、到和数量的参数，这使得跟踪事务变得很容易。为了侦听这个事件，您将使用。<code class="docutils literal"><span class="pre">event</span> <span class="pre">Sent(address</span> <span class="pre">from,</span> <span class="pre">address</span> <span class="pre">to,</span> <span class="pre">uint</span> <span class="pre">amount);</span></code><code class="docutils literal"><span class="pre">send</span></code><code class="docutils literal"><span class="pre">from</span></code><code class="docutils literal"><span class="pre">to</span></code><code class="docutils literal"><span class="pre">amount</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">Coin</span><span class="p">.</span><span class="nx">Sent</span><span class="p">().</span><span class="nx">watch</span><span class="p">({},</span> <span class="s1">''</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Coin transfer: "</span> <span class="o">+</span> <span class="nx">result</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">amount</span> <span class="o">+</span>
            <span class="s2">" coins were sent from "</span> <span class="o">+</span> <span class="nx">result</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">from</span> <span class="o">+</span>
            <span class="s2">" to "</span> <span class="o">+</span> <span class="nx">result</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">to</span> <span class="o">+</span> <span class="s2">"."</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Balances now:\n"</span> <span class="o">+</span>
            <span class="s2">"Sender: "</span> <span class="o">+</span> <span class="nx">Coin</span><span class="p">.</span><span class="nx">balances</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">from</span><span class="p">)</span> <span class="o">+</span>
            <span class="s2">"Receiver: "</span> <span class="o">+</span> <span class="nx">Coin</span><span class="p">.</span><span class="nx">balances</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">args</span><span class="p">.</span><span class="nx">to</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">})</span>
</pre></div>
</div>
<p>注意如何从用户界面调用自动生成的函数余额。<code class="docutils literal"><span class="pre">balances</span></code></p>
<p id="index-3">特殊功能硬币是在合约创建过程中运行的，不能在事后调用。它永久地存储了创建协议的人的地址:msg(连同tx和块)是一个神奇的全局变量，包含一些允许访问区块链的属性。味精。发送方始终是当前(外部)函数调用来自的地址。<code class="docutils literal"><span class="pre">Coin</span></code><code class="docutils literal"><span class="pre">msg</span></code><code class="docutils literal"><span class="pre">tx</span></code><code class="docutils literal"><span class="pre">block</span></code><code class="docutils literal"><span class="pre">msg.sender</span></code></p>
<p>最后，最终会得到合约的功能，可以被用户和合约所调用，都是mint和send。如果除了创建合约的帐户之外，任何人都调用mint，那么什么都不会发生。另一方面，发送者可以被任何人(已经有一些硬币)用来向其他人发送硬币。请注意，如果你使用这个合约将硬币发送到一个地址，当你在区块链浏览器上看到这个地址时，你将看不到任何东西，因为你的硬币和已改变的余额只存储在这枚硬币合约的数据存储中。通过使用事件，创建跟踪新硬币的交易和余额的“区块链explorer”是相对容易的。<code class="docutils literal"><span class="pre">mint</span></code><code class="docutils literal"><span class="pre">send</span></code><code class="docutils literal"><span class="pre">mint</span></code><code class="docutils literal"><span class="pre">send</span></code></p>
</div>
</div>
<div class="section" id="blockchain-basics">
<span id="id1"></span><h3>Blockchain Basics<a class="headerlink" href="#blockchain-basics" title="Permalink to this headline">¶</a></h3>
<p>区块链作为一个概念，对于程序员来说并不太难理解。原因是大多数的复杂性(采矿、散列、椭圆曲线加密、对等网络等)只是提供了一组特性和承诺。一旦你接受了这些特性，你就不用担心潜在的技术了——或者你是否知道亚马逊的AWS是如何在内部运行的，以便使用它?<a class="reference external" href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">hashing</a><a class="reference external" href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">elliptic-curve cryptography</a><a class="reference external" href="https://en.wikipedia.org/wiki/Peer-to-peer">peer-to-peer networks</a></p>
<div class="section" id="transactions">
<span id="index-4"></span><h4>Transactions<a class="headerlink" href="#transactions" title="Permalink to this headline">¶</a></h4>
<p>区块链是一个全局共享的事务数据库。这意味着每个人都可以通过参与网络来读取数据库中的条目。如果您想要在数据库中更改某些内容，您必须创建一个必须被所有其他成员接受的所谓的事务。“事务”一词意味着您想要的更改(假设您同时想要更改两个值)要么完全没有完成，要么完全应用。此外，当您的事务应用于数据库时，没有其他事务可以更改它。</p>
<p>例如，假设有一个表列出了所有电子货币账户的余额。如果请求从一个帐户转移到另一个帐户，则数据库的事务性质将确保如果从一个帐户中减去余额，它总是会被添加到另一个帐户。如果dueto不管什么原因，添加到目标帐户的金额是不可能的，那么源帐户也不会被修改。</p>
<p>此外，事务总是由发送方(创建者)进行加密签名。这使得保护访问数据库的特定修改变得非常简单。在电子货币的例子中，一个简单的支票可以确保只有持有账户钥匙的人才能从账户上转账。</p>
</div>
<div class="section" id="blocks">
<span id="index-5"></span><h4>Blocks<a class="headerlink" href="#blocks" title="Permalink to this headline">¶</a></h4>
<p>要克服的一个主要障碍是，在比特币的条件下，被称为“双重支出攻击”:如果网络中存在两个想要清空账户的交易，即所谓的冲突，会发生什么?</p>
<p>对此的抽象回答是，你不必在意。将为您选择事务的顺序，事务将被绑定到所谓的“块”中，然后它们将在所有参与节点中执行和分配。如果两笔交易相互矛盾，最后一笔交易将被拒绝，而不会成为交易的一部分。</p>
<p>这些块在时间上形成一个线性序列，这就是“区块链”这个词的来源。每隔一段时间，每隔17秒，就会有一些积木被加入到链条中。</p>
<p>作为“订单选择机制”(即所谓的“挖掘”)的一部分，可能会不时地恢复块，但只在链的“顶端”。在顶部添加的块越多，它的可能性就越小。所以可能是你的事务被恢复了，甚至从区块链中删除了，但是你等待的时间越长，它就会越少。</p>
<span class="target" id="the-ethereum-virtual-machine"></span></div>
</div>
<div class="section" id="index-6">
<span id="id2"></span><h3>The Ethereum Virtual Machine<a class="headerlink" href="#index-6" title="Permalink to this headline">¶</a></h3>
<div class="section" id="overview">
<h4>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h4>
<p>Ethereum虚拟机或EVM是Ethereum中智能合约的运行时环境。它不仅是沙箱，而且实际上是完全隔离的，这意味着在EVM中运行的代码无法访问网络、文件系统或其他进程。智能合约甚至限制了其他智能合约的使用。</p>
</div>
<div class="section" id="accounts">
<span id="index-7"></span><h4>Accounts<a class="headerlink" href="#accounts" title="Permalink to this headline">¶</a></h4>
<p>在Ethereum中有两种帐户共享sameaddress空间:由公私密钥对(即人)控制的外部帐户和由存储在帐户中的代码所控制的合约帐户。<strong>External accounts</strong><strong>contract accounts</strong></p>
<p>外部帐户的地址是由公钥决定的，而合约的地址是在合约创建时确定的(它源自创建者的地址和从该地址发送的事务数，即所谓的“nonce”)。</p>
<p>无论帐户存储代码与否，这两种类型都被EVM同等对待。</p>
<p>每个帐户都有一个持久的键值存储，将256位的单词映射到256位字节的存储。<strong>storage</strong></p>
<p>此外，每个帐户都有一个余额(在“Wei”中是准确的)，可以通过发送包含以太的交易来修改。<strong>balance</strong></p>
</div>
<div class="section" id="index-8">
<span id="id3"></span><h4>Transactions<a class="headerlink" href="#index-8" title="Permalink to this headline">¶</a></h4>
<p>事务是由一个帐户发送到另一个帐户的消息(可能是相同的或特殊的零帐户，见下文)。它可以包括二进制数据(有效负载)和以太。</p>
<p>如果目标帐户包含代码，则执行该代码，并将有效负载作为输入数据提供。</p>
<p>如果目标帐户是零帐户(地址为0的帐户)，则事务创建一个新合约。如前所述，该合约的地址不是零地址，而是来自发送方的地址(“nonce”)的地址。这样的合约创建事务的有效负载被带到beEVM字节码并执行。此执行的输出将作为合约的代码保存。这意味着，为了创建一个合约，您不需要发送合约的实际代码，而是在执行时返回该代码的代码。<code class="docutils literal"><span class="pre">0</span></code><strong>new contract</strong></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在创建合约时，它的代码仍然是空的。正因为如此，在构造函数已经完成执行之前，您不应该在构建中调用它。</p>
</div>
</div>
<div class="section" id="gas">
<span id="index-9"></span><h4>Gas<a class="headerlink" href="#gas" title="Permalink to this headline">¶</a></h4>
<p>在创建过程中，每个事务都被收取一定数量的气体，其目的是限制执行事务所需的工作量，并为执行该事务支付费用。当EVM执行事务时，气体会根据特定的规则逐渐耗尽。<strong>gas</strong></p>
<p>燃气价格是由交易的创建者设定的一个值，它必须从发送帐户上支付gas_price * gas。如果在执行后还剩下一些气体，则以同样的方式返还。<strong>gas price</strong><code class="docutils literal"><span class="pre">gas_price</span> <span class="pre">*</span> <span class="pre">gas</span></code></p>
<p>如果气体在任意点(即为负)耗尽，就会触发一个异常气体异常，该异常将返回当前调用帧中对状态的所有修改。</p>
</div>
<div class="section" id="storage-memory-and-the-stack">
<span id="index-10"></span><h4>Storage, Memory and the Stack<a class="headerlink" href="#storage-memory-and-the-stack" title="Permalink to this headline">¶</a></h4>
<p>每个帐户都有一个持久的内存区域，称为存储区。存储是一个键值存储，它将256位的单词映射到256位单词。在合约中枚举存储是不可能的，而且读起来比较昂贵，甚至更多，以修改存储。合约既不能读也不能写任何存储单元。<strong>storage</strong></p>
<p>第二个内存区域称为内存，其中一个合约为每个消息调用提供新清除的实例。内存是线性的，可以在字节级别上处理，但是读取限制在256位的宽度，而writescan是8位或256位宽。记忆是由一个单词(256位)扩展的，当存取(读或写)一个先前未触及的记忆单词(即。任何offsetwithin一句话)。在扩张的时候，必须支付天然气的费用。记忆是更大的，它生长得更大(它以四倍的速度扩展)。<strong>memory</strong></p>
<p>EVM不是一个注册机器，而是一个堆栈机器，因此在一个称为堆栈的区域上执行所有计算。它的最大大小为1024个元素，包含256位的字。对堆栈的访问以如下方式限制到顶部:可以将最上面的16个元素之一复制到堆栈顶部，或者将最顶层元素与下面16个元素中的一个交换。所有其他操作都从堆栈中获取最多两个(或一个，或更多，取决于操作)元素，并将结果推到堆栈上。当然，可以将堆栈元素移到存储或内存中，但不可能在堆栈中更深入地访问任意元素，而不首先删除堆栈的顶部。<strong>stack</strong></p>
</div>
<div class="section" id="instruction-set">
<span id="index-11"></span><h4>Instruction Set<a class="headerlink" href="#instruction-set" title="Permalink to this headline">¶</a></h4>
<p>为了避免可能导致协商一致问题的正确实现，EVM的指令集保持最小。所有的指令操作在基本数据类型，256位字。通常的算术、位、逻辑和比较运算是存在的。条件和无条件的跳跃是可能的。此外，合约可以访问当前块的相关属性，比如它的编号和时间戳。</p>
</div>
<div class="section" id="message-calls">
<span id="index-12"></span><h4>Message Calls<a class="headerlink" href="#message-calls" title="Permalink to this headline">¶</a></h4>
<p>合约可以通过消息调用的方式调用其他合约或将以太发送到非合约帐户。消息调用类似于事务，因为它们有一个源、一个目标、数据有效负载、以太、气体和返回数据。事实上，每个事务都由一个顶级消息调用组成，而顶级消息调用反过来又可以创建更多的消息调用。</p>
<p>一份合约可以决定其剩余的天然气有多少应该被发送给内部消息，以及它想要保留多少。如果在内部调用(或其他任何异常)中发生了异常，那么将会通过将错误值放到堆栈上来表示。在这种情况下，只使用与呼叫一起发送的气体。在Solidity中，调用合约在这种情况下会导致默认的手动异常，因此异常会“冒泡”调用堆栈。<strong>gas</strong></p>
<p>如前所述，被调用的合约(可以与调用者相同)将接收一个新清除的内存实例，并可以访问所有的有效负载——这将在一个称为calldata的单独区域中提供。在它完成执行之后，它可以返回数据，这些数据将存储在调用者预先分配的调用者的内存中。<strong>calldata</strong></p>
<p>调用的深度为1024，这意味着对于更复杂的操作，循环应该优先于递归调用。<strong>limited</strong></p>
</div>
<div class="section" id="delegatecall-callcode-and-libraries">
<span id="index-13"></span><h4>Delegatecall / Callcode and Libraries<a class="headerlink" href="#delegatecall-callcode-and-libraries" title="Permalink to this headline">¶</a></h4>
<p>存在一种特殊的消息调用变体，它与消息调用完全相同，除了在callingcontract和msg的上下文中执行目标地址的代码。发送者和味精。价值不会改变他们的价值观。<strong>delegatecall</strong><code class="docutils literal"><span class="pre">msg.sender</span></code><code class="docutils literal"><span class="pre">msg.value</span></code></p>
<p>这意味着合约可以在运行时动态地从不同的地址加载代码。存储、当前地址和余额仍然是调用合约，只有代码取自被调用的地址。</p>
<p>这使得实现“库”特性成为可能:可重用的库代码可以应用到合约的存储中，例如，为了实现复杂的数据结构。</p>
</div>
<div class="section" id="logs">
<span id="index-14"></span><h4>Logs<a class="headerlink" href="#logs" title="Permalink to this headline">¶</a></h4>
<p>可以将数据存储在特定索引的数据结构中，这些数据结构映射到块级别。为了实现事件，Solidity使用的这个特性叫做logsis。合约在创建之后不能访问日志数据，但是可以从区块链之外有效地访问它们。由于日志数据的某些部分存储在bloom filters中，因此可以以高效和加密安全的方式搜索这些数据，因此，不下载整个区块链(“light client”)的网络节点仍然可以找到这些日志。<strong>logs</strong><strong>events</strong><a class="reference external" href="https://en.wikipedia.org/wiki/Bloom_filter">bloom filters</a></p>
</div>
<div class="section" id="create">
<span id="index-15"></span><h4>Create<a class="headerlink" href="#create" title="Permalink to this headline">¶</a></h4>
<p>合约甚至可以使用特殊的操作码来创建其他的合约。他们不只是简单地叫零地址。这些创建调用和正常消息调用之间的惟一区别是，负载数据isexecuted和存储为代码的结果和调用者/ creatorreceive在堆栈上接收新合约的地址。<strong>create calls</strong></p>
</div>
<div class="section" id="self-destruct">
<span id="index-16"></span><h4>Self-destruct<a class="headerlink" href="#self-destruct" title="Permalink to this headline">¶</a></h4>
<p>代码从区块链中删除的唯一可能是在该地址的合约执行自毁操作。存储在该地址的剩余的以太会被发送到指定的目标，然后将存储和代码从状态中删除。<code class="docutils literal"><span class="pre">selfdestruct</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">即使合约的代码不包含对自毁的调用，它仍然可以使用delegate atecall或callcode执行该操作。<code class="docutils literal"><span class="pre">selfdestruct</span></code><code class="docutils literal"><span class="pre">delegatecall</span></code><code class="docutils literal"><span class="pre">callcode</span></code></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">旧合约的删节可能或不可能由Ethereumclients实现。此外，归档节点可以选择无限期地保存合约存储和代码。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">目前，外部帐户无法从状态中删除。<strong>external accounts</strong></p>
</div>
</div>
</div>
</div>
<span id="document-installing-solidity"></span><div class="section" id="installing-the-solidity-compiler">
<span id="installing-solidity"></span><span id="index-0"></span><h2>Installing the Solidity Compiler<a class="headerlink" href="#installing-the-solidity-compiler" title="Permalink to this headline">¶</a></h2>
<div class="section" id="versioning">
<h3>Versioning<a class="headerlink" href="#versioning" title="Permalink to this headline">¶</a></h3>
<p>Solidity版本遵循语义版本控制，此外，还可以提供夜间开发构建。夜间的构建不能保证是工作的，尽管他们尽了最大的努力，可能会包含未文档和/或损坏的更改。我们建议使用最新版本。包安装程序将使用最新版本。<a class="reference external" href="https://semver.org">semantic versioning</a><strong>nightly development builds</strong></p>
</div>
<div class="section" id="remix">
<h3>Remix<a class="headerlink" href="#remix" title="Permalink to this headline">¶</a></h3>
<p><em>We recommend Remix for small contracts and for quickly learning Solidity.</em></p>
<p><a class="reference external" href="https://remix.ethereum.org/">Access Remix online</a>在网上重新混音，你不需要安装任何东西。如果你想在没有连接互联网的情况下使用它，那就去https://github.com/ethereum/browser- ty/tree/gh-pages，并下载该页面上的. zip文件。<a class="reference external" href="https://github.com/ethereum/browser-solidity/tree/gh-pages">https://github.com/ethereum/browser-solidity/tree/gh-pages</a></p>
<p>更多的选项，在这个页面细节安装命令行固体编译器软件在您的计算机。如果您需要更多的编译选项，那么选择一个命令行编译器。</p>
</div>
<div class="section" id="npm-node-js">
<span id="solcjs"></span><h3>npm / Node.js<a class="headerlink" href="#npm-node-js" title="Permalink to this headline">¶</a></h3>
<p>使用npm方便和可移植的方式安装solcjs，一个Solidity编译器。这个程序的功能比下面的所有选项都要少。我们使用命令行编译器文档假设您使用的是全功能的编译器solc。因此，如果您从npm安装solcjs，那么您将停止阅读这里的文档，然后继续使用solc-js。<cite>npm</cite><cite>solcjs</cite><cite>solcjs</cite><a class="reference internal" href="index.html#commandline-compiler"><span class="std std-ref">Using the Commandline Compiler</span></a><cite>solc</cite><cite>solcjs</cite><cite>npm</cite><a class="reference external" href="https://github.com/ethereum/solc-js">solc-js</a></p>
<p>注意:solc-js项目是通过使用Emscripten派生的c++ solc。可以直接在JavaScript项目中使用solc-js(例如Remix)。请参考solc-js存储库中的说明。<cite>solc</cite><cite>solc-js</cite></p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">npm</span> <span class="nx">install</span> <span class="o">-</span><span class="nx">g</span> <span class="nx">solc</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>命令行被命名为solcjs。<cite>solcjs</cite></p>
<p class="last">solcjs的comandline选项不兼容solc和工具(如geth)，期望solc的行为不能与solcjs兼容。<cite>solcjs</cite><cite>solc</cite><cite>geth</cite><cite>solc</cite><cite>solcjs</cite></p>
</div>
</div>
<div class="section" id="docker">
<h3>Docker<a class="headerlink" href="#docker" title="Permalink to this headline">¶</a></h3>
<p>我们为编译器提供最新的docker构建。stablerepository包含发布版本，而nightlyrepository包含开发分支中可能不稳定的更改。<code class="docutils literal"><span class="pre">stable</span></code><code class="docutils literal"><span class="pre">nightly</span></code></p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">docker</span> <span class="nx">run</span> <span class="nx">ethereum</span><span class="o">/</span><span class="nx">solc</span><span class="o">:</span><span class="nx">stable</span> <span class="nx">solc</span> <span class="o">--</span><span class="nx">version</span>
</pre></div>
</div>
<p>目前，docker映像只包含编译器可执行文件，因此您必须做一些额外的工作来链接源和输出目录。</p>
</div>
<div class="section" id="binary-packages">
<h3>Binary Packages<a class="headerlink" href="#binary-packages" title="Permalink to this headline">¶</a></h3>
<p>固体的二进制包是可用的。<a class="reference external" href="https://github.com/ethereum/solidity/releases">solidity/releases</a></p>
<p>我们也有Ubuntu的PPAs。为最新的稳定版本。</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">sudo</span> <span class="nx">add</span><span class="o">-</span><span class="nx">apt</span><span class="o">-</span><span class="nx">repository</span> <span class="nx">ppa</span><span class="o">:</span><span class="nx">ethereum</span><span class="o">/</span><span class="nx">ethereum</span>
<span class="nx">sudo</span> <span class="nx">apt</span><span class="o">-</span><span class="nx">get</span> <span class="nx">update</span>
<span class="nx">sudo</span> <span class="nx">apt</span><span class="o">-</span><span class="nx">get</span> <span class="nx">install</span> <span class="nx">solc</span>
</pre></div>
</div>
<p>如果你想使用最前沿的开发人员版本:</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">sudo</span> <span class="nx">add</span><span class="o">-</span><span class="nx">apt</span><span class="o">-</span><span class="nx">repository</span> <span class="nx">ppa</span><span class="o">:</span><span class="nx">ethereum</span><span class="o">/</span><span class="nx">ethereum</span>
<span class="nx">sudo</span> <span class="nx">add</span><span class="o">-</span><span class="nx">apt</span><span class="o">-</span><span class="nx">repository</span> <span class="nx">ppa</span><span class="o">:</span><span class="nx">ethereum</span><span class="o">/</span><span class="nx">ethereum</span><span class="o">-</span><span class="nx">dev</span>
<span class="nx">sudo</span> <span class="nx">apt</span><span class="o">-</span><span class="nx">get</span> <span class="nx">update</span>
<span class="nx">sudo</span> <span class="nx">apt</span><span class="o">-</span><span class="nx">get</span> <span class="nx">install</span> <span class="nx">solc</span>
</pre></div>
</div>
<p>我们还将发布一个snap包，它可以在所有受支持的Linux发行版中安装。安装最新稳定版solc:<a class="reference external" href="https://snapcraft.io/">snap package</a><a class="reference external" href="https://snapcraft.io/docs/core/install">supported Linux distros</a></p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">sudo</span> <span class="nx">snap</span> <span class="nx">install</span> <span class="nx">solc</span>
</pre></div>
</div>
<p>或者，如果您想帮助测试不稳定的solc，并使用开发分支最近的更改:</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">sudo</span> <span class="nx">snap</span> <span class="nx">install</span> <span class="nx">solc</span> <span class="o">--</span><span class="nx">edge</span>
</pre></div>
</div>
<p>Arch Linux也有包，尽管仅限于最新的开发版本:</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">pacman</span> <span class="o">-</span><span class="nx">S</span> <span class="nx">solidity</span>
</pre></div>
</div>
<p>在写文章的时候，在詹金斯(Jenkins)到特拉维西(TravisCI)的迁移之后，Homebrew正在丢失预置的瓶子，但homebrewworks仍然可以作为从源头构建的一种手段。我们将很快重新添加预建的瓶子。</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">brew</span> <span class="nx">update</span>
<span class="nx">brew</span> <span class="nx">upgrade</span>
<span class="nx">brew</span> <span class="nx">tap</span> <span class="nx">ethereum</span><span class="o">/</span><span class="nx">ethereum</span>
<span class="nx">brew</span> <span class="nx">install</span> <span class="nx">solidity</span>
</pre></div>
</div>
<p>如果你需要一个特定版本的固体，你可以直接从Github上安装aHomebrew公式。</p>
<p>Viewsolidity。在Github rb提交。<a class="reference external" href="https://github.com/ethereum/homebrew-ethereum/commits/master/solidity.rb">solidity.rb commits on Github</a></p>
<p>跟踪历史链接，直到您有一个关于固化的特定提交的原始文件链接。<code class="docutils literal"><span class="pre">solidity.rb</span></code></p>
<p>安装使用酿造:<code class="docutils literal"><span class="pre">brew</span></code></p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">brew</span> <span class="nx">unlink</span> <span class="nx">solidity</span>
<span class="err">#</span> <span class="nx">Install</span> <span class="mf">0.4</span><span class="p">.</span><span class="mi">8</span>
<span class="nx">brew</span> <span class="nx">install</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//raw.githubusercontent.com/ethereum/homebrew-ethereum/77cce03da9f289e5a3ffe579840d3c5dc0a62717/solidity.rb</span>
</pre></div>
</div>
<p>Gentoo Linux还提供了一个可以使用出现的solidity包:<code class="docutils literal"><span class="pre">emerge</span></code></p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">emerge</span> <span class="nx">dev</span><span class="o">-</span><span class="nx">lang</span><span class="o">/</span><span class="nx">solidity</span>
</pre></div>
</div>
</div>
<div class="section" id="building-from-source">
<span id="id1"></span><h3>Building from Source<a class="headerlink" href="#building-from-source" title="Permalink to this headline">¶</a></h3>
<div class="section" id="clone-the-repository">
<h4>Clone the Repository<a class="headerlink" href="#clone-the-repository" title="Permalink to this headline">¶</a></h4>
<p>要克隆源代码，执行以下命令:</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">git</span> <span class="nx">clone</span> <span class="o">--</span><span class="nx">recursive</span> <span class="nx">https</span><span class="o">:</span><span class="c1">//github.com/ethereum/solidity.git</span>
<span class="nx">cd</span> <span class="nx">solidity</span>
</pre></div>
</div>
<p>如果你想帮助发展固体，你应该用叉子把你的个人叉子作为第二个遥控器:</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">cd</span> <span class="nx">solidity</span>
<span class="nx">git</span> <span class="nx">remote</span> <span class="nx">add</span> <span class="nx">personal</span> <span class="nx">git</span><span class="err">@</span><span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">:</span><span class="p">[</span><span class="nx">username</span><span class="p">]</span><span class="o">/</span><span class="nx">solidity</span><span class="p">.</span><span class="nx">git</span>
</pre></div>
</div>
<p>可靠性git子。确保正确加载:</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">git</span> <span class="nx">submodule</span> <span class="nx">update</span> <span class="o">--</span><span class="nx">init</span> <span class="o">--</span><span class="nx">recursive</span>
</pre></div>
</div>
</div>
<div class="section" id="prerequisites-macos">
<h4>Prerequisites - macOS<a class="headerlink" href="#prerequisites-macos" title="Permalink to this headline">¶</a></h4>
<p>对于macOS，请确保安装了最新版本的xcode。它包含了Clang c++编译器、xcode IDE和其他用于在OS X上构建c++应用程序所需的苹果开发工具。如果您第一次安装了Xcode，或者刚刚安装了一个新版本，那么您就需要在您可以使用命令行构建之前同意这个许可:<a class="reference external" href="https://developer.apple.com/xcode/download/">Xcode installed</a><a class="reference external" href="https://en.wikipedia.org/wiki/Clang">Clang C++ compiler</a><a class="reference external" href="https://en.wikipedia.org/wiki/Xcode">Xcode IDE</a></p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">sudo</span> <span class="nx">xcodebuild</span> <span class="o">-</span><span class="nx">license</span> <span class="nx">accept</span>
</pre></div>
</div>
<p>我们的OS X构建要求您安装Homebrewpackage管理器来安装外部依赖项。如果你想从头再来，下面是如何卸载Homebrew的方法。<a class="reference external" href="http://brew.sh">install the Homebrew</a><a class="reference external" href="https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/FAQ.md#how-do-i-uninstall-homebrew">uninstall Homebrew</a></p>
</div>
<div class="section" id="prerequisites-windows">
<h4>Prerequisites - Windows<a class="headerlink" href="#prerequisites-windows" title="Permalink to this headline">¶</a></h4>
<p>您将需要安装以下对Windows构建的依赖关系:</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%"/>
<col width="61%"/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Software</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference external" href="https://git-scm.com/download/win">Git for Windows</a></td>
<td>Command-line tool for retrieving source from Github.</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="https://cmake.org/download/">CMake</a></td>
<td>Cross-platform build file generator.</td>
</tr>
<tr class="row-even"><td><a class="reference external" href="https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017">Visual Studio 2017 Build Tools</a></td>
<td>C++ compiler</td>
</tr>
<tr class="row-odd"><td><a class="reference external" href="https://www.visualstudio.com/vs/">Visual Studio 2017</a>  (Optional)</td>
<td>C++ compiler and dev environment.</td>
</tr>
</tbody>
</table>
<p>如果您已经有一个IDE并且只需要编译器和库，那么您可以安装Visual Studio 2017构建工具。</p>
<p>Visual Studio 2017提供了IDE和必要的编译器和库。因此，如果您没有IDE，并且更喜欢开发solidity, Visual Studio 2017可能是您可以轻松实现所有设置的一个选择。</p>
<p>以下是2017年安装Visual Studio 2017构建工具或Visual Studio 2017的组件列表:</p>
<ul class="simple">
<li>Visual Studio C++ core features</li>
<li>VC++ 2017 v141 toolset (x86,x64)</li>
<li>Windows Universal CRT SDK</li>
<li>Windows 8.1 SDK</li>
<li>C++/CLI support</li>
</ul>
</div>
<div class="section" id="external-dependencies">
<h4>External Dependencies<a class="headerlink" href="#external-dependencies" title="Permalink to this headline">¶</a></h4>
<p>我们现在有一个“一个按钮”脚本，它安装所有需要的外部依赖的macOS、Windows和许多Linux发行版。这曾经是一个多步骤手工的过程，但现在是一行:</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="nx">scripts</span><span class="o">/</span><span class="nx">install_deps</span><span class="p">.</span><span class="nx">sh</span>
</pre></div>
</div>
<p>或者,在Windows上:</p>
<div class="code bat highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">scripts</span><span class="err">\</span><span class="nx">install_deps</span><span class="p">.</span><span class="nx">bat</span>
</pre></div>
</div>
</div>
<div class="section" id="command-line-build">
<h4>Command-Line Build<a class="headerlink" href="#command-line-build" title="Permalink to this headline">¶</a></h4>
<p><strong>Be sure to install External Dependencies (see above) before build.</strong></p>
<p>Solidity项目使用CMake来配置构建。在Linux、macOS和其他Unices中，构建可靠性非常相似:</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">mkdir</span> <span class="nx">build</span>
<span class="nx">cd</span> <span class="nx">build</span>
<span class="nx">cmake</span> <span class="p">..</span> <span class="o">&amp;&amp;</span> <span class="nx">make</span>
</pre></div>
</div>
<p>或者更简单:</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="err">#</span><span class="nx">note</span><span class="o">:</span> <span class="k">this</span> <span class="nx">will</span> <span class="nx">install</span> <span class="nx">binaries</span> <span class="nx">solc</span> <span class="nx">and</span> <span class="nx">soltest</span> <span class="nx">at</span> <span class="nx">usr</span><span class="o">/</span><span class="nx">local</span><span class="o">/</span><span class="nx">bin</span>
<span class="p">.</span><span class="o">/</span><span class="nx">scripts</span><span class="o">/</span><span class="nx">build</span><span class="p">.</span><span class="nx">sh</span>
</pre></div>
</div>
<p>甚至为Windows:</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">mkdir</span> <span class="nx">build</span>
<span class="nx">cd</span> <span class="nx">build</span>
<span class="nx">cmake</span> <span class="o">-</span><span class="nx">G</span> <span class="s2">"Visual Studio 15 2017 Win64"</span> <span class="p">..</span>
</pre></div>
</div>
<p>这后一组指令应该会产生Solidity。在那个构建目录中。双击该文件可以导致Visual Studio启动。我们建议使用buildingRelWithDebugInfo配置，但其他所有工作都可以。<strong>solidity.sln</strong><strong>RelWithDebugInfo</strong></p>
<p>或者，您可以在命令行上构建Windows，比如:</p>
<div class="code bash highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">cmake</span> <span class="o">--</span><span class="nx">build</span> <span class="p">.</span> <span class="o">--</span><span class="nx">config</span> <span class="nx">RelWithDebInfo</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="cmake-options">
<h3>CMake options<a class="headerlink" href="#cmake-options" title="Permalink to this headline">¶</a></h3>
<p>如果您感兴趣的话，可以使用CMake选项。lh。<code class="docutils literal"><span class="pre">cmake</span> <span class="pre">..</span> <span class="pre">-LH</span></code></p>
</div>
<div class="section" id="the-version-string-in-detail">
<h3>The version string in detail<a class="headerlink" href="#the-version-string-in-detail" title="Permalink to this headline">¶</a></h3>
<p>Solidity版本字符串包含四个部分:</p>
<ul class="simple">
<li>the version number</li>
<li>pre-release tag, usually set to <code class="docutils literal"><span class="pre">develop.YYYY.MM.DD</span></code> or <code class="docutils literal"><span class="pre">nightly.YYYY.MM.DD</span></code></li>
<li>commit in the format of <code class="docutils literal"><span class="pre">commit.GITHASH</span></code></li>
<li>platform has arbitrary number of items, containing details about the platform and compiler</li>
</ul>
<p>如果有局部修改，则提交将以.mod为后缀。<code class="docutils literal"><span class="pre">.mod</span></code></p>
<p>这些部分是由Semver所要求的，其中Solidity预发布标记等于Semver预发布，而Solidity commit和platform组合构成了Semver构建元数据。</p>
<p>一个释放的例子:0.4.8 + commit.60cc1668.Emscripten.clang。<code class="docutils literal"><span class="pre">0.4.8+commit.60cc1668.Emscripten.clang</span></code></p>
<p>一个预发布的例子:0.4.9-nightly.2017.1.17 + commit.6ecb4aa3.Emscripten.clang<code class="docutils literal"><span class="pre">0.4.9-nightly.2017.1.17+commit.6ecb4aa3.Emscripten.clang</span></code></p>
</div>
<div class="section" id="important-information-about-versioning">
<h3>Important information about versioning<a class="headerlink" href="#important-information-about-versioning" title="Permalink to this headline">¶</a></h3>
<p>在发布版本之后，补丁版本级别会被替换，因为我们假设只有补丁级别的变化会发生。在合并更改时，应该根据semver和变更的严重程度来调整版本。最后，总是使用当前夜间构建的版本进行发布，但不使用预发布的说明符。<code class="docutils literal"><span class="pre">prerelease</span></code></p>
<p>例子:</p>
<ol class="arabic simple" start="0">
<li>the 0.4.0 release is made</li>
<li>nightly build has a version of 0.4.1 from now on</li>
<li>non-breaking changes are introduced - no change in version</li>
<li>a breaking change is introduced - version is bumped to 0.5.0</li>
<li>the 0.5.0 release is made</li>
</ol>
<p>这种行为与pragma的版本很好。<a class="reference internal" href="index.html#version-pragma"><span class="std std-ref">version pragma</span></a></p>
</div>
</div>
<span id="document-solidity-by-example"></span><div class="section" id="solidity-by-example">
<h2>Solidity by Example<a class="headerlink" href="#solidity-by-example" title="Permalink to this headline">¶</a></h2>
<div class="section" id="voting">
<span id="index-0"></span><span id="id1"></span><h3>Voting<a class="headerlink" href="#voting" title="Permalink to this headline">¶</a></h3>
<p>下面的合约相当复杂，但却显示出了大量的可靠性。它实现了votingcontract。当然，电子投票的主要问题是如何给正确的人分配投票权以及如何防止操纵。我们不会解决所有的问题，但至少我们会进行授权投票，这样投票就会自动而且完全透明。<strong>automatic and completely transparent</strong></p>
<p>其想法是为每个选项创建一个合约，为每个选项提供一个简短的名称。然后，担任主席的合约的缔约人将给予每个人单独投票的权利。</p>
<p>地址后面的人可以选择投自己的票或者把票投给他们信任的人。</p>
<p>在投票结束时，winningProposal()将以最大的票数返回提案。<code class="docutils literal"><span class="pre">winningProposal()</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="cs">/// </span><span class="k">@title</span><span class="cs"> Voting with delegation.</span>
<span class="kd">contract</span> <span class="nx">Ballot</span> <span class="p">{</span>
    <span class="c1">// This declares a new complex type which will</span>
    <span class="c1">// be used for variables later.</span>
    <span class="c1">// It will represent a single voter.</span>
    <span class="kd">struct</span> <span class="nx">Voter</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">weight</span><span class="p">;</span> <span class="c1">// weight is accumulated by delegation</span>
        <span class="kt">bool</span> <span class="nx">voted</span><span class="p">;</span>  <span class="c1">// if true, that person already voted</span>
        <span class="kt">address</span> <span class="nx">delegate</span><span class="p">;</span> <span class="c1">// person delegated to</span>
        <span class="kt">uint</span> <span class="nx">vote</span><span class="p">;</span>   <span class="c1">// index of the voted proposal</span>
    <span class="p">}</span>

    <span class="c1">// This is a type for a single proposal.</span>
    <span class="kd">struct</span> <span class="nx">Proposal</span> <span class="p">{</span>
        <span class="kt">bytes32</span> <span class="nx">name</span><span class="p">;</span>   <span class="c1">// short name (up to 32 bytes)</span>
        <span class="kt">uint</span> <span class="nx">voteCount</span><span class="p">;</span> <span class="c1">// number of accumulated votes</span>
    <span class="p">}</span>

    <span class="kt">address</span> <span class="k">public</span> <span class="nx">chairperson</span><span class="p">;</span>

    <span class="c1">// This declares a state variable that</span>
    <span class="c1">// stores a `Voter` struct for each possible address.</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="nx">Voter</span><span class="p">)</span> <span class="k">public</span> <span class="nx">voters</span><span class="p">;</span>

    <span class="c1">// A dynamically-sized array of `Proposal` structs.</span>
    <span class="nx">Proposal</span><span class="p">[]</span> <span class="k">public</span> <span class="nx">proposals</span><span class="p">;</span>

    <span class="cs">/// Create a new ballot to choose one of `proposalNames`.</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="kt">bytes32</span><span class="p">[]</span> <span class="nx">proposalNames</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">chairperson</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
        <span class="nx">voters</span><span class="p">[</span><span class="nx">chairperson</span><span class="p">].</span><span class="nx">weight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// For each of the provided proposal names,</span>
        <span class="c1">// create a new proposal object and add it</span>
        <span class="c1">// to the end of the array.</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">proposalNames</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// `Proposal({...})` creates a temporary</span>
            <span class="c1">// Proposal object and `proposals.push(...)`</span>
            <span class="c1">// appends it to the end of `proposals`.</span>
            <span class="nx">proposals</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Proposal</span><span class="p">({</span>
                <span class="nx">name</span><span class="o">:</span> <span class="nx">proposalNames</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span>
                <span class="nx">voteCount</span><span class="o">:</span> <span class="mi">0</span>
            <span class="p">}));</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Give `voter` the right to vote on this ballot.</span>
    <span class="c1">// May only be called by `chairperson`.</span>
    <span class="kd">function</span> <span class="nx">giveRightToVote</span><span class="p">(</span><span class="kt">address</span> <span class="nx">voter</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// If the first argument of `require` evaluates</span>
        <span class="c1">// to `false`, execution terminates and all</span>
        <span class="c1">// changes to the state and to Ether balances</span>
        <span class="c1">// are reverted.</span>
        <span class="c1">// This used to consume all gas in old EVM versions, but</span>
        <span class="c1">// not anymore.</span>
        <span class="c1">// It is often a good idea to use `require` to check if</span>
        <span class="c1">// functions are called correctly.</span>
        <span class="c1">// As a second argument, you can also provide an</span>
        <span class="c1">// explanation about what went wrong.</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">chairperson</span><span class="p">,</span>
            <span class="s2">"Only chairperson can give right to vote."</span>
        <span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="o">!</span><span class="nx">voters</span><span class="p">[</span><span class="nx">voter</span><span class="p">].</span><span class="nx">voted</span><span class="p">,</span>
            <span class="s2">"The voter already voted."</span>
        <span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="nx">voters</span><span class="p">[</span><span class="nx">voter</span><span class="p">].</span><span class="nx">weight</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nx">voters</span><span class="p">[</span><span class="nx">voter</span><span class="p">].</span><span class="nx">weight</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// Delegate your vote to the voter `to`.</span>
    <span class="kd">function</span> <span class="nx">delegate</span><span class="p">(</span><span class="kt">address</span> <span class="nx">to</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// assigns reference</span>
        <span class="nx">Voter</span> <span class="k">storage</span> <span class="nx">sender</span> <span class="o">=</span> <span class="nx">voters</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
        <span class="nb">require</span><span class="p">(</span><span class="o">!</span><span class="nx">sender</span><span class="p">.</span><span class="nx">voted</span><span class="p">,</span> <span class="s2">"You already voted."</span><span class="p">);</span>

        <span class="nb">require</span><span class="p">(</span><span class="nx">to</span> <span class="o">!=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="s2">"Self-delegation is disallowed."</span><span class="p">);</span>

        <span class="c1">// Forward the delegation as long as</span>
        <span class="c1">// `to` also delegated.</span>
        <span class="c1">// In general, such loops are very dangerous,</span>
        <span class="c1">// because if they run too long, they might</span>
        <span class="c1">// need more gas than is available in a block.</span>
        <span class="c1">// In this case, the delegation will not be executed,</span>
        <span class="c1">// but in other situations, such loops might</span>
        <span class="c1">// cause a contract to get "stuck" completely.</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">voters</span><span class="p">[</span><span class="nx">to</span><span class="p">].</span><span class="nx">delegate</span> <span class="o">!=</span> <span class="kt">address</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">to</span> <span class="o">=</span> <span class="nx">voters</span><span class="p">[</span><span class="nx">to</span><span class="p">].</span><span class="nx">delegate</span><span class="p">;</span>

            <span class="c1">// We found a loop in the delegation, not allowed.</span>
            <span class="nb">require</span><span class="p">(</span><span class="nx">to</span> <span class="o">!=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="s2">"Found loop in delegation."</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Since `sender` is a reference, this</span>
        <span class="c1">// modifies `voters[msg.sender].voted`</span>
        <span class="nx">sender</span><span class="p">.</span><span class="nx">voted</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">sender</span><span class="p">.</span><span class="nx">delegate</span> <span class="o">=</span> <span class="nx">to</span><span class="p">;</span>
        <span class="nx">Voter</span> <span class="k">storage</span> <span class="nx">delegate_</span> <span class="o">=</span> <span class="nx">voters</span><span class="p">[</span><span class="nx">to</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">delegate_</span><span class="p">.</span><span class="nx">voted</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// If the delegate already voted,</span>
            <span class="c1">// directly add to the number of votes</span>
            <span class="nx">proposals</span><span class="p">[</span><span class="nx">delegate_</span><span class="p">.</span><span class="nx">vote</span><span class="p">].</span><span class="nx">voteCount</span> <span class="o">+=</span> <span class="nx">sender</span><span class="p">.</span><span class="nx">weight</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// If the delegate did not vote yet,</span>
            <span class="c1">// add to her weight.</span>
            <span class="nx">delegate_</span><span class="p">.</span><span class="nx">weight</span> <span class="o">+=</span> <span class="nx">sender</span><span class="p">.</span><span class="nx">weight</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cs">/// Give your vote (including votes delegated to you)</span>
    <span class="cs">/// to proposal `proposals[proposal].name`.</span>
    <span class="kd">function</span> <span class="nx">vote</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">proposal</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">Voter</span> <span class="k">storage</span> <span class="nx">sender</span> <span class="o">=</span> <span class="nx">voters</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
        <span class="nb">require</span><span class="p">(</span><span class="o">!</span><span class="nx">sender</span><span class="p">.</span><span class="nx">voted</span><span class="p">,</span> <span class="s2">"Already voted."</span><span class="p">);</span>
        <span class="nx">sender</span><span class="p">.</span><span class="nx">voted</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">sender</span><span class="p">.</span><span class="nx">vote</span> <span class="o">=</span> <span class="nx">proposal</span><span class="p">;</span>

        <span class="c1">// If `proposal` is out of the range of the array,</span>
        <span class="c1">// this will throw automatically and revert all</span>
        <span class="c1">// changes.</span>
        <span class="nx">proposals</span><span class="p">[</span><span class="nx">proposal</span><span class="p">].</span><span class="nx">voteCount</span> <span class="o">+=</span> <span class="nx">sender</span><span class="p">.</span><span class="nx">weight</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// </span><span class="k">@dev</span><span class="cs"> Computes the winning proposal taking all</span>
    <span class="cs">/// previous votes into account.</span>
    <span class="kd">function</span> <span class="nx">winningProposal</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span>
            <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">winningProposal_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">winningVoteCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">p</span> <span class="o">&lt;</span> <span class="nx">proposals</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">proposals</span><span class="p">[</span><span class="nx">p</span><span class="p">].</span><span class="nx">voteCount</span> <span class="o">&gt;</span> <span class="nx">winningVoteCount</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">winningVoteCount</span> <span class="o">=</span> <span class="nx">proposals</span><span class="p">[</span><span class="nx">p</span><span class="p">].</span><span class="nx">voteCount</span><span class="p">;</span>
                <span class="nx">winningProposal_</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Calls winningProposal() function to get the index</span>
    <span class="c1">// of the winner contained in the proposals array and then</span>
    <span class="c1">// returns the name of the winner</span>
    <span class="kd">function</span> <span class="nx">winnerName</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span>
            <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span> <span class="nx">winnerName_</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">winnerName_</span> <span class="o">=</span> <span class="nx">proposals</span><span class="p">[</span><span class="nx">winningProposal</span><span class="p">()].</span><span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="possible-improvements">
<h4>Possible Improvements<a class="headerlink" href="#possible-improvements" title="Permalink to this headline">¶</a></h4>
<p>目前，许多交易都需要分配给所有参与者的权利。你能想出更好的办法吗?</p>
</div>
</div>
<div class="section" id="blind-auction">
<span id="index-1"></span><h3>Blind Auction<a class="headerlink" href="#blind-auction" title="Permalink to this headline">¶</a></h3>
<p>在本节中，我们将展示在Ethereum上创建一个完全盲目的拍卖合约是多么容易。我们将从一个公开的拍卖开始，每个人都可以看到自己的出价，然后将这个合约延伸到一个盲目的拍卖中，在这个拍卖结束之前，我们不可能看到实际的出价。</p>
<div class="section" id="simple-open-auction">
<span id="simple-auction"></span><h4>Simple Open Auction<a class="headerlink" href="#simple-open-auction" title="Permalink to this headline">¶</a></h4>
<p>下面简单的拍卖合约的大意是，每个人都可以在竞标期间发送他们的报价。投标已经包括了sendingmoney / ether，以便将投标人与他们的投标联系起来。如果出价最高，出价最高的投标者就能收回她的钱。在投标结束后，为了受益人收到他的钱，合约必须手工调用，合约不能自行启动。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">SimpleAuction</span> <span class="p">{</span>
    <span class="c1">// Parameters of the auction. Times are either</span>
    <span class="c1">// absolute unix timestamps (seconds since 1970-01-01)</span>
    <span class="c1">// or time periods in seconds.</span>
    <span class="kt">address</span> <span class="k">public</span> <span class="nx">beneficiary</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">auctionEnd</span><span class="p">;</span>

    <span class="c1">// Current state of the auction.</span>
    <span class="kt">address</span> <span class="k">public</span> <span class="nx">highestBidder</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">highestBid</span><span class="p">;</span>

    <span class="c1">// Allowed withdrawals of previous bids</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="nx">pendingReturns</span><span class="p">;</span>

    <span class="c1">// Set to true at the end, disallows any change</span>
    <span class="kt">bool</span> <span class="nx">ended</span><span class="p">;</span>

    <span class="c1">// Events that will be fired on changes.</span>
    <span class="kd">event</span> <span class="nx">HighestBidIncreased</span><span class="p">(</span><span class="kt">address</span> <span class="nx">bidder</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">amount</span><span class="p">);</span>
    <span class="kd">event</span> <span class="nx">AuctionEnded</span><span class="p">(</span><span class="kt">address</span> <span class="nx">winner</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">amount</span><span class="p">);</span>

    <span class="c1">// The following is a so-called natspec comment,</span>
    <span class="c1">// recognizable by the three slashes.</span>
    <span class="c1">// It will be shown when the user is asked to</span>
    <span class="c1">// confirm a transaction.</span>

    <span class="cs">/// Create a simple auction with `_biddingTime`</span>
    <span class="cs">/// seconds bidding time on behalf of the</span>
    <span class="cs">/// beneficiary address `_beneficiary`.</span>
    <span class="nx">constructor</span><span class="p">(</span>
        <span class="kt">uint</span> <span class="nx">_biddingTime</span><span class="p">,</span>
        <span class="kt">address</span> <span class="nx">_beneficiary</span>
    <span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">beneficiary</span> <span class="o">=</span> <span class="nx">_beneficiary</span><span class="p">;</span>
        <span class="nx">auctionEnd</span> <span class="o">=</span> <span class="nb">now</span> <span class="o">+</span> <span class="nx">_biddingTime</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// Bid on the auction with the value sent</span>
    <span class="cs">/// together with this transaction.</span>
    <span class="cs">/// The value will only be refunded if the</span>
    <span class="cs">/// auction is not won.</span>
    <span class="kd">function</span> <span class="nx">bid</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="c1">// No arguments are necessary, all</span>
        <span class="c1">// information is already part of</span>
        <span class="c1">// the transaction. The keyword payable</span>
        <span class="c1">// is required for the function to</span>
        <span class="c1">// be able to receive Ether.</span>

        <span class="c1">// Revert the call if the bidding</span>
        <span class="c1">// period is over.</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nb">now</span> <span class="o">&lt;=</span> <span class="nx">auctionEnd</span><span class="p">,</span>
            <span class="s2">"Auction already ended."</span>
        <span class="p">);</span>

        <span class="c1">// If the bid is not higher, send the</span>
        <span class="c1">// money back.</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="nx">highestBid</span><span class="p">,</span>
            <span class="s2">"There already is a higher bid."</span>
        <span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">highestBid</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Sending back the money by simply using</span>
            <span class="c1">// highestBidder.send(highestBid) is a security risk</span>
            <span class="c1">// because it could execute an untrusted contract.</span>
            <span class="c1">// It is always safer to let the recipients</span>
            <span class="c1">// withdraw their money themselves.</span>
            <span class="nx">pendingReturns</span><span class="p">[</span><span class="nx">highestBidder</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">highestBid</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">highestBidder</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
        <span class="nx">highestBid</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
        <span class="nx">emit</span> <span class="nx">HighestBidIncreased</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cs">/// Withdraw a bid that was overbid.</span>
    <span class="kd">function</span> <span class="nx">withdraw</span><span class="p">()</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">amount</span> <span class="o">=</span> <span class="nx">pendingReturns</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// It is important to set this to zero because the recipient</span>
            <span class="c1">// can call this function again as part of the receiving call</span>
            <span class="c1">// before `send` returns.</span>
            <span class="nx">pendingReturns</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">amount</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// No need to call throw here, just reset the amount owing</span>
                <span class="nx">pendingReturns</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">=</span> <span class="nx">amount</span><span class="p">;</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// End the auction and send the highest bid</span>
    <span class="cs">/// to the beneficiary.</span>
    <span class="kd">function</span> <span class="nx">auctionEnd</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// It is a good guideline to structure functions that interact</span>
        <span class="c1">// with other contracts (i.e. they call functions or send Ether)</span>
        <span class="c1">// into three phases:</span>
        <span class="c1">// 1. checking conditions</span>
        <span class="c1">// 2. performing actions (potentially changing conditions)</span>
        <span class="c1">// 3. interacting with other contracts</span>
        <span class="c1">// If these phases are mixed up, the other contract could call</span>
        <span class="c1">// back into the current contract and modify the state or cause</span>
        <span class="c1">// effects (ether payout) to be performed multiple times.</span>
        <span class="c1">// If functions called internally include interaction with external</span>
        <span class="c1">// contracts, they also have to be considered interaction with</span>
        <span class="c1">// external contracts.</span>

        <span class="c1">// 1. Conditions</span>
        <span class="nb">require</span><span class="p">(</span><span class="nb">now</span> <span class="o">&gt;=</span> <span class="nx">auctionEnd</span><span class="p">,</span> <span class="s2">"Auction not yet ended."</span><span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="o">!</span><span class="nx">ended</span><span class="p">,</span> <span class="s2">"auctionEnd has already been called."</span><span class="p">);</span>

        <span class="c1">// 2. Effects</span>
        <span class="nx">ended</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">emit</span> <span class="nx">AuctionEnded</span><span class="p">(</span><span class="nx">highestBidder</span><span class="p">,</span> <span class="nx">highestBid</span><span class="p">);</span>

        <span class="c1">// 3. Interaction</span>
        <span class="nx">beneficiary</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">highestBid</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id2">
<h4>Blind Auction<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>之前的公开拍卖被扩展到以下的盲人拍卖。盲目拍卖的好处是，拍卖结束时没有时间压力。在atransparent的计算平台上进行盲目的拍卖听起来可能像一场灾难，但密码术拯救了我们。</p>
<p>在投标期间，投标人实际上并没有发送她的投标，但只是一个哈希版本。由于目前认为找到两个(足够长的)值是不可能的，所以投标人提交了该报价。在投标结束后，投标人必须披露其投标:他们将其价值未加密的和合约检查的哈希值与投标期间提供的报价相同。<strong>bidding period</strong></p>
<p>另一个挑战是如何让拍卖品与盲人同时进行:唯一的办法就是让买家在拍卖后不把钱寄出去，而是让她连同出价一起寄出。因为价值转移不会在以太中被蒙蔽，任何人都可以看到它的价值。<strong>binding and blind</strong></p>
<p>下面的合约通过接受大于最高出价的任何值来解决这个问题。因为这当然只能在显示阶段进行检查，有些投标可能是无效的，而且这是故意的(它甚至提供了一个明确的标记来将无效的出价与高价值转移):投标方可以通过放置几个高或低无效的投标来迷惑竞争。<strong>invalid</strong></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">BlindAuction</span> <span class="p">{</span>
    <span class="kd">struct</span> <span class="nx">Bid</span> <span class="p">{</span>
        <span class="kt">bytes32</span> <span class="nx">blindedBid</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="nx">deposit</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">address</span> <span class="k">public</span> <span class="nx">beneficiary</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">biddingEnd</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">revealEnd</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="k">public</span> <span class="nx">ended</span><span class="p">;</span>

    <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="nx">Bid</span><span class="p">[])</span> <span class="k">public</span> <span class="nx">bids</span><span class="p">;</span>

    <span class="kt">address</span> <span class="k">public</span> <span class="nx">highestBidder</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">highestBid</span><span class="p">;</span>

    <span class="c1">// Allowed withdrawals of previous bids</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="nx">pendingReturns</span><span class="p">;</span>

    <span class="kd">event</span> <span class="nx">AuctionEnded</span><span class="p">(</span><span class="kt">address</span> <span class="nx">winner</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">highestBid</span><span class="p">);</span>

    <span class="cs">/// Modifiers are a convenient way to validate inputs to</span>
    <span class="cs">/// functions. `onlyBefore` is applied to `bid` below:</span>
    <span class="cs">/// The new function body is the modifier's body where</span>
    <span class="cs">/// `_` is replaced by the old function body.</span>
    <span class="kd">modifier</span> <span class="nx">onlyBefore</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_time</span><span class="p">)</span> <span class="p">{</span> <span class="nb">require</span><span class="p">(</span><span class="nb">now</span> <span class="o">&lt;</span> <span class="nx">_time</span><span class="p">);</span> <span class="nx">_</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">modifier</span> <span class="nx">onlyAfter</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_time</span><span class="p">)</span> <span class="p">{</span> <span class="nb">require</span><span class="p">(</span><span class="nb">now</span> <span class="o">&gt;</span> <span class="nx">_time</span><span class="p">);</span> <span class="nx">_</span><span class="p">;</span> <span class="p">}</span>

    <span class="nx">constructor</span><span class="p">(</span>
        <span class="kt">uint</span> <span class="nx">_biddingTime</span><span class="p">,</span>
        <span class="kt">uint</span> <span class="nx">_revealTime</span><span class="p">,</span>
        <span class="kt">address</span> <span class="nx">_beneficiary</span>
    <span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">beneficiary</span> <span class="o">=</span> <span class="nx">_beneficiary</span><span class="p">;</span>
        <span class="nx">biddingEnd</span> <span class="o">=</span> <span class="nb">now</span> <span class="o">+</span> <span class="nx">_biddingTime</span><span class="p">;</span>
        <span class="nx">revealEnd</span> <span class="o">=</span> <span class="nx">biddingEnd</span> <span class="o">+</span> <span class="nx">_revealTime</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// Place a blinded bid with `_blindedBid` = keccak256(value,</span>
    <span class="cs">/// fake, secret).</span>
    <span class="cs">/// The sent ether is only refunded if the bid is correctly</span>
    <span class="cs">/// revealed in the revealing phase. The bid is valid if the</span>
    <span class="cs">/// ether sent together with the bid is at least "value" and</span>
    <span class="cs">/// "fake" is not true. Setting "fake" to true and sending</span>
    <span class="cs">/// not the exact amount are ways to hide the real bid but</span>
    <span class="cs">/// still make the required deposit. The same address can</span>
    <span class="cs">/// place multiple bids.</span>
    <span class="kd">function</span> <span class="nx">bid</span><span class="p">(</span><span class="kt">bytes32</span> <span class="nx">_blindedBid</span><span class="p">)</span>
        <span class="k">public</span>
        <span class="k">payable</span>
        <span class="nx">onlyBefore</span><span class="p">(</span><span class="nx">biddingEnd</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">bids</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">].</span><span class="nx">push</span><span class="p">(</span><span class="nx">Bid</span><span class="p">({</span>
            <span class="nx">blindedBid</span><span class="o">:</span> <span class="nx">_blindedBid</span><span class="p">,</span>
            <span class="nx">deposit</span><span class="o">:</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span>
        <span class="p">}));</span>
    <span class="p">}</span>

    <span class="cs">/// Reveal your blinded bids. You will get a refund for all</span>
    <span class="cs">/// correctly blinded invalid bids and for all bids except for</span>
    <span class="cs">/// the totally highest.</span>
    <span class="kd">function</span> <span class="nx">reveal</span><span class="p">(</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="nx">_values</span><span class="p">,</span>
        <span class="kt">bool</span><span class="p">[]</span> <span class="nx">_fake</span><span class="p">,</span>
        <span class="kt">bytes32</span><span class="p">[]</span> <span class="nx">_secret</span>
    <span class="p">)</span>
        <span class="k">public</span>
        <span class="nx">onlyAfter</span><span class="p">(</span><span class="nx">biddingEnd</span><span class="p">)</span>
        <span class="nx">onlyBefore</span><span class="p">(</span><span class="nx">revealEnd</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">bids</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">].</span><span class="nx">length</span><span class="p">;</span>
        <span class="nb">require</span><span class="p">(</span><span class="nx">_values</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="nx">length</span><span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="nx">_fake</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="nx">length</span><span class="p">);</span>
        <span class="nb">require</span><span class="p">(</span><span class="nx">_secret</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="nx">length</span><span class="p">);</span>

        <span class="kt">uint</span> <span class="nx">refund</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">bid</span> <span class="o">=</span> <span class="nx">bids</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">][</span><span class="nx">i</span><span class="p">];</span>
            <span class="kd">var</span> <span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">fake</span><span class="p">,</span> <span class="nx">secret</span><span class="p">)</span> <span class="o">=</span>
                    <span class="p">(</span><span class="nx">_values</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">_fake</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">_secret</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">bid</span><span class="p">.</span><span class="nx">blindedBid</span> <span class="o">!=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">fake</span><span class="p">,</span> <span class="nx">secret</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// Bid was not actually revealed.</span>
                <span class="c1">// Do not refund deposit.</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">refund</span> <span class="o">+=</span> <span class="nx">bid</span><span class="p">.</span><span class="nx">deposit</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">fake</span> <span class="o">&amp;&amp;</span> <span class="nx">bid</span><span class="p">.</span><span class="nx">deposit</span> <span class="o">&gt;=</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">placeBid</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">value</span><span class="p">))</span>
                    <span class="nx">refund</span> <span class="o">-=</span> <span class="nx">value</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// Make it impossible for the sender to re-claim</span>
            <span class="c1">// the same deposit.</span>
            <span class="nx">bid</span><span class="p">.</span><span class="nx">blindedBid</span> <span class="o">=</span> <span class="kt">bytes32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">refund</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// This is an "internal" function which means that it</span>
    <span class="c1">// can only be called from the contract itself (or from</span>
    <span class="c1">// derived contracts).</span>
    <span class="kd">function</span> <span class="nx">placeBid</span><span class="p">(</span><span class="kt">address</span> <span class="nx">bidder</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span> <span class="k">internal</span>
            <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="nx">success</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;=</span> <span class="nx">highestBid</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">highestBidder</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Refund the previously highest bidder.</span>
            <span class="nx">pendingReturns</span><span class="p">[</span><span class="nx">highestBidder</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">highestBid</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">highestBid</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
        <span class="nx">highestBidder</span> <span class="o">=</span> <span class="nx">bidder</span><span class="p">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// Withdraw a bid that was overbid.</span>
    <span class="kd">function</span> <span class="nx">withdraw</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">amount</span> <span class="o">=</span> <span class="nx">pendingReturns</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">amount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// It is important to set this to zero because the recipient</span>
            <span class="c1">// can call this function again as part of the receiving call</span>
            <span class="c1">// before `transfer` returns (see the remark above about</span>
            <span class="c1">// conditions -&gt; effects -&gt; interaction).</span>
            <span class="nx">pendingReturns</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">amount</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cs">/// End the auction and send the highest bid</span>
    <span class="cs">/// to the beneficiary.</span>
    <span class="kd">function</span> <span class="nx">auctionEnd</span><span class="p">()</span>
        <span class="k">public</span>
        <span class="nx">onlyAfter</span><span class="p">(</span><span class="nx">revealEnd</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="o">!</span><span class="nx">ended</span><span class="p">);</span>
        <span class="nx">emit</span> <span class="nx">AuctionEnded</span><span class="p">(</span><span class="nx">highestBidder</span><span class="p">,</span> <span class="nx">highestBid</span><span class="p">);</span>
        <span class="nx">ended</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">beneficiary</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">highestBid</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="safe-remote-purchase">
<span id="index-2"></span><h3>Safe Remote Purchase<a class="headerlink" href="#safe-remote-purchase" title="Permalink to this headline">¶</a></h3>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Purchase</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">value</span><span class="p">;</span>
    <span class="kt">address</span> <span class="k">public</span> <span class="nx">seller</span><span class="p">;</span>
    <span class="kt">address</span> <span class="k">public</span> <span class="nx">buyer</span><span class="p">;</span>
    <span class="kd">enum</span> <span class="nx">State</span> <span class="p">{</span> <span class="nx">Created</span><span class="p">,</span> <span class="nx">Locked</span><span class="p">,</span> <span class="nx">Inactive</span> <span class="p">}</span>
    <span class="nx">State</span> <span class="k">public</span> <span class="nx">state</span><span class="p">;</span>

    <span class="c1">// Ensure that `msg.value` is an even number.</span>
    <span class="c1">// Division will truncate if it is an odd number.</span>
    <span class="c1">// Check via multiplication that it wasn't an odd number.</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="nx">seller</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
        <span class="nx">value</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="nb">require</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">value</span><span class="p">)</span> <span class="o">==</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="s2">"Value has to be even."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">modifier</span> <span class="nx">condition</span><span class="p">(</span><span class="kt">bool</span> <span class="nx">_condition</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="nx">_condition</span><span class="p">);</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">modifier</span> <span class="nx">onlyBuyer</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">buyer</span><span class="p">,</span>
            <span class="s2">"Only buyer can call this."</span>
        <span class="p">);</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">modifier</span> <span class="nx">onlySeller</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">seller</span><span class="p">,</span>
            <span class="s2">"Only seller can call this."</span>
        <span class="p">);</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">modifier</span> <span class="nx">inState</span><span class="p">(</span><span class="nx">State</span> <span class="nx">_state</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nx">state</span> <span class="o">==</span> <span class="nx">_state</span><span class="p">,</span>
            <span class="s2">"Invalid state."</span>
        <span class="p">);</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">event</span> <span class="nx">Aborted</span><span class="p">();</span>
    <span class="kd">event</span> <span class="nx">PurchaseConfirmed</span><span class="p">();</span>
    <span class="kd">event</span> <span class="nx">ItemReceived</span><span class="p">();</span>

    <span class="cs">/// Abort the purchase and reclaim the ether.</span>
    <span class="cs">/// Can only be called by the seller before</span>
    <span class="cs">/// the contract is locked.</span>
    <span class="kd">function</span> <span class="nx">abort</span><span class="p">()</span>
        <span class="k">public</span>
        <span class="nx">onlySeller</span>
        <span class="nx">inState</span><span class="p">(</span><span class="nx">State</span><span class="p">.</span><span class="nx">Created</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">emit</span> <span class="nx">Aborted</span><span class="p">();</span>
        <span class="nx">state</span> <span class="o">=</span> <span class="nx">State</span><span class="p">.</span><span class="nx">Inactive</span><span class="p">;</span>
        <span class="nx">seller</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">balance</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="cs">/// Confirm the purchase as buyer.</span>
    <span class="cs">/// Transaction has to include `2 * value` ether.</span>
    <span class="cs">/// The ether will be locked until confirmReceived</span>
    <span class="cs">/// is called.</span>
    <span class="kd">function</span> <span class="nx">confirmPurchase</span><span class="p">()</span>
        <span class="k">public</span>
        <span class="nx">inState</span><span class="p">(</span><span class="nx">State</span><span class="p">.</span><span class="nx">Created</span><span class="p">)</span>
        <span class="nx">condition</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nx">value</span><span class="p">))</span>
        <span class="k">payable</span>
    <span class="p">{</span>
        <span class="nx">emit</span> <span class="nx">PurchaseConfirmed</span><span class="p">();</span>
        <span class="nx">buyer</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
        <span class="nx">state</span> <span class="o">=</span> <span class="nx">State</span><span class="p">.</span><span class="nx">Locked</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// Confirm that you (the buyer) received the item.</span>
    <span class="cs">/// This will release the locked ether.</span>
    <span class="kd">function</span> <span class="nx">confirmReceived</span><span class="p">()</span>
        <span class="k">public</span>
        <span class="nx">onlyBuyer</span>
        <span class="nx">inState</span><span class="p">(</span><span class="nx">State</span><span class="p">.</span><span class="nx">Locked</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">emit</span> <span class="nx">ItemReceived</span><span class="p">();</span>
        <span class="c1">// It is important to change the state first because</span>
        <span class="c1">// otherwise, the contracts called using `send` below</span>
        <span class="c1">// can call in again here.</span>
        <span class="nx">state</span> <span class="o">=</span> <span class="nx">State</span><span class="p">.</span><span class="nx">Inactive</span><span class="p">;</span>

        <span class="c1">// NOTE: This actually allows both the buyer and the seller to</span>
        <span class="c1">// block the refund - the withdraw pattern should be used.</span>

        <span class="nx">buyer</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="nx">seller</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="kt">address</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="nx">balance</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="micropayment-channel">
<h3>Micropayment Channel<a class="headerlink" href="#micropayment-channel" title="Permalink to this headline">¶</a></h3>
<p>写的。</p>
</div>
</div>
<span id="document-solidity-in-depth"></span><div class="section" id="solidity-in-depth">
<h2>Solidity in Depth<a class="headerlink" href="#solidity-in-depth" title="Permalink to this headline">¶</a></h2>
<p>这一节将为您提供关于可靠性的所有知识。如果这里有什么遗漏，请与我们联系，或者发出请求。<a class="reference external" href="https://gitter.im/ethereum/solidity">Gitter</a><a class="reference external" href="https://github.com/ethereum/solidity/pulls">Github</a></p>
<div class="toctree-wrapper compound">
<span id="document-layout-of-source-files"></span><div class="section" id="layout-of-a-solidity-source-file">
<h3>Layout of a Solidity Source File<a class="headerlink" href="#layout-of-a-solidity-source-file" title="Permalink to this headline">¶</a></h3>
<p>源文件可以包含任意数量的合约定义，包括directivesandpragma指令。</p>
<div class="section" id="version-pragma">
<span id="index-0"></span><span id="id1"></span><h4>Version Pragma<a class="headerlink" href="#version-pragma" title="Permalink to this headline">¶</a></h4>
<p>源文件可以(也应该)用一个所谓的版本pragma来进行注释，以将编译后的版本编译成可能会引入不兼容更改的编译器版本。我们试图将这些更改保持在绝对最小值，并特别引入更改，以使语义的更改也需要更改语法，但这当然不总是可能的。正因为如此，通过changelog阅读至少对于包含更改的版本来说是一个好主意，这些发行版将始终具有form0.x的版本。0或x.0.0。<code class="docutils literal"><span class="pre">0.x.0</span></code><code class="docutils literal"><span class="pre">x.0.0</span></code></p>
<p>pragma的版本如下:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>这样一个源文件不会编译编译器比0.4.0and版本也不会工作在编译器从版本0.5.0(thissecond条件添加使用^)。这背后的想法是，在版本0.5.0之前不会有任何的变化，所以我们总是可以确定我们的代码将按照我们的计划进行编译。我们不确定编译器的确切版本，因此bug修复版本仍然是可能的。<code class="docutils literal"><span class="pre">^</span></code><code class="docutils literal"><span class="pre">0.5.0</span></code></p>
<p>可以为编译器版本指定更复杂的规则，表达式遵循npm所使用的规则。<a class="reference external" href="https://docs.npmjs.com/misc/semver">npm</a></p>
</div>
<div class="section" id="importing-other-source-files">
<span id="import"></span><span id="index-1"></span><h4>Importing other Source Files<a class="headerlink" href="#importing-other-source-files" title="Permalink to this headline">¶</a></h4>
<div class="section" id="syntax-and-semantics">
<h5>Syntax and Semantics<a class="headerlink" href="#syntax-and-semantics" title="Permalink to this headline">¶</a></h5>
<p>Solidity支持非常类似于JavaScript的导入语句(从ES6开始)，尽管Solidity不知道“默认导出”的概念。</p>
<p>在全局级别，可以使用以下表单的导入语句:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="s2">"filename"</span><span class="p">;</span>
</pre></div>
</div>
<p>这个语句从“filename”(和符号导入到那里的符号)导入到全局范围(与ES6不同，但向后兼容于Solidity)的所有全局符号。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">symbolName</span> <span class="nx">from</span> <span class="s2">"filename"</span><span class="p">;</span>
</pre></div>
</div>
<p>创建一个新的全局符号symbolName，其成员是来自“filename”的所有全局符号。<code class="docutils literal"><span class="pre">symbolName</span></code><code class="docutils literal"><span class="pre">"filename"</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="p">{</span><span class="nx">symbol1</span> <span class="k">as</span> <span class="nx">alias</span><span class="p">,</span> <span class="nx">symbol2</span><span class="p">}</span> <span class="nx">from</span> <span class="s2">"filename"</span><span class="p">;</span>
</pre></div>
</div>
<p>创建新的全局符号别名和symbol2，分别从“filename”中引用symbol1和symbol2。<code class="docutils literal"><span class="pre">alias</span></code><code class="docutils literal"><span class="pre">symbol2</span></code><code class="docutils literal"><span class="pre">symbol1</span></code><code class="docutils literal"><span class="pre">symbol2</span></code><code class="docutils literal"><span class="pre">"filename"</span></code></p>
<p>另一种语法不是ES6的一部分，但可能很方便:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="s2">"filename"</span> <span class="k">as</span> <span class="nx">symbolName</span><span class="p">;</span>
</pre></div>
</div>
<p>这相当于从“filename”中导入*作为符号名称;。<code class="docutils literal"><span class="pre">import</span> <span class="pre">*</span> <span class="pre">as</span> <span class="pre">symbolName</span> <span class="pre">from</span> <span class="pre">"filename";</span></code></p>
</div>
<div class="section" id="paths">
<h5>Paths<a class="headerlink" href="#paths" title="Permalink to this headline">¶</a></h5>
<p>在上面的文件中，文件名总是被当作路径使用/作为目录分隔符。作为当前和…父目录。什么时候。或. .后跟一个字符，但不被认为是当前或父目录。所有路径名都被视为绝对路径，除非它们从当前开始。或者父目录…<code class="docutils literal"><span class="pre">filename</span></code><code class="docutils literal"><span class="pre">/</span></code><code class="docutils literal"><span class="pre">.</span></code><code class="docutils literal"><span class="pre">..</span></code><code class="docutils literal"><span class="pre">.</span></code><code class="docutils literal"><span class="pre">..</span></code><code class="docutils literal"><span class="pre">/</span></code><code class="docutils literal"><span class="pre">.</span></code><code class="docutils literal"><span class="pre">..</span></code></p>
<p>要从与当前文件相同的目录中导入一个文件x，请使用import。当x;/ x”。如果你用import x作为x;相反，可以引用不同的文件(在全局“include目录”中)。<code class="docutils literal"><span class="pre">x</span></code><code class="docutils literal"><span class="pre">import</span> <span class="pre">"./x"</span> <span class="pre">as</span> <span class="pre">x;</span></code><code class="docutils literal"><span class="pre">import</span> <span class="pre">"x"</span> <span class="pre">as</span> <span class="pre">x;</span></code></p>
<p>它取决于编译器(参见下面)如何真正解析路径。通常，目录层次结构不需要严格地映射到您的localfilesystem，它也可以映射到通过例如ipfs、http或git发现的资源。</p>
</div>
<div class="section" id="use-in-actual-compilers">
<h5>Use in Actual Compilers<a class="headerlink" href="#use-in-actual-compilers" title="Permalink to this headline">¶</a></h5>
<p>当调用编译器时，不仅可以指定如何发现路径的第一个元素，而且还可以指定路径前缀，这样，例如github.com/ethereum/dapp-bin/library被重新映射到/usr/local/dapp-bin/library，编译器将从那里读取这些文件。如果可以使用多个重新设置，则先尝试使用最长的键。这就允许使用例如“回调”。”“映射到“/ usr /地方/ include /可靠性”。此外，这些重新包装可以依赖于上下文，这允许您配置包的导入，例如一个同名库的不同版本。<code class="docutils literal"><span class="pre">github.com/ethereum/dapp-bin/library</span></code><code class="docutils literal"><span class="pre">/usr/local/dapp-bin/library</span></code><code class="docutils literal"><span class="pre">""</span></code><code class="docutils literal"><span class="pre">"/usr/local/include/solidity"</span></code></p>
<p><strong>solc</strong>solc:</p>
<p>对于solc (commandline编译器)，这些重新映射提供了上下文:前缀=目标参数，其中上下文:和=目标部件都是可选的(在这种情况下，目标默认为前缀)。所有重新映射的值都是常规文件(包括它们的依赖项)。这一机制完全向后兼容(只要不包含任何文件名=或:)，因此不会发生破坏性的变化。在导入一个以前缀开头的文件的目录上下文中的所有importsin文件，都是通过用目标替换前缀来重定向的。<code class="docutils literal"><span class="pre">context:prefix=target</span></code><code class="docutils literal"><span class="pre">context:</span></code><code class="docutils literal"><span class="pre">=target</span></code><code class="docutils literal"><span class="pre">context</span></code><code class="docutils literal"><span class="pre">prefix</span></code><code class="docutils literal"><span class="pre">prefix</span></code><code class="docutils literal"><span class="pre">target</span></code></p>
<p>因此，如果您使用clonegithub.com/ethereum/dapp-bin/local到/usr/local/dapp-bin，您可以在源文件中使用以下内容:<code class="docutils literal"><span class="pre">github.com/ethereum/dapp-bin/</span></code><code class="docutils literal"><span class="pre">/usr/local/dapp-bin</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="s2">"github.com/ethereum/dapp-bin/library/iterable_mapping.sol"</span> <span class="k">as</span> <span class="nx">it_mapping</span><span class="p">;</span>
</pre></div>
</div>
<p>然后运行编译器。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>solc github.com/ethereum/dapp-bin/<span class="o">=</span>/usr/local/dapp-bin/ source.sol
</pre></div>
</div>
<p>作为一个更复杂的例子，假设您依赖于使用一个非常旧版本的dapp-bin的模块。旧版本的dapp-bin在/usr/local/dapp-bin_old中被检出，然后您就可以使用了。<code class="docutils literal"><span class="pre">/usr/local/dapp-bin_old</span></code></p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>solc module1:github.com/ethereum/dapp-bin/<span class="o">=</span>/usr/local/dapp-bin/ <span class="se">\</span>
     module2:github.com/ethereum/dapp-bin/<span class="o">=</span>/usr/local/dapp-bin_old/ <span class="se">\</span>
     source.sol
</pre></div>
</div>
<p>因此，module2中的所有导入都指向旧版本，而importsin module1则得到了新版本。<code class="docutils literal"><span class="pre">module2</span></code><code class="docutils literal"><span class="pre">module1</span></code></p>
<p>请注意，solc只允许您将文件包含在特定目录中:它们必须位于一个明确指定的源文件的目录(或子目录)中，或者在重新映射目标的目录(或子目录)中。如果您想允许直接绝对包含，只需添加theremapping =/。<code class="docutils literal"><span class="pre">=/</span></code></p>
<p>如果有多个重新映射导致有效文件，则选择使用最长公共前缀的重新映射。</p>
<p><strong>Remix</strong>混合:</p>
<p><a class="reference external" href="https://remix.ethereum.org/">Remix</a>remixin为github提供了一种自动重新映射，并且还将自动在网络上检索文件:您可以导入可迭代的映射，例如，导入github.com/ethereum/dapp-bin/library/iterable_mapping.sol”作为it_mapping;<code class="docutils literal"><span class="pre">import</span> <span class="pre">"github.com/ethereum/dapp-bin/library/iterable_mapping.sol"</span> <span class="pre">as</span> <span class="pre">it_mapping;</span></code></p>
<p>将来还可以添加其他源代码提供程序。</p>
</div>
</div>
<div class="section" id="comments">
<span id="index-2"></span><h4>Comments<a class="headerlink" href="#comments" title="Permalink to this headline">¶</a></h4>
<p>单行注释(//)和多行注释(/*. */)是可能的。<code class="docutils literal"><span class="pre">//</span></code><code class="docutils literal"><span class="pre">/*...*/</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="c1">// This is a single-line comment.</span>

<span class="cm">/*</span>
<span class="cm">This is a</span>
<span class="cm">multi-line comment.</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p>此外，还有另一种类型的注释，称为natspec注释，文档尚未编写。它们是用atrixslash(///)或双星号块(/**)写的。*/)并应直接使用上述功能声明或声明。您可以在这些注释中使用doxygenstyle标记来记录文档功能，为正式的验证添加注释条件，并提供在用户试图调用函数时向用户显示的一段文本。<code class="docutils literal"><span class="pre">///</span></code><code class="docutils literal"><span class="pre">/**</span> <span class="pre">...</span> <span class="pre">*/</span></code><a class="reference external" href="https://en.wikipedia.org/wiki/Doxygen">Doxygen</a><strong>confirmation text</strong></p>
<p>在下面的示例中，我们记录了合约的标题、两个输入参数的解释和两个返回值。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="cs">/** </span><span class="k">@title</span><span class="cs"> Shape calculator. */</span>
<span class="kd">contract</span> <span class="nx">shapeCalculator</span> <span class="p">{</span>
    <span class="cs">/** </span><span class="k">@dev</span><span class="cs"> Calculates a rectangle's surface and perimeter.</span>
<span class="cs">      * </span><span class="k">@param</span><span class="cs"> w Width of the rectangle.</span>
<span class="cs">      * </span><span class="k">@param</span><span class="cs"> h Height of the rectangle.</span>
<span class="cs">      * </span><span class="k">@return</span><span class="cs"> s The calculated surface.</span>
<span class="cs">      * </span><span class="k">@return</span><span class="cs"> p The calculated perimeter.</span>
<span class="cs">      */</span>
    <span class="kd">function</span> <span class="nx">rectangle</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">w</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">h</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">s</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">s</span> <span class="o">=</span> <span class="nx">w</span> <span class="o">*</span> <span class="nx">h</span><span class="p">;</span>
        <span class="nx">p</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="nx">w</span> <span class="o">+</span> <span class="nx">h</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-structure-of-a-contract"></span><div class="section" id="structure-of-a-contract">
<span id="contract-structure"></span><span id="index-0"></span><h3>Structure of a Contract<a class="headerlink" href="#structure-of-a-contract" title="Permalink to this headline">¶</a></h3>
<p>Solidity中的合约类似于面向对象语言的类。每个合约都可以包含声明状态变量、函数、函数修饰符、事件、结构类型和枚举类型。此外，合约可以从其他合约中继承。<a class="reference internal" href="#structure-state-variables"><span class="std std-ref">State Variables</span></a><a class="reference internal" href="#structure-functions"><span class="std std-ref">Functions</span></a><a class="reference internal" href="#structure-function-modifiers"><span class="std std-ref">Function Modifiers</span></a><a class="reference internal" href="#structure-events"><span class="std std-ref">Events</span></a><a class="reference internal" href="#structure-struct-types"><span class="std std-ref">Struct Types</span></a><a class="reference internal" href="#structure-enum-types"><span class="std std-ref">Enum Types</span></a></p>
<div class="section" id="state-variables">
<span id="structure-state-variables"></span><h4>State Variables<a class="headerlink" href="#state-variables" title="Permalink to this headline">¶</a></h4>
<p>状态变量是永久存储在合约存储中的值。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">SimpleStorage</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="nx">storedData</span><span class="p">;</span> <span class="c1">// State variable</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请参阅类型部分，以获得有效的状态变量类型和可见性和getter。<a class="reference internal" href="index.html#types"><span class="std std-ref">Types</span></a><a class="reference internal" href="index.html#visibility-and-getters"><span class="std std-ref">Visibility and Getters</span></a></p>
</div>
<div class="section" id="functions">
<span id="structure-functions"></span><h4>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h4>
<p>函数是合约中代码的可执行单元。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">SimpleAuction</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">bid</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span> <span class="c1">// Function</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><a class="reference internal" href="index.html#function-calls"><span class="std std-ref">Function Calls</span></a>函数调用可以在内部或外部发生，并且对其他合约具有不同级别的可见性(可见性和Getters)。<a class="reference internal" href="index.html#visibility-and-getters"><span class="std std-ref">Visibility and Getters</span></a></p>
</div>
<div class="section" id="function-modifiers">
<span id="structure-function-modifiers"></span><h4>Function Modifiers<a class="headerlink" href="#function-modifiers" title="Permalink to this headline">¶</a></h4>
<p>函数修饰符可用于以声明方式修改函数的语义(参见合约部分中的函数修饰符)。<a class="reference internal" href="index.html#modifiers"><span class="std std-ref">Function Modifiers</span></a></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Purchase</span> <span class="p">{</span>
    <span class="kt">address</span> <span class="k">public</span> <span class="nx">seller</span><span class="p">;</span>

    <span class="kd">modifier</span> <span class="nx">onlySeller</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// Modifier</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">seller</span><span class="p">,</span>
            <span class="s2">"Only seller can call this."</span>
        <span class="p">);</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">abort</span><span class="p">()</span> <span class="k">public</span> <span class="nx">onlySeller</span> <span class="p">{</span> <span class="c1">// Modifier usage</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="events">
<span id="structure-events"></span><h4>Events<a class="headerlink" href="#events" title="Permalink to this headline">¶</a></h4>
<p>事件是与EVM日志设施的便利接口。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">21</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">SimpleAuction</span> <span class="p">{</span>
    <span class="kd">event</span> <span class="nx">HighestBidIncreased</span><span class="p">(</span><span class="kt">address</span> <span class="nx">bidder</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">amount</span><span class="p">);</span> <span class="c1">// Event</span>

    <span class="kd">function</span> <span class="nx">bid</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="nx">emit</span> <span class="nx">HighestBidIncreased</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span> <span class="c1">// Triggering event</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>有关事件如何被声明的信息，请参见合约部分中的事件，并可以从dapp中使用。<a class="reference internal" href="index.html#events"><span class="std std-ref">Events</span></a></p>
</div>
<div class="section" id="struct-types">
<span id="structure-struct-types"></span><h4>Struct Types<a class="headerlink" href="#struct-types" title="Permalink to this headline">¶</a></h4>
<p>struct是自定义定义的类型，可以对多个变量进行分组(在类型部分中进行seestruct)。<a class="reference internal" href="index.html#structs"><span class="std std-ref">Structs</span></a></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Ballot</span> <span class="p">{</span>
    <span class="kd">struct</span> <span class="nx">Voter</span> <span class="p">{</span> <span class="c1">// Struct</span>
        <span class="kt">uint</span> <span class="nx">weight</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nx">voted</span><span class="p">;</span>
        <span class="kt">address</span> <span class="nx">delegate</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="nx">vote</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="enum-types">
<span id="structure-enum-types"></span><h4>Enum Types<a class="headerlink" href="#enum-types" title="Permalink to this headline">¶</a></h4>
<p>枚举可以用来创建具有有限“常量值”的自定义类型(类型部分的seeEnums)。<a class="reference internal" href="index.html#enums"><span class="std std-ref">Enums</span></a></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Purchase</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="nx">State</span> <span class="p">{</span> <span class="nx">Created</span><span class="p">,</span> <span class="nx">Locked</span><span class="p">,</span> <span class="nx">Inactive</span> <span class="p">}</span> <span class="c1">// Enum</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-types"></span><div class="section" id="types">
<span id="index-0"></span><span id="id1"></span><h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p>Solidity是一种静态类型的语言，这意味着需要指定eachvariable(状态和本地)的类型(或者至少是已知的-参见下面的类型推导)。Solidity提供了几种基本类型，可以组合成复杂类型。<a class="reference internal" href="#type-deduction"><span class="std std-ref">Type Deduction</span></a></p>
<p>此外，类型可以在包含操作符的表达式中相互作用。为了快速地引用不同的操作符，请参阅操作符的优先顺序。<a class="reference internal" href="index.html#order"><span class="std std-ref">Order of Precedence of Operators</span></a></p>
<div class="section" id="value-types">
<span id="index-1"></span><h4>Value Types<a class="headerlink" href="#value-types" title="Permalink to this headline">¶</a></h4>
<p>下面的类型也被称为值类型，因为这些类型的变量总是通过值传递的，也就是说，当它们被用作函数参数或赋值时，它们总是被复制。</p>
<div class="section" id="booleans">
<span id="index-2"></span><h5>Booleans<a class="headerlink" href="#booleans" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal"><span class="pre">bool</span></code>bool:可能的值是常量true和false。<code class="docutils literal"><span class="pre">true</span></code><code class="docutils literal"><span class="pre">false</span></code></p>
<p>运营商:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">!</span></code> (logical negation)</li>
<li><code class="docutils literal"><span class="pre">&amp;&amp;</span></code> (logical conjunction, “and”)</li>
<li><code class="docutils literal"><span class="pre">||</span></code> (logical disjunction, “or”)</li>
<li><code class="docutils literal"><span class="pre">==</span></code> (equality)</li>
<li><code class="docutils literal"><span class="pre">!=</span></code> (inequality)</li>
</ul>
<p>操作人员||和&amp;&amp;应用通用的短路规则。这意味着在表达式f(x) || g(y)中，如果f(x)计算为true，即使它可能有副作用，也不会对g(y)进行评估。<code class="docutils literal"><span class="pre">||</span></code><code class="docutils literal"><span class="pre">&amp;&amp;</span></code><code class="docutils literal"><span class="pre">f(x)</span> <span class="pre">||</span> <span class="pre">g(y)</span></code><code class="docutils literal"><span class="pre">f(x)</span></code><code class="docutils literal"><span class="pre">true</span></code><code class="docutils literal"><span class="pre">g(y)</span></code></p>
</div>
<div class="section" id="integers">
<span id="index-3"></span><h5>Integers<a class="headerlink" href="#integers" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal"><span class="pre">int</span></code>int / uint:各种大小的签名和无符号整数。uint8到uint256的步骤8(未签名8到256位)和int8到int256。uint和int分别是uint256和int256的别名。<code class="docutils literal"><span class="pre">uint</span></code><code class="docutils literal"><span class="pre">uint8</span></code><code class="docutils literal"><span class="pre">uint256</span></code><code class="docutils literal"><span class="pre">8</span></code><code class="docutils literal"><span class="pre">int8</span></code><code class="docutils literal"><span class="pre">int256</span></code><code class="docutils literal"><span class="pre">uint</span></code><code class="docutils literal"><span class="pre">int</span></code><code class="docutils literal"><span class="pre">uint256</span></code><code class="docutils literal"><span class="pre">int256</span></code></p>
<p>运营商:</p>
<ul class="simple">
<li>Comparisons: <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code> (evaluate to <code class="docutils literal"><span class="pre">bool</span></code>)</li>
<li>Bit operators: <code class="docutils literal"><span class="pre">&amp;</span></code>, <code class="docutils literal"><span class="pre">|</span></code>, <code class="docutils literal"><span class="pre">^</span></code> (bitwise exclusive or), <code class="docutils literal"><span class="pre">~</span></code> (bitwise negation)</li>
<li>Arithmetic operators: <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, unary <code class="docutils literal"><span class="pre">-</span></code>, unary <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">%</span></code> (remainder), <code class="docutils literal"><span class="pre">**</span></code> (exponentiation), <code class="docutils literal"><span class="pre">&lt;&lt;</span></code> (left shift), <code class="docutils literal"><span class="pre">&gt;&gt;</span></code> (right shift)</li>
</ul>
<p>分区总是截断(它只被编译到EVM的DIV opcode中)，但是如果both算子是文字(或文字表达式)，它就不会截断。<code class="docutils literal"><span class="pre">DIV</span></code><a class="reference internal" href="#rational-literals"><span class="std std-ref">literals</span></a></p>
<p>除零和模量为零抛出运行时异常。</p>
<p>移位操作的结果是左操作数的类型。表达式x &lt;&lt; y等于x * 2**y, x &gt;&gt; y isequito x / 2**y。这意味着移动的负数符号会扩展。由负数移动会抛出运行时异常。<code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">y</span></code><code class="docutils literal"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">2**y</span></code><code class="docutils literal"><span class="pre">x</span> <span class="pre">&gt;&gt;</span> <span class="pre">y</span></code><code class="docutils literal"><span class="pre">x</span> <span class="pre">/</span> <span class="pre">2**y</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">由符号整数类型的负值右移所产生的结果与其他编程语言产生的结果不同。在固体中，将右移映射到除法，因此移位的负值将被四舍五入到零(截断)。在其他的编程语言中，负价值的转移就像除法一样(趋向于负无穷)。</p>
</div>
</div>
<div class="section" id="fixed-point-numbers">
<span id="index-4"></span><h5>Fixed Point Numbers<a class="headerlink" href="#fixed-point-numbers" title="Permalink to this headline">¶</a></h5>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">固定点数还没有完全支持。它们可以被声明，但不能被分配给或从。</p>
</div>
<p><code class="docutils literal"><span class="pre">fixed</span></code>固定/固定:不同尺寸的固定点数。ufixedMxN和fixedMxN，其中M表示为类型所占的位数，N表示可用的小数位数。M必须能被8整除，从8到256位。N必须在0到80之间，包括在内。ufixed和fixed分别是ufixed128x18和fixed128x18的别名。<code class="docutils literal"><span class="pre">ufixed</span></code><code class="docutils literal"><span class="pre">ufixedMxN</span></code><code class="docutils literal"><span class="pre">fixedMxN</span></code><code class="docutils literal"><span class="pre">M</span></code><code class="docutils literal"><span class="pre">N</span></code><code class="docutils literal"><span class="pre">M</span></code><code class="docutils literal"><span class="pre">N</span></code><code class="docutils literal"><span class="pre">ufixed</span></code><code class="docutils literal"><span class="pre">fixed</span></code><code class="docutils literal"><span class="pre">ufixed128x18</span></code><code class="docutils literal"><span class="pre">fixed128x18</span></code></p>
<p>运营商:</p>
<ul class="simple">
<li>Comparisons: <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code> (evaluate to <code class="docutils literal"><span class="pre">bool</span></code>)</li>
<li>Arithmetic operators: <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code>, unary <code class="docutils literal"><span class="pre">-</span></code>, unary <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">%</span></code> (remainder)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">浮点数之间的主要区别(浮动和双在许多语言,更准确的IEEE 754数字)和定点数的数量是位用于整数和小数部分(十进制点后的部分)是灵活的在前,虽然strictlydefined在后者。一般来说，在浮点数中，几乎整个空间都用来表示数字，而只有一小部分位定义小数点的位置。<code class="docutils literal"><span class="pre">float</span></code><code class="docutils literal"><span class="pre">double</span></code></p>
</div>
</div>
<div class="section" id="address">
<span id="index-5"></span><span id="id2"></span><h5>Address<a class="headerlink" href="#address" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal"><span class="pre">address</span></code>地址:保存一个20字节的值(一个Ethereum地址的大小)。地址类型也有成员，并作为所有合约的基础。</p>
<p>运营商:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code> and <code class="docutils literal"><span class="pre">&gt;</span></code></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">从版本0.5.0开始，合约不是从地址类型派生出来的，但是仍然可以被显式地转换为地址。</p>
</div>
<div class="section" id="members-of-addresses">
<span id="id3"></span><h6>Members of Addresses<a class="headerlink" href="#members-of-addresses" title="Permalink to this headline">¶</a></h6>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">balance</span></code> and <code class="docutils literal"><span class="pre">transfer</span></code></li>
</ul>
<p>如需快速参考，请参阅相关的地址。<a class="reference internal" href="index.html#address-related"><span class="std std-ref">Address Related</span></a></p>
<p>可以使用属性平衡查询地址的余额，并将以太(单位为wei)发送到使用传递函数的地址:<code class="docutils literal"><span class="pre">balance</span></code><code class="docutils literal"><span class="pre">transfer</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kt">address</span> <span class="nx">x</span> <span class="o">=</span> <span class="mh">0x123</span><span class="p">;</span>
<span class="kt">address</span> <span class="nx">myAddress</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">balance</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="nx">myAddress</span><span class="p">.</span><span class="nx">balance</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="nx">x</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">如果x是一个合约地址，它的代码(更具体地说:它的回退函数，如果存在)将与传递调用一起执行(这是EVM的一个特性，不能被阻止)。如果执行耗尽了气体或以任何方式失败，以太转移将被恢复，当前的合约将以一个例外停止。<code class="docutils literal"><span class="pre">x</span></code><code class="docutils literal"><span class="pre">transfer</span></code></p>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">send</span></code></li>
</ul>
<p>发送是传输的低级副本。如果执行失败，当前的合约将不会停止，但是send将返回false。<code class="docutils literal"><span class="pre">transfer</span></code><code class="docutils literal"><span class="pre">send</span></code><code class="docutils literal"><span class="pre">false</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">使用send有一些危险:如果调用堆栈深度为1024(这可能总是由调用者强制)，传输失败，并且如果收件人耗尽了气体，也会失败。因此，为了确保安全的以太传输，总是要检查发送的返回值，使用转移或者更好的:使用一个模式，接收者收回钱。<code class="docutils literal"><span class="pre">send</span></code><code class="docutils literal"><span class="pre">send</span></code><code class="docutils literal"><span class="pre">transfer</span></code></p>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">call</span></code>, <code class="docutils literal"><span class="pre">callcode</span></code> and <code class="docutils literal"><span class="pre">delegatecall</span></code></li>
</ul>
<p>此外，为了与不符合ABI的合约进行接口，提供了函数调用，该函数调用任意类型的任意数量的参数。这些参数被添加到32字节并连接。一个例外是第一个参数被编码到四个字节。在这种情况下，不允许在这里使用函数签名。<code class="docutils literal"><span class="pre">call</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kt">address</span> <span class="nx">nameReg</span> <span class="o">=</span> <span class="mh">0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2</span><span class="p">;</span>
<span class="nx">nameReg</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="s2">"register"</span><span class="p">,</span> <span class="s2">"MyName"</span><span class="p">);</span>
<span class="nx">nameReg</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="kt">bytes4</span><span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span><span class="s2">"fun(uint256)"</span><span class="p">)),</span> <span class="nx">a</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">call</span></code>调用返回一个布尔值，指示调用的函数是否终止(true)或引发EVM异常(false)。不可能访问返回的实际数据(为此，我们需要事先知道编码和大小)。<code class="docutils literal"><span class="pre">true</span></code><code class="docutils literal"><span class="pre">false</span></code></p>
<p>可以用.gas()修改器调整所提供的气体:<code class="docutils literal"><span class="pre">.gas()</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">namReg</span><span class="p">.</span><span class="nx">call</span><span class="p">.</span><span class="nx">gas</span><span class="p">(</span><span class="mi">1000000</span><span class="p">)(</span><span class="s2">"register"</span><span class="p">,</span> <span class="s2">"MyName"</span><span class="p">);</span>
</pre></div>
</div>
<p>同样，提供的醚值也可以被控制:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">nameReg</span><span class="p">.</span><span class="nx">call</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="mi">1</span> <span class="kt">ether</span><span class="p">)(</span><span class="s2">"register"</span><span class="p">,</span> <span class="s2">"MyName"</span><span class="p">);</span>
</pre></div>
</div>
<p>最后，这些修饰符可以组合在一起。它们的顺序无关紧要:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">nameReg</span><span class="p">.</span><span class="nx">call</span><span class="p">.</span><span class="nx">gas</span><span class="p">(</span><span class="mi">1000000</span><span class="p">).</span><span class="nx">value</span><span class="p">(</span><span class="mi">1</span> <span class="kt">ether</span><span class="p">)(</span><span class="s2">"register"</span><span class="p">,</span> <span class="s2">"MyName"</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>在重载函数上使用气体或值修饰符是不可能的。</p>
<p class="last">一个解决方案是引入一个特殊的气体和值的例子，并重新检查它们是否存在于重载解析的位置。</p>
</div>
<p>同样，可以使用委托的函数:不同的是，只使用给定地址的代码，所有其他方面(存储、平衡、…)都是从当前合约中提取的。委托的目的是使用存储在另一个合约中的库代码。用户必须确保两个合约中存储的布局都适合于被使用的委托。在homestead之前，只有一种名为callcode的有限变体没有提供对原始msg的访问。发送者和味精。值的值。<code class="docutils literal"><span class="pre">delegatecall</span></code><code class="docutils literal"><span class="pre">delegatecall</span></code><code class="docutils literal"><span class="pre">callcode</span></code><code class="docutils literal"><span class="pre">msg.sender</span></code><code class="docutils literal"><span class="pre">msg.value</span></code></p>
<p>所有三个函数调用、委托和callcode都是非常低级的函数，只有当它们破坏了实体的类型安全性时，才应该使用它们作为最后的手段。<code class="docutils literal"><span class="pre">call</span></code><code class="docutils literal"><span class="pre">delegatecall</span></code><code class="docutils literal"><span class="pre">callcode</span></code><em>last resort</em></p>
<p>.gas()选项可在所有三种方法上使用，而.value()选项不支持委托。<code class="docutils literal"><span class="pre">.gas()</span></code><code class="docutils literal"><span class="pre">.value()</span></code><code class="docutils literal"><span class="pre">delegatecall</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">所有的合约都可以转换为地址类型，所以可以使用地址(this)来查询合约的余额。<code class="docutils literal"><span class="pre">address</span></code><code class="docutils literal"><span class="pre">address(this).balance</span></code></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">我们不鼓励使用callcode，并且在将来会被删除。<code class="docutils literal"><span class="pre">callcode</span></code></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">所有这些功能都是低级功能，应该小心使用。具体地说，任何未知的合约都可能是恶意的，如果你调用它，你就把控制权交给了那个可以反过来调用你的合约的合约，所以当调用返回时，准备好修改你的状态变量。</p>
</div>
</div>
</div>
<div class="section" id="fixed-size-byte-arrays">
<span id="index-6"></span><h5>Fixed-size byte arrays<a class="headerlink" href="#fixed-size-byte-arrays" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal"><span class="pre">bytes1</span></code>bytes2, bytes3，…，bytes32。字节是bytes1的别名。<code class="docutils literal"><span class="pre">bytes2</span></code><code class="docutils literal"><span class="pre">bytes3</span></code><code class="docutils literal"><span class="pre">bytes32</span></code><code class="docutils literal"><span class="pre">byte</span></code><code class="docutils literal"><span class="pre">bytes1</span></code></p>
<p>运营商:</p>
<ul class="simple">
<li>Comparisons: <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">!=</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code> (evaluate to <code class="docutils literal"><span class="pre">bool</span></code>)</li>
<li>Bit operators: <code class="docutils literal"><span class="pre">&amp;</span></code>, <code class="docutils literal"><span class="pre">|</span></code>, <code class="docutils literal"><span class="pre">^</span></code> (bitwise exclusive or), <code class="docutils literal"><span class="pre">~</span></code> (bitwise negation), <code class="docutils literal"><span class="pre">&lt;&lt;</span></code> (left shift), <code class="docutils literal"><span class="pre">&gt;&gt;</span></code> (right shift)</li>
<li>Index access: If <code class="docutils literal"><span class="pre">x</span></code> is of type <code class="docutils literal"><span class="pre">bytesI</span></code>, then <code class="docutils literal"><span class="pre">x[k]</span></code> for <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">k</span> <span class="pre">&lt;</span> <span class="pre">I</span></code> returns the <code class="docutils literal"><span class="pre">k</span></code> th byte (read-only).</li>
</ul>
<p>移位操作符使用任何整数类型作为右操作数(但会返回左操作数的类型)，这表示要转换的位数。由负数移动会导致运行时异常。</p>
<p>成员:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">.length</span></code> yields the fixed length of the byte array (read-only).</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">可以使用字节数组作为字节[]，但是它浪费了大量的空间，31字节的每个元素，确切地说，当通过调用时。最好使用字节。<code class="docutils literal"><span class="pre">byte[]</span></code><code class="docutils literal"><span class="pre">bytes</span></code></p>
</div>
</div>
<div class="section" id="dynamically-sized-byte-array">
<h5>Dynamically-sized byte array<a class="headerlink" href="#dynamically-sized-byte-array" title="Permalink to this headline">¶</a></h5>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">bytes</span></code>:</dt>
<dd>Dynamically-sized byte array, see <a class="reference internal" href="#arrays"><span class="std std-ref">Arrays</span></a>. Not a value-type!</dd>
<dt><code class="docutils literal"><span class="pre">string</span></code>:</dt>
<dd>Dynamically-sized UTF-8-encoded string, see <a class="reference internal" href="#arrays"><span class="std std-ref">Arrays</span></a>. Not a value-type!</dd>
</dl>
<p>作为一个经验法则，使用字节为任意长度的原始字节数据和stringfor任意长度的字符串(UTF-8)数据。如果您可以将长度限制为一定数量的字节，那么一定要使用bytes1到bytes32，因为它们要便宜得多。<code class="docutils literal"><span class="pre">bytes</span></code><code class="docutils literal"><span class="pre">string</span></code><code class="docutils literal"><span class="pre">bytes1</span></code><code class="docutils literal"><span class="pre">bytes32</span></code></p>
</div>
<div class="section" id="address-literals">
<span id="index-7"></span><span id="id4"></span><h5>Address Literals<a class="headerlink" href="#address-literals" title="Permalink to this headline">¶</a></h5>
<p>通过地址校验和测试的十六进制文字，如:example0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF是地址类型。在39到41个数字之间的十六进制文字，不通过校验和测试产品的警告，并被当作常规的理性数字文字处理。<code class="docutils literal"><span class="pre">0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</span></code><code class="docutils literal"><span class="pre">address</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在EIP-55中定义了混合案例地址校验和格式。<a class="reference external" href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md">EIP-55</a></p>
</div>
</div>
<div class="section" id="rational-and-integer-literals">
<span id="rational-literals"></span><span id="index-8"></span><h5>Rational and Integer Literals<a class="headerlink" href="#rational-and-integer-literals" title="Permalink to this headline">¶</a></h5>
<p>整型文字是由0-9范围内的一系列数字组成。它们被解释为小数。举个例子，69的意思是69。八进制字不存在于固体，前导零是无效的。<code class="docutils literal"><span class="pre">69</span></code></p>
<p>十进制小数是由a构成的。至少有一个数字在一边。例子包括1。、。1和1.3。<code class="docutils literal"><span class="pre">.</span></code><code class="docutils literal"><span class="pre">1.</span></code><code class="docutils literal"><span class="pre">.1</span></code><code class="docutils literal"><span class="pre">1.3</span></code></p>
<p>科学的表示法也得到了支持，在此基础上可以有分数，而指数不能。示例包括2e10、-2e10、2e-10、2.5e1。<code class="docutils literal"><span class="pre">2e10</span></code><code class="docutils literal"><span class="pre">-2e10</span></code><code class="docutils literal"><span class="pre">2e-10</span></code><code class="docutils literal"><span class="pre">2.5e1</span></code></p>
<p>数字文字表达式保留任意的精度，直到它们被转换成非文字类型(即，将它们与非文字表达式一起使用)。这意味着计算不会溢出，而分类不会截断数字的文字表达式。</p>
<p>例如，(2**800 + 1)- 2**800的结果是常量1(类型uint8)，尽管中间结果甚至不适合机器字的大小。此外，.5 * 8结果为整数4(尽管在中间使用了非整数)。<code class="docutils literal"><span class="pre">(2**800</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">-</span> <span class="pre">2**800</span></code><code class="docutils literal"><span class="pre">1</span></code><code class="docutils literal"><span class="pre">uint8</span></code><code class="docutils literal"><span class="pre">.5</span> <span class="pre">*</span> <span class="pre">8</span></code><code class="docutils literal"><span class="pre">4</span></code></p>
<p>只要操作数是整数，任何可以应用于整数的运算符也可以应用于数字文字表达式。如果其中任何一个是分数阶的，位操作是不允许的，如果指数是小数(因为这可能会导致非有理数)，则不允许取幂。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Solidity对每个有理数都有一个数字文本类型。整型文字和理性数字文字属于数字文字类型。此外，所有数字文字表达式(即只包含数字文字和运算符的表达式)属于数字文本类型。因此，数字字面表达式1 + 2和2 + 1都属于相同的数字类型3。<code class="docutils literal"><span class="pre">1</span> <span class="pre">+</span> <span class="pre">2</span></code><code class="docutils literal"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></code></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">用于在早期版本中截断的整型文字的除法，但现在它将转换成一个有理数，即5 / 2不等于2，而是2。5。<code class="docutils literal"><span class="pre">5</span> <span class="pre">/</span> <span class="pre">2</span></code><code class="docutils literal"><span class="pre">2</span></code><code class="docutils literal"><span class="pre">2.5</span></code></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在使用非文字表达式时，数字文字表达式会被转换为非文字类型。尽管我们知道在下面的示例中分配给b的表达式的值计算为toan整数，但部分表达式2.5 + a不进行类型检查，因此代码不编译。<code class="docutils literal"><span class="pre">b</span></code><code class="docutils literal"><span class="pre">2.5</span> <span class="pre">+</span> <span class="pre">a</span></code></p>
</div>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kt">uint128</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">uint128</span> <span class="nx">b</span> <span class="o">=</span> <span class="mf">2.5</span> <span class="o">+</span> <span class="nx">a</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="string-literals">
<span id="index-9"></span><h5>String Literals<a class="headerlink" href="#string-literals" title="Permalink to this headline">¶</a></h5>
<p>字符串字面量是用双引号或单引号(“foo”或“bar”)来写的。它们并不意味着在C中尾随零;“foo”表示3个字节，而不是4个字节。与整型文字一样，它们的类型可以变化，但是它们可以隐式地转换为bytes1，…，bytes32，如果它们适合，则是字节和字符串。<code class="docutils literal"><span class="pre">"foo"</span></code><code class="docutils literal"><span class="pre">'bar'</span></code><code class="docutils literal"><span class="pre">"foo"</span></code><code class="docutils literal"><span class="pre">bytes1</span></code><code class="docutils literal"><span class="pre">bytes32</span></code><code class="docutils literal"><span class="pre">bytes</span></code><code class="docutils literal"><span class="pre">string</span></code></p>
<p>字符串字面量支持转义字符，例如\n， \xNN和\uNNNN。\xNN采用十六进制值并插入适当的字节，而\uNNNN采用Unicode编码点并插入一个UTF-8序列。<code class="docutils literal"><span class="pre">\n</span></code><code class="docutils literal"><span class="pre">\xNN</span></code><code class="docutils literal"><span class="pre">\uNNNN</span></code><code class="docutils literal"><span class="pre">\xNN</span></code><code class="docutils literal"><span class="pre">\uNNNN</span></code></p>
</div>
<div class="section" id="hexadecimal-literals">
<span id="index-10"></span><h5>Hexadecimal Literals<a class="headerlink" href="#hexadecimal-literals" title="Permalink to this headline">¶</a></h5>
<p>Hexademical Literals用关键字十六进制前缀，用双引号或单引号括起来(十六进制“001122FF”)。它们的内容必须是十六进制字符串，它们的值将是这些值的二进制表示。<code class="docutils literal"><span class="pre">hex</span></code><code class="docutils literal"><span class="pre">hex"001122FF"</span></code></p>
<p>它的字面意思是字符串字面量，并具有相同的可兑换性限制。</p>
</div>
<div class="section" id="enums">
<span id="index-11"></span><span id="id5"></span><h5>Enums<a class="headerlink" href="#enums" title="Permalink to this headline">¶</a></h5>
<p>枚举是创建用户定义类型的一种方法。它们是显式地转换为和来自所有整数类型，但隐式转换是不允许的。显式conversionscheck在运行时的值范围和失败导致异常。Enums至少需要一个成员。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">test</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="nx">ActionChoices</span> <span class="p">{</span> <span class="nx">GoLeft</span><span class="p">,</span> <span class="nx">GoRight</span><span class="p">,</span> <span class="nx">GoStraight</span><span class="p">,</span> <span class="nx">SitStill</span> <span class="p">}</span>
    <span class="nx">ActionChoices</span> <span class="nx">choice</span><span class="p">;</span>
    <span class="nx">ActionChoices</span> <span class="k">constant</span> <span class="nx">defaultChoice</span> <span class="o">=</span> <span class="nx">ActionChoices</span><span class="p">.</span><span class="nx">GoStraight</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">setGoStraight</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">choice</span> <span class="o">=</span> <span class="nx">ActionChoices</span><span class="p">.</span><span class="nx">GoStraight</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Since enum types are not part of the ABI, the signature of "getChoice"</span>
    <span class="c1">// will automatically be changed to "getChoice() returns (uint8)"</span>
    <span class="c1">// for all matters external to Solidity. The integer type used is just</span>
    <span class="c1">// large enough to hold all enum values, i.e. if you have more values,</span>
    <span class="c1">// `uint16` will be used and so on.</span>
    <span class="kd">function</span> <span class="nx">getChoice</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="nx">ActionChoices</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">choice</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">getDefaultChoice</span><span class="p">()</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">defaultChoice</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-types">
<span id="index-12"></span><span id="id6"></span><h5>Function Types<a class="headerlink" href="#function-types" title="Permalink to this headline">¶</a></h5>
<p>函数类型是函数的类型。函数类型的变量由函数类型的函数和函数参数赋值，用于将函数传递到函数调用并返回函数。功能类型有两种:内部和外部功能:<em>internal</em><em>external</em></p>
<p>内部函数只能在当前合约中调用(更具体地说，在当前代码单元内，它还包括内部库函数和继承函数)，因为它们不能在当前合约的文本之外执行。调用内部函数是通过跳转到它的entry标签来实现的，就像在内部调用currentcontract的函数一样。</p>
<p>外部函数由一个地址和一个函数签名组成，它们可以通过外部函数调用来传递和返回。</p>
<p>功能类型如下:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">parameter</span> <span class="nx">types</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span><span class="k">internal</span><span class="o">|</span><span class="k">external</span><span class="p">}</span> <span class="p">[</span><span class="k">pure</span><span class="o">|</span><span class="k">constant</span><span class="o">|</span><span class="k">view</span><span class="o">|</span><span class="k">payable</span><span class="p">]</span> <span class="p">[</span><span class="k">returns</span> <span class="p">(</span><span class="o">&lt;</span><span class="k">return</span> <span class="nx">types</span><span class="o">&gt;</span><span class="p">)]</span>
</pre></div>
</div>
<p>与参数类型相反，返回类型不能为空——如果函数类型不返回任何内容，则返回的全部返回(&lt;返回类型&gt;)部分必须省略。<code class="docutils literal"><span class="pre">returns</span> <span class="pre">(&lt;return</span> <span class="pre">types&gt;)</span></code></p>
<p>默认情况下，函数类型是内部的，所以内部关键字可以省略。相反，合约函数本身是公共的，默认情况下，只有当作为类型的名称使用时，默认是内部的。<code class="docutils literal"><span class="pre">internal</span></code></p>
<p>在当前的合约中，有两种方法可以访问一个函数:要么直接使用它的名称，要么使用这个。前者将导致一个内部函数，后者在一个外部函数中。<code class="docutils literal"><span class="pre">f</span></code><code class="docutils literal"><span class="pre">this.f</span></code></p>
<p>如果函数类型变量未初始化，调用它将导致异常。如果在使用deleteon之后调用函数，也会发生同样的情况。<code class="docutils literal"><span class="pre">delete</span></code></p>
<p>如果外部函数类型在实体的外部环境中使用，则将它们视为函数类型，它将函数标识符与函数标识符一起编码在一个bytes24类型中。<code class="docutils literal"><span class="pre">function</span></code><code class="docutils literal"><span class="pre">bytes24</span></code></p>
<p>注意，当前合约的公共功能既可以作为内部函数也可以作为外部函数使用。如果要用f作为内部函数，只要用f，如果你想用它的外部形式，用这个。<code class="docutils literal"><span class="pre">f</span></code><code class="docutils literal"><span class="pre">f</span></code><code class="docutils literal"><span class="pre">this.f</span></code></p>
<p>此外，公共(或外部)函数也有一个特殊的成员称为选择器，它返回ABI函数选择器:<code class="docutils literal"><span class="pre">selector</span></code><a class="reference internal" href="index.html#abi-function-selector"><span class="std std-ref">ABI function selector</span></a></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Selector</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes4</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">selector</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>示例说明如何使用内部函数类型:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">library</span> <span class="nx">ArrayUtils</span> <span class="p">{</span>
  <span class="c1">// internal functions can be used in internal library functions because</span>
  <span class="c1">// they will be part of the same code context</span>
  <span class="kd">function</span> <span class="nx">map</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="k">memory</span> <span class="nx">self</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="nx">f</span><span class="p">)</span>
    <span class="k">internal</span>
    <span class="k">pure</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="k">memory</span> <span class="nx">r</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="nx">self</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">self</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">reduce</span><span class="p">(</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="k">memory</span> <span class="nx">self</span><span class="p">,</span>
    <span class="kd">function</span> <span class="p">(</span><span class="kt">uint</span><span class="p">,</span> <span class="kt">uint</span><span class="p">)</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="nx">f</span>
  <span class="p">)</span>
    <span class="k">internal</span>
    <span class="k">pure</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">r</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="nx">r</span> <span class="o">=</span> <span class="nx">self</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">r</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">self</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">range</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">length</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="k">memory</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">r</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="nx">length</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">r</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Pyramid</span> <span class="p">{</span>
  <span class="k">using</span> <span class="nx">ArrayUtils</span> <span class="k">for</span> <span class="o">*</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">pyramid</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">l</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ArrayUtils</span><span class="p">.</span><span class="nx">range</span><span class="p">(</span><span class="nx">l</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">square</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">square</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="nx">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">y</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>另一个使用外部函数类型的示例:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Oracle</span> <span class="p">{</span>
  <span class="kd">struct</span> <span class="nx">Request</span> <span class="p">{</span>
    <span class="kt">bytes</span> <span class="nx">data</span><span class="p">;</span>
    <span class="kd">function</span><span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span><span class="p">)</span> <span class="k">external</span> <span class="nx">callback</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">Request</span><span class="p">[]</span> <span class="nx">requests</span><span class="p">;</span>
  <span class="kd">event</span> <span class="nx">NewRequest</span><span class="p">(</span><span class="kt">uint</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">query</span><span class="p">(</span><span class="kt">bytes</span> <span class="nx">data</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="kt">bytes</span> <span class="k">memory</span><span class="p">)</span> <span class="k">external</span> <span class="nx">callback</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="nx">requests</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Request</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">callback</span><span class="p">));</span>
    <span class="nx">emit</span> <span class="nx">NewRequest</span><span class="p">(</span><span class="nx">requests</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">reply</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">requestID</span><span class="p">,</span> <span class="kt">bytes</span> <span class="nx">response</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="c1">// Here goes the check that the reply comes from a trusted source</span>
    <span class="nx">requests</span><span class="p">[</span><span class="nx">requestID</span><span class="p">].</span><span class="nx">callback</span><span class="p">(</span><span class="nx">response</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">OracleUser</span> <span class="p">{</span>
  <span class="nx">Oracle</span> <span class="k">constant</span> <span class="nx">oracle</span> <span class="o">=</span> <span class="nx">Oracle</span><span class="p">(</span><span class="mh">0x1234567</span><span class="p">);</span> <span class="c1">// known contract</span>
  <span class="kd">function</span> <span class="nx">buySomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">oracle</span><span class="p">.</span><span class="nx">query</span><span class="p">(</span><span class="s2">"USD"</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">oracleResponse</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">oracleResponse</span><span class="p">(</span><span class="kt">bytes</span> <span class="nx">response</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="nb">require</span><span class="p">(</span>
        <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="kt">address</span><span class="p">(</span><span class="nx">oracle</span><span class="p">),</span>
        <span class="s2">"Only oracle can call this."</span>
    <span class="p">);</span>
    <span class="c1">// Use the data</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Lambda或内联函数是计划的，但还不支持。</p>
</div>
</div>
</div>
<div class="section" id="reference-types">
<span id="index-13"></span><h4>Reference Types<a class="headerlink" href="#reference-types" title="Permalink to this headline">¶</a></h4>
<p>复杂类型，即不总是符合256位的类型必须比我们已经看到的值类型更仔细地处理。由于复制它们可能非常昂贵，所以我们必须考虑是否要将它们存储在内存中(不是持久存储)或存储(在这里保存statevariables)。<strong>memory</strong><strong>storage</strong></p>
<div class="section" id="data-location">
<h5>Data location<a class="headerlink" href="#data-location" title="Permalink to this headline">¶</a></h5>
<p>每个复杂类型，即数组和结构，都有一个附加注释，即“数据位置”，关于它是否存储在内存中或存储中。根据不同的文本，始终存在默认值，但可以通过将存储或内存添加到类型中来覆盖。函数参数(包括返回参数)的默认值是内存，本地变量的默认值是存储，而位置是强制存储状态变量(显然)。<em>arrays</em><em>structs</em><code class="docutils literal"><span class="pre">storage</span></code><code class="docutils literal"><span class="pre">memory</span></code><code class="docutils literal"><span class="pre">memory</span></code><code class="docutils literal"><span class="pre">storage</span></code><code class="docutils literal"><span class="pre">storage</span></code></p>
<p>还有第三个数据位置，calldata，它是一个不可修改的、非持久的区域，其中存储了函数参数。外部函数的函数参数(不返回参数)被强制调用数据并表现得像内存一样。<code class="docutils literal"><span class="pre">calldata</span></code><code class="docutils literal"><span class="pre">calldata</span></code><code class="docutils literal"><span class="pre">memory</span></code></p>
<p>数据位置很重要，因为它们改变了分配的行为方式:存储和内存之间的分配以及状态变量(甚至来自其他状态变量)总是创建独立的副本。对于本地存储变量的赋值只分配一个引用，而这个引用总是指向状态变量，即使后者在此期间改变了。另一方面，从内存存储引用类型到另一个内存存储引用类型的赋值不会创建副本。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// the data location of x is storage</span>

    <span class="c1">// the data location of memoryArray is memory</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="nx">memoryArray</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">=</span> <span class="nx">memoryArray</span><span class="p">;</span> <span class="c1">// works, copies the whole array to storage</span>
        <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// works, assigns a pointer, data location of y is storage</span>
        <span class="nx">y</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span> <span class="c1">// fine, returns the 8th element</span>
        <span class="nx">y</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// fine, modifies x through y</span>
        <span class="k">delete</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// fine, clears the array, also modifies y</span>
        <span class="c1">// The following does not work; it would need to create a new temporary /</span>
        <span class="c1">// unnamed array in storage, but storage is "statically" allocated:</span>
        <span class="c1">// y = memoryArray;</span>
        <span class="c1">// This does not work either, since it would "reset" the pointer, but there</span>
        <span class="c1">// is no sensible location it could point to.</span>
        <span class="c1">// delete y;</span>
        <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// calls g, handing over a reference to x</span>
        <span class="nx">h</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// calls h and creates an independent, temporary copy in memory</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="k">storage</span> <span class="nx">storageArray</span><span class="p">)</span> <span class="k">internal</span> <span class="p">{}</span>
    <span class="kd">function</span> <span class="nx">h</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="nx">memoryArray</span><span class="p">)</span> <span class="k">public</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="summary">
<h6>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h6>
<dl class="docutils">
<dt>Forced data location:</dt>
<dd><ul class="first last simple">
<li>parameters (not return) of external functions: calldata</li>
<li>state variables: storage</li>
</ul>
</dd>
<dt>Default data location:</dt>
<dd><ul class="first last simple">
<li>parameters (also return) of functions: memory</li>
<li>all other local variables: storage</li>
</ul>
</dd>
</dl>
</div>
</div>
<div class="section" id="arrays">
<span id="index-14"></span><span id="id7"></span><h5>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h5>
<p>数组可以具有编译时的固定大小，也可以是动态的。对于存储数组，元素类型可以是任意的(也可以是其他数组、映射或结构)。对于内存数组，它不能是一个映射，如果它是公开可见的函数的参数，则必须是ABI类型。</p>
<p>一个固定大小k和元素类型T的数组被写成T[k]，一个动态大小的数组T[]。例如，uint的5个动态数组的数组是uint[][5](注意，与其他语言相比，这个符号是颠倒的)。要在第三个动态数组中访问第二个uint，您可以使用x[2][1](索引是基于零的，访问工作与声明相反，即x[2]从右边的类型中去掉一个级别)。<code class="docutils literal"><span class="pre">k</span></code><code class="docutils literal"><span class="pre">T</span></code><code class="docutils literal"><span class="pre">T[k]</span></code><code class="docutils literal"><span class="pre">T[]</span></code><code class="docutils literal"><span class="pre">uint</span></code><code class="docutils literal"><span class="pre">uint[][5]</span></code><code class="docutils literal"><span class="pre">x[2][1]</span></code><code class="docutils literal"><span class="pre">x[2]</span></code></p>
<p>类型字节和字符串的变量是特殊的数组。字节类似于字节[]，但它在calldata中紧密地打包。字符串等于字节，但不允许长度或索引访问(现在)。<code class="docutils literal"><span class="pre">bytes</span></code><code class="docutils literal"><span class="pre">string</span></code><code class="docutils literal"><span class="pre">bytes</span></code><code class="docutils literal"><span class="pre">byte[]</span></code><code class="docutils literal"><span class="pre">string</span></code><code class="docutils literal"><span class="pre">bytes</span></code></p>
<p>所以字节应该总是优先于字节[]，因为它更便宜。<code class="docutils literal"><span class="pre">bytes</span></code><code class="docutils literal"><span class="pre">byte[]</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">如果您想访问一个字符串s的字节表示法，usebytes(s)。长度/字节(s)[7] = 'x';请注意，您正在访问UTF-8表示的低级字节，而不是单个字符!<code class="docutils literal"><span class="pre">s</span></code><code class="docutils literal"><span class="pre">bytes(s).length</span></code><code class="docutils literal"><span class="pre">bytes(s)[7]</span> <span class="pre">=</span> <span class="pre">'x';</span></code></p>
</div>
<p>可以将数组标记为公有，并具有可靠的创建getter。数值索引将成为getter的必需参数。<code class="docutils literal"><span class="pre">public</span></code><a class="reference internal" href="index.html#visibility-and-getters"><span class="std std-ref">getter</span></a></p>
<div class="section" id="allocating-memory-arrays">
<span id="index-15"></span><h6>Allocating Memory Arrays<a class="headerlink" href="#allocating-memory-arrays" title="Permalink to this headline">¶</a></h6>
<p>可以使用新的关键字来创建具有可变长度的数组。与存储数组相反，不可能通过分配给.length成员来调整内存数组的大小。<code class="docutils literal"><span class="pre">new</span></code><strong>not</strong><code class="docutils literal"><span class="pre">.length</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">len</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="p">{</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="k">memory</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="mi">7</span><span class="p">);</span>
        <span class="kt">bytes</span> <span class="k">memory</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">bytes</span><span class="p">(</span><span class="nx">len</span><span class="p">);</span>
        <span class="c1">// Here we have a.length == 7 and b.length == len</span>
        <span class="nx">a</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="array-literals-inline-arrays">
<span id="index-16"></span><h6>Array Literals / Inline Arrays<a class="headerlink" href="#array-literals-inline-arrays" title="Permalink to this headline">¶</a></h6>
<p>数组文本是作为表达式编写的数组，并不是立即分配给一个变量。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="k">pure</span> <span class="p">{</span>
        <span class="nx">g</span><span class="p">([</span><span class="kt">uint</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="nx">_data</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>数组文字的类型是固定大小的内存数组，其basetype是给定元素的公共类型。[1,2,3]isuint8[3]内存的类型，因为每个常量的类型都是uint8。因此，必须将exampleabove中的第一个元素转换为uint。请注意，目前固定大小的内存数组不能分配给动态大小的内存数组，也就是说，以下是不可能的:<code class="docutils literal"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code><code class="docutils literal"><span class="pre">uint8[3]</span> <span class="pre">memory</span></code><code class="docutils literal"><span class="pre">uint8</span></code><code class="docutils literal"><span class="pre">uint</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="c1">// This will not compile.</span>

<span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// The next line creates a type error because uint[3] memory</span>
        <span class="c1">// cannot be converted to uint[] memory.</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">[</span><span class="kt">uint</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>它计划在未来移除这一限制，但目前由于数组在ABI中传递的方式而产生了一些复杂的问题。</p>
</div>
<div class="section" id="members">
<span id="index-17"></span><h6>Members<a class="headerlink" href="#members" title="Permalink to this headline">¶</a></h6>
<dl class="docutils">
<dt><strong>length</strong>:</dt>
<dd>Arrays have a <code class="docutils literal"><span class="pre">length</span></code> member to hold their number of elements.
Dynamic arrays can be resized in storage (not in memory) by changing the
<code class="docutils literal"><span class="pre">.length</span></code> member. This does not happen automatically when attempting to access elements outside the current length. The size of memory arrays is fixed (but dynamic, i.e. it can depend on runtime parameters) once they are created.</dd>
<dt><strong>push</strong>:</dt>
<dd>Dynamic storage arrays and <code class="docutils literal"><span class="pre">bytes</span></code> (not <code class="docutils literal"><span class="pre">string</span></code>) have a member function called <code class="docutils literal"><span class="pre">push</span></code> that can be used to append an element at the end of the array. The function returns the new length.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">还不可能在外部函数中使用数组数组。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>由于EVM的限制，不可能从外部函数调用返回动态内容。函数f incontract C {function f()返回(uint[]){…如果从web3调用，将会返回。js，但不是来自于固体。<code class="docutils literal"><span class="pre">f</span></code><code class="docutils literal"><span class="pre">contract</span> <span class="pre">C</span> <span class="pre">{</span> <span class="pre">function</span> <span class="pre">f()</span> <span class="pre">returns</span> <span class="pre">(uint[])</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span> <span class="pre">}</span></code></p>
<p class="last">目前唯一的解决方法是使用大型静态大小的数组。</p>
</div>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">ArrayContract</span> <span class="p">{</span>
    <span class="kt">uint</span><span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="mi">20</span><span class="p">]</span> <span class="nx">m_aLotOfIntegers</span><span class="p">;</span>
    <span class="c1">// Note that the following is not a pair of dynamic arrays but a</span>
    <span class="c1">// dynamic array of pairs (i.e. of fixed size arrays of length two).</span>
    <span class="kt">bool</span><span class="p">[</span><span class="mi">2</span><span class="p">][]</span> <span class="nx">m_pairsOfFlags</span><span class="p">;</span>
    <span class="c1">// newPairs is stored in memory - the default for function arguments</span>

    <span class="kd">function</span> <span class="nx">setAllFlagPairs</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="mi">2</span><span class="p">][]</span> <span class="nx">newPairs</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// assignment to a storage array replaces the complete array</span>
        <span class="nx">m_pairsOfFlags</span> <span class="o">=</span> <span class="nx">newPairs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">setFlagPair</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">index</span><span class="p">,</span> <span class="kt">bool</span> <span class="nx">flagA</span><span class="p">,</span> <span class="kt">bool</span> <span class="nx">flagB</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// access to a non-existing index will throw an exception</span>
        <span class="nx">m_pairsOfFlags</span><span class="p">[</span><span class="nx">index</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">flagA</span><span class="p">;</span>
        <span class="nx">m_pairsOfFlags</span><span class="p">[</span><span class="nx">index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">flagB</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">changeFlagArraySize</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">newSize</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// if the new size is smaller, removed array elements will be cleared</span>
        <span class="nx">m_pairsOfFlags</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="nx">newSize</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">clear</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// these clear the arrays completely</span>
        <span class="k">delete</span> <span class="nx">m_pairsOfFlags</span><span class="p">;</span>
        <span class="k">delete</span> <span class="nx">m_aLotOfIntegers</span><span class="p">;</span>
        <span class="c1">// identical effect here</span>
        <span class="nx">m_pairsOfFlags</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bytes</span> <span class="nx">m_byteData</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">byteArrays</span><span class="p">(</span><span class="kt">bytes</span> <span class="nx">data</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// byte arrays ("bytes") are different as they are stored without padding,</span>
        <span class="c1">// but can be treated identical to "uint8[]"</span>
        <span class="nx">m_byteData</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
        <span class="nx">m_byteData</span><span class="p">.</span><span class="nx">length</span> <span class="o">+=</span> <span class="mi">7</span><span class="p">;</span>
        <span class="nx">m_byteData</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="kt">byte</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
        <span class="k">delete</span> <span class="nx">m_byteData</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">addFlag</span><span class="p">(</span><span class="kt">bool</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="nx">flag</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">m_pairsOfFlags</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">flag</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">createMemoryArray</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">size</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Dynamic memory arrays are created using `new`:</span>
        <span class="kt">uint</span><span class="p">[</span><span class="mi">2</span><span class="p">][]</span> <span class="k">memory</span> <span class="nx">arrayOfPairs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[</span><span class="mi">2</span><span class="p">][](</span><span class="nx">size</span><span class="p">);</span>
        <span class="c1">// Create a dynamic byte array:</span>
        <span class="kt">bytes</span> <span class="k">memory</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">bytes</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
            <span class="nx">b</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="kt">byte</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="structs">
<span id="index-18"></span><span id="id8"></span><h5>Structs<a class="headerlink" href="#structs" title="Permalink to this headline">¶</a></h5>
<p>Solidity提供了一种以结构形式定义新类型的方法，如下例所示:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">CrowdFunding</span> <span class="p">{</span>
    <span class="c1">// Defines a new type with two fields.</span>
    <span class="kd">struct</span> <span class="nx">Funder</span> <span class="p">{</span>
        <span class="kt">address</span> <span class="nx">addr</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="nx">amount</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">struct</span> <span class="nx">Campaign</span> <span class="p">{</span>
        <span class="kt">address</span> <span class="nx">beneficiary</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="nx">fundingGoal</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="nx">numFunders</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="nx">amount</span><span class="p">;</span>
        <span class="k">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="nx">Funder</span><span class="p">)</span> <span class="nx">funders</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">uint</span> <span class="nx">numCampaigns</span><span class="p">;</span>
    <span class="k">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="nx">Campaign</span><span class="p">)</span> <span class="nx">campaigns</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">newCampaign</span><span class="p">(</span><span class="kt">address</span> <span class="nx">beneficiary</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">goal</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">campaignID</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">campaignID</span> <span class="o">=</span> <span class="nx">numCampaigns</span><span class="o">++</span><span class="p">;</span> <span class="c1">// campaignID is return variable</span>
        <span class="c1">// Creates new struct and saves in storage. We leave out the mapping type.</span>
        <span class="nx">campaigns</span><span class="p">[</span><span class="nx">campaignID</span><span class="p">]</span> <span class="o">=</span> <span class="nx">Campaign</span><span class="p">(</span><span class="nx">beneficiary</span><span class="p">,</span> <span class="nx">goal</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">contribute</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">campaignID</span><span class="p">)</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="nx">Campaign</span> <span class="k">storage</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">campaigns</span><span class="p">[</span><span class="nx">campaignID</span><span class="p">];</span>
        <span class="c1">// Creates a new temporary memory struct, initialised with the given values</span>
        <span class="c1">// and copies it over to storage.</span>
        <span class="c1">// Note that you can also use Funder(msg.sender, msg.value) to initialise.</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">funders</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">numFunders</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">Funder</span><span class="p">({</span><span class="nx">addr</span><span class="o">:</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">amount</span><span class="o">:</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">});</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">amount</span> <span class="o">+=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">checkGoalReached</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">campaignID</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="nx">reached</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">Campaign</span> <span class="k">storage</span> <span class="nx">c</span> <span class="o">=</span> <span class="nx">campaigns</span><span class="p">[</span><span class="nx">campaignID</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">amount</span> <span class="o">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">fundingGoal</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="nx">amount</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">amount</span><span class="p">;</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">amount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">beneficiary</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">amount</span><span class="p">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>合约并没有提供一个众包合约的全部功能，但它包含了理解结构所必需的基本概念。结构类型可以在映射和数组中使用，它们可以包含映射和数组。</p>
<p>结构体不可能包含它自己类型的成员，尽管结构本身可以是映射成员的值类型。这个限制是必要的，因为结构的大小必须是有限的。</p>
<p>注意，在所有函数中，结构类型被分配给一个局部变量(默认存储数据位置)。这不会复制struct，但只存储一个引用，这样本地变量的赋值就会实际写入状态。</p>
<p>当然，您也可以直接访问struct的成员，并将其分配给一个局部变量，就像inactivity [campaignID]。数量= 0。<code class="docutils literal"><span class="pre">campaigns[campaignID].amount</span> <span class="pre">=</span> <span class="pre">0</span></code></p>
</div>
</div>
<div class="section" id="mappings">
<span id="index-19"></span><h4>Mappings<a class="headerlink" href="#mappings" title="Permalink to this headline">¶</a></h4>
<p>映射类型被声明为映射(_KeyType =&gt; _ValueType)。这里_KeyType几乎可以是任何类型，除了一个映射、一个动态大小的数组、一个合约、一个enum和一个struct。_ValueType实际上可以是任何类型，包括映射。<code class="docutils literal"><span class="pre">mapping(_KeyType</span> <span class="pre">=&gt;</span> <span class="pre">_ValueType)</span></code><code class="docutils literal"><span class="pre">_KeyType</span></code><code class="docutils literal"><span class="pre">_ValueType</span></code></p>
<p>映射可以被看作是哈希表，它实际上是初始化的，每一个可能的键都存在，并被映射到一个值，它的字节表示法都是零:一个类型的默认值。但这里的相似之处是:关键数据实际上并不是存储在映射中，而是用于查找值的keccak256散列。<a class="reference external" href="https://en.wikipedia.org/wiki/Hash_table">hash tables</a><a class="reference internal" href="index.html#default-value"><span class="std std-ref">default value</span></a><code class="docutils literal"><span class="pre">keccak256</span></code></p>
<p>正因为如此，映射没有长度或一个键的概念或值被“设置”。</p>
<p>映射只允许状态变量(或者作为内部函数的存储引用类型)。</p>
<p>可以将映射标记为公有，并具有可靠的创建getter。_KeyType将成为getter的必需参数，它将返回_ValueType。<code class="docutils literal"><span class="pre">public</span></code><a class="reference internal" href="index.html#visibility-and-getters"><span class="std std-ref">getter</span></a><code class="docutils literal"><span class="pre">_KeyType</span></code><code class="docutils literal"><span class="pre">_ValueType</span></code></p>
<p>_ValueType也可以是一个映射。getter将为每个_KeyType(递归地)提供一个参数。<code class="docutils literal"><span class="pre">_ValueType</span></code><code class="docutils literal"><span class="pre">_KeyType</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">MappingExample</span> <span class="p">{</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="k">public</span> <span class="nx">balances</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">update</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">newBalance</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">balances</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newBalance</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">MappingUser</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">MappingExample</span> <span class="nx">m</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MappingExample</span><span class="p">();</span>
        <span class="nx">m</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">m</span><span class="p">.</span><span class="nx">balances</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">映射不是可迭代的，但是可以在它们之上实现一个数据结构。例如，请参阅iterable映射。<a class="reference external" href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">iterable mapping</a></p>
</div>
</div>
<div class="section" id="operators-involving-lvalues">
<span id="index-20"></span><h4>Operators Involving LValues<a class="headerlink" href="#operators-involving-lvalues" title="Permalink to this headline">¶</a></h4>
<p>如果a是一个LValue(即一个变量或可以分配给它的变量)，下面的操作符可用作shorthands:<code class="docutils literal"><span class="pre">a</span></code></p>
<p><code class="docutils literal"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">e</span></code>+ = e相当于= a + e。运营商- = * =,/ = % = | = &amp; = ^ =相应的定义。a++和a——等价于a+ = 1 / a- = 1，但表达式本身仍然具有a的前值，而a和+a对a具有相同的作用，但在变化后返回值。<code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">+</span> <span class="pre">e</span></code><code class="docutils literal"><span class="pre">-=</span></code><code class="docutils literal"><span class="pre">*=</span></code><code class="docutils literal"><span class="pre">/=</span></code><code class="docutils literal"><span class="pre">%=</span></code><code class="docutils literal"><span class="pre">|=</span></code><code class="docutils literal"><span class="pre">&amp;=</span></code><code class="docutils literal"><span class="pre">^=</span></code><code class="docutils literal"><span class="pre">a++</span></code><code class="docutils literal"><span class="pre">a--</span></code><code class="docutils literal"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">1</span></code><code class="docutils literal"><span class="pre">a</span> <span class="pre">-=</span> <span class="pre">1</span></code><code class="docutils literal"><span class="pre">a</span></code><code class="docutils literal"><span class="pre">--a</span></code><code class="docutils literal"><span class="pre">++a</span></code><code class="docutils literal"><span class="pre">a</span></code></p>
<div class="section" id="delete">
<h5>delete<a class="headerlink" href="#delete" title="Permalink to this headline">¶</a></h5>
<p><code class="docutils literal"><span class="pre">delete</span> <span class="pre">a</span></code>delete a将类型的初始值赋给a，即对于整数来说，它等价于a = 0，但也可以在数组中使用，在数组中，它分配一个长度为0的动态数组，或者是与所有元素重置相同长度的静态数组。对于struct，它会分配一个包含所有成员重置的struct。<code class="docutils literal"><span class="pre">a</span></code><code class="docutils literal"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">0</span></code></p>
<p><code class="docutils literal"><span class="pre">delete</span></code>delete对整个映射没有影响(因为映射的键可能是任意的，而且通常是未知的)。因此，如果你删除一个struct，它将重置所有不是映射的成员，并且递归到成员中，除非它们是映射。但是，单独的键和它们映射到的内容可以被删除。</p>
<p>需要注意的是，delete a确实像赋值给a，即在a中存储一个新对象。<code class="docutils literal"><span class="pre">delete</span> <span class="pre">a</span></code><code class="docutils literal"><span class="pre">a</span></code><code class="docutils literal"><span class="pre">a</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">DeleteExample</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="nx">data</span><span class="p">;</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="nx">dataArray</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
        <span class="k">delete</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// sets x to 0, does not affect data</span>
        <span class="k">delete</span> <span class="nx">data</span><span class="p">;</span> <span class="c1">// sets data to 0, does not affect x which still holds a copy</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="k">storage</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">dataArray</span><span class="p">;</span>
        <span class="k">delete</span> <span class="nx">dataArray</span><span class="p">;</span> <span class="c1">// this sets dataArray.length to zero, but as uint[] is a complex object, also</span>
        <span class="c1">// y is affected which is an alias to the storage object</span>
        <span class="c1">// On the other hand: "delete y" is not valid, as assignments to local variables</span>
        <span class="c1">// referencing storage objects can only be made from existing storage objects.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="conversions-between-elementary-types">
<span id="index-21"></span><h4>Conversions between Elementary Types<a class="headerlink" href="#conversions-between-elementary-types" title="Permalink to this headline">¶</a></h4>
<div class="section" id="implicit-conversions">
<h5>Implicit Conversions<a class="headerlink" href="#implicit-conversions" title="Permalink to this headline">¶</a></h5>
<p>如果一个操作符被应用到不同的类型，编译器会试图隐式地将一个操作数转换为另一个操作数(同样的istrue赋值)。一般来说，如果在语义上有意义，而且没有信息丢失，那么在价值类型转换之间的隐式转换就可能发生:uint8是可转换的touint16和int128到int256，但int8不能转换为uint256(因为uint256不能保持为-1)。此外，无符号整数可以转换为相同或更大的字节，但反之亦然。任何可以转换为uint160的类型都可以转换为地址。<code class="docutils literal"><span class="pre">uint8</span></code><code class="docutils literal"><span class="pre">uint16</span></code><code class="docutils literal"><span class="pre">int128</span></code><code class="docutils literal"><span class="pre">int256</span></code><code class="docutils literal"><span class="pre">int8</span></code><code class="docutils literal"><span class="pre">uint256</span></code><code class="docutils literal"><span class="pre">uint256</span></code><code class="docutils literal"><span class="pre">-1</span></code><code class="docutils literal"><span class="pre">uint160</span></code><code class="docutils literal"><span class="pre">address</span></code></p>
</div>
<div class="section" id="explicit-conversions">
<h5>Explicit Conversions<a class="headerlink" href="#explicit-conversions" title="Permalink to this headline">¶</a></h5>
<p>如果编译器不允许隐式转换，但是您知道您在做什么，那么显式的类型转换有时是可能的。请注意，这可能会给您带来一些意料之外的行为，所以一定要测试以确保您想要的结果!下面的例子中，你将一个负的int8转换为uint:<code class="docutils literal"><span class="pre">int8</span></code><code class="docutils literal"><span class="pre">uint</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kt">int8</span> <span class="nx">y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
<span class="kt">uint</span> <span class="nx">x</span> <span class="o">=</span> <span class="kt">uint</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
</pre></div>
</div>
<p>在这个代码段的末尾，x将有值0xfffff..fd(64个hexcharacters)，它是-3在两个256位的补码表示中。<code class="docutils literal"><span class="pre">x</span></code><code class="docutils literal"><span class="pre">0xfffff..fd</span></code></p>
<p>如果类型被显式地转换为较小的类型，则会删除高阶位:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kt">uint32</span> <span class="nx">a</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span>
<span class="kt">uint16</span> <span class="nx">b</span> <span class="o">=</span> <span class="kt">uint16</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// b will be 0x5678 now</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="type-deduction">
<span id="index-22"></span><span id="id9"></span><h4>Type Deduction<a class="headerlink" href="#type-deduction" title="Permalink to this headline">¶</a></h4>
<p>为了方便起见，并不总是需要显式地指定avariable的类型，编译器会自动将它从分配给变量的firstexpression类型中推断出来:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kt">uint24</span> <span class="nx">x</span> <span class="o">=</span> <span class="mh">0x123</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
</pre></div>
</div>
<p>这里y的类型是uint24。使用var不可能用于函数参数或返回参数。<code class="docutils literal"><span class="pre">y</span></code><code class="docutils literal"><span class="pre">uint24</span></code><code class="docutils literal"><span class="pre">var</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">该类型仅从第一个赋值推导出来，在下面的代码段中，sothe循环是无限的，因为我将拥有typeuint8，并且该类型的最高值小于2000。for (var i = 0;我&lt; 2000;我+ +){…}<code class="docutils literal"><span class="pre">i</span></code><code class="docutils literal"><span class="pre">uint8</span></code><code class="docutils literal"><span class="pre">2000</span></code><code class="docutils literal"><span class="pre">for</span> <span class="pre">(var</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">2000;</span> <span class="pre">i++)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code></p>
</div>
</div>
</div>
<span id="document-units-and-global-variables"></span><div class="section" id="units-and-globally-available-variables">
<h3>Units and Globally Available Variables<a class="headerlink" href="#units-and-globally-available-variables" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ether-units">
<span id="index-0"></span><h4>Ether Units<a class="headerlink" href="#ether-units" title="Permalink to this headline">¶</a></h4>
<p>一个文字数字可以用“魏”、“finney”、“szabo”或“以太”的后缀来转换“以太”的子面值，假设没有后缀的以太货币数字为“wei”，例如:2“ether == 2000 finney”的计算结果为true。<code class="docutils literal"><span class="pre">wei</span></code><code class="docutils literal"><span class="pre">finney</span></code><code class="docutils literal"><span class="pre">szabo</span></code><code class="docutils literal"><span class="pre">ether</span></code><code class="docutils literal"><span class="pre">2</span> <span class="pre">ether</span> <span class="pre">==</span> <span class="pre">2000</span> <span class="pre">finney</span></code><code class="docutils literal"><span class="pre">true</span></code></p>
</div>
<div class="section" id="time-units">
<span id="index-1"></span><h4>Time Units<a class="headerlink" href="#time-units" title="Permalink to this headline">¶</a></h4>
<p>后缀，如秒，分钟，小时，天，数周，数年之后，数字可以用来转换单位的时间，秒是基部和单位被认为是天真的如下方式:<code class="docutils literal"><span class="pre">seconds</span></code><code class="docutils literal"><span class="pre">minutes</span></code><code class="docutils literal"><span class="pre">hours</span></code><code class="docutils literal"><span class="pre">days</span></code><code class="docutils literal"><span class="pre">weeks</span></code><code class="docutils literal"><span class="pre">years</span></code></p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">1</span> <span class="pre">==</span> <span class="pre">1</span> <span class="pre">seconds</span></code></li>
<li><code class="docutils literal"><span class="pre">1</span> <span class="pre">minutes</span> <span class="pre">==</span> <span class="pre">60</span> <span class="pre">seconds</span></code></li>
<li><code class="docutils literal"><span class="pre">1</span> <span class="pre">hours</span> <span class="pre">==</span> <span class="pre">60</span> <span class="pre">minutes</span></code></li>
<li><code class="docutils literal"><span class="pre">1</span> <span class="pre">days</span> <span class="pre">==</span> <span class="pre">24</span> <span class="pre">hours</span></code></li>
<li><code class="docutils literal"><span class="pre">1</span> <span class="pre">weeks</span> <span class="pre">==</span> <span class="pre">7</span> <span class="pre">days</span></code></li>
<li><code class="docutils literal"><span class="pre">1</span> <span class="pre">years</span> <span class="pre">==</span> <span class="pre">365</span> <span class="pre">days</span></code></li>
</ul>
</div></blockquote>
<p>请注意，如果你使用这些单位进行日历计算，因为每一年等于365天，而不是每一天都有24小时，因为闰秒。由于不能预测闰秒的事实，精确的日历库必须由外部的oracle更新。<a class="reference external" href="https://en.wikipedia.org/wiki/Leap_second">leap seconds</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">由于上述原因，后缀年份已被弃用。<code class="docutils literal"><span class="pre">years</span></code></p>
</div>
<p>这些后缀不能应用于变量。如果你想要解释一些输入变量，例如:days，你可以用以下方法来做:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">start</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">daysAfter</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">now</span> <span class="o">&gt;=</span> <span class="nx">start</span> <span class="o">+</span> <span class="nx">daysAfter</span> <span class="o">*</span> <span class="mi">1</span> <span class="kt">days</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="special-variables-and-functions">
<h4>Special Variables and Functions<a class="headerlink" href="#special-variables-and-functions" title="Permalink to this headline">¶</a></h4>
<p>在globalnamespace中有一些特殊的变量和函数，它们主要用于提供关于blockchainor的信息，或者是通用的实用函数。</p>
<div class="section" id="block-and-transaction-properties">
<span id="index-2"></span><h5>Block and Transaction Properties<a class="headerlink" href="#block-and-transaction-properties" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">block.blockhash(uint</span> <span class="pre">blockNumber)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>: hash of the given block - only works for 256 most recent, excluding current, blocks - deprecated in version 0.4.22 and replaced by <code class="docutils literal"><span class="pre">blockhash(uint</span> <span class="pre">blockNumber)</span></code>.</li>
<li><code class="docutils literal"><span class="pre">block.coinbase</span></code> (<code class="docutils literal"><span class="pre">address</span></code>): current block miner’s address</li>
<li><code class="docutils literal"><span class="pre">block.difficulty</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): current block difficulty</li>
<li><code class="docutils literal"><span class="pre">block.gaslimit</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): current block gaslimit</li>
<li><code class="docutils literal"><span class="pre">block.number</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): current block number</li>
<li><code class="docutils literal"><span class="pre">block.timestamp</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): current block timestamp as seconds since unix epoch</li>
<li><code class="docutils literal"><span class="pre">gasleft()</span> <span class="pre">returns</span> <span class="pre">(uint256)</span></code>: remaining gas</li>
<li><code class="docutils literal"><span class="pre">msg.data</span></code> (<code class="docutils literal"><span class="pre">bytes</span></code>): complete calldata</li>
<li><code class="docutils literal"><span class="pre">msg.gas</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): remaining gas - deprecated in version 0.4.21 and to be replaced by <code class="docutils literal"><span class="pre">gasleft()</span></code></li>
<li><code class="docutils literal"><span class="pre">msg.sender</span></code> (<code class="docutils literal"><span class="pre">address</span></code>): sender of the message (current call)</li>
<li><code class="docutils literal"><span class="pre">msg.sig</span></code> (<code class="docutils literal"><span class="pre">bytes4</span></code>): first four bytes of the calldata (i.e. function identifier)</li>
<li><code class="docutils literal"><span class="pre">msg.value</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): number of wei sent with the message</li>
<li><code class="docutils literal"><span class="pre">now</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): current block timestamp (alias for <code class="docutils literal"><span class="pre">block.timestamp</span></code>)</li>
<li><code class="docutils literal"><span class="pre">tx.gasprice</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): gas price of the transaction</li>
<li><code class="docutils literal"><span class="pre">tx.origin</span></code> (<code class="docutils literal"><span class="pre">address</span></code>): sender of the transaction (full call chain)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">msg所有成员的值，包括msg。发送方andmsg。值可以更改每个外部函数调用。这包括调用库函数。<code class="docutils literal"><span class="pre">msg</span></code><code class="docutils literal"><span class="pre">msg.sender</span></code><code class="docutils literal"><span class="pre">msg.value</span></code><strong>external</strong></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>不要依赖于块。时间戳，现在和blockhash作为一个随机性的来源，除非你知道你在做什么。<code class="docutils literal"><span class="pre">block.timestamp</span></code><code class="docutils literal"><span class="pre">now</span></code><code class="docutils literal"><span class="pre">blockhash</span></code></p>
<p>时间戳和块散列都可以在一定程度上受到矿商的影响。例如，采矿社区的坏行为者可以在选择的哈希上运行一个赌场支付函数，如果他们没有收到任何钱，就重新尝试不同的哈希。</p>
<p class="last">当前块时间戳必须严格大于最后一个块的时间戳，但唯一的保证是它将位于规范链中两个连续块的时间戳之间。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">由于可伸缩性的原因，所有块都不能使用块哈希。您只能访问最近256个块的散列，所有其他值都为零。</p>
</div>
</div>
<div class="section" id="abi-encoding-functions">
<span id="index-3"></span><h5>ABI Encoding Functions<a class="headerlink" href="#abi-encoding-functions" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">abi.encode(...)</span> <span class="pre">returns</span> <span class="pre">(bytes)</span></code>: ABI-encodes the given arguments</li>
<li><code class="docutils literal"><span class="pre">abi.encodePacked(...)</span> <span class="pre">returns</span> <span class="pre">(bytes)</span></code>: Performes packed encoding of the given arguments</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">abi.encodeWithSelector(bytes4</span> <span class="pre">selector,</span> <span class="pre">...)</span> <span class="pre">returns</span> <span class="pre">(bytes)</span></code>: ABI-encodes the given arguments</dt>
<dd>starting from the second and prepends the given four-byte selector</dd>
</dl>
</li>
<li><code class="docutils literal"><span class="pre">abi.encodeWithSignature(string</span> <span class="pre">signature,</span> <span class="pre">...)</span> <span class="pre">returns</span> <span class="pre">(bytes)</span></code>: Equivalent to <code class="docutils literal"><span class="pre">abi.encodeWithSelector(bytes4(keccak256(signature),</span> <span class="pre">...)`</span></code></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">这些编码函数可以用来为函数调用提供数据，而不需要实际调用函数。此外,keccak256(abi。encodePacked(a, b))是计算keccak256(a, b)的更为明确的方法，在未来版本中会被废弃。<code class="docutils literal"><span class="pre">keccak256(abi.encodePacked(a,</span> <span class="pre">b))</span></code><code class="docutils literal"><span class="pre">keccak256(a,</span> <span class="pre">b)</span></code></p>
</div>
<p>有关ABI和编码的详细信息，请参阅相关文档。<a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI</span></a><a class="reference internal" href="index.html#abi-packed-mode"><span class="std std-ref">tightly packed encoding</span></a></p>
</div>
<div class="section" id="error-handling">
<span id="index-4"></span><h5>Error Handling<a class="headerlink" href="#error-handling" title="Permalink to this headline">¶</a></h5>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">assert(bool</span> <span class="pre">condition)</span></code>:</dt>
<dd>invalidates the transaction if the condition is not met - to be used for internal errors.</dd>
<dt><code class="docutils literal"><span class="pre">require(bool</span> <span class="pre">condition)</span></code>:</dt>
<dd>reverts if the condition is not met - to be used for errors in inputs or external components.</dd>
<dt><code class="docutils literal"><span class="pre">require(bool</span> <span class="pre">condition,</span> <span class="pre">string</span> <span class="pre">message)</span></code>:</dt>
<dd>reverts if the condition is not met - to be used for errors in inputs or external components. Also provides an error message.</dd>
<dt><code class="docutils literal"><span class="pre">revert()</span></code>:</dt>
<dd>abort execution and revert state changes</dd>
<dt><code class="docutils literal"><span class="pre">revert(string</span> <span class="pre">reason)</span></code>:</dt>
<dd>abort execution and revert state changes, providing an explanatory string</dd>
</dl>
</div>
<div class="section" id="mathematical-and-cryptographic-functions">
<span id="index-5"></span><h5>Mathematical and Cryptographic Functions<a class="headerlink" href="#mathematical-and-cryptographic-functions" title="Permalink to this headline">¶</a></h5>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">addmod(uint</span> <span class="pre">x,</span> <span class="pre">uint</span> <span class="pre">y,</span> <span class="pre">uint</span> <span class="pre">k)</span> <span class="pre">returns</span> <span class="pre">(uint)</span></code>:</dt>
<dd>compute <code class="docutils literal"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">k</span></code> where the addition is performed with arbitrary precision and does not wrap around at <code class="docutils literal"><span class="pre">2**256</span></code>. Assert that <code class="docutils literal"><span class="pre">k</span> <span class="pre">!=</span> <span class="pre">0</span></code> starting from version 0.5.0.</dd>
<dt><code class="docutils literal"><span class="pre">mulmod(uint</span> <span class="pre">x,</span> <span class="pre">uint</span> <span class="pre">y,</span> <span class="pre">uint</span> <span class="pre">k)</span> <span class="pre">returns</span> <span class="pre">(uint)</span></code>:</dt>
<dd>compute <code class="docutils literal"><span class="pre">(x</span> <span class="pre">*</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">k</span></code> where the multiplication is performed with arbitrary precision and does not wrap around at <code class="docutils literal"><span class="pre">2**256</span></code>. Assert that <code class="docutils literal"><span class="pre">k</span> <span class="pre">!=</span> <span class="pre">0</span></code> starting from version 0.5.0.</dd>
<dt><code class="docutils literal"><span class="pre">keccak256(...)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>:</dt>
<dd>compute the Ethereum-SHA-3 (Keccak-256) hash of the <a class="reference internal" href="index.html#abi-packed-mode"><span class="std std-ref">(tightly packed) arguments</span></a></dd>
<dt><code class="docutils literal"><span class="pre">sha256(...)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>:</dt>
<dd>compute the SHA-256 hash of the <a class="reference internal" href="index.html#abi-packed-mode"><span class="std std-ref">(tightly packed) arguments</span></a></dd>
<dt><code class="docutils literal"><span class="pre">sha3(...)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>:</dt>
<dd>alias to <code class="docutils literal"><span class="pre">keccak256</span></code></dd>
<dt><code class="docutils literal"><span class="pre">ripemd160(...)</span> <span class="pre">returns</span> <span class="pre">(bytes20)</span></code>:</dt>
<dd>compute RIPEMD-160 hash of the <a class="reference internal" href="index.html#abi-packed-mode"><span class="std std-ref">(tightly packed) arguments</span></a></dd>
<dt><code class="docutils literal"><span class="pre">ecrecover(bytes32</span> <span class="pre">hash,</span> <span class="pre">uint8</span> <span class="pre">v,</span> <span class="pre">bytes32</span> <span class="pre">r,</span> <span class="pre">bytes32</span> <span class="pre">s)</span> <span class="pre">returns</span> <span class="pre">(address)</span></code>:</dt>
<dd>recover the address associated with the public key from elliptic curve signature or return zero on error
(<a class="reference external" href="https://ethereum.stackexchange.com/q/1777/222">example usage</a>)</dd>
</dl>
<p>在上面，“紧密填充”意味着参数没有填充。这意味着以下内容都是相同的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nb">keccak256</span><span class="p">(</span><span class="s2">"ab"</span><span class="p">,</span> <span class="s2">"c"</span><span class="p">)</span>
<span class="nb">keccak256</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">)</span>
<span class="nb">keccak256</span><span class="p">(</span><span class="mh">0x616263</span><span class="p">)</span>
<span class="nb">keccak256</span><span class="p">(</span><span class="mi">6382179</span><span class="p">)</span>
<span class="nb">keccak256</span><span class="p">(</span><span class="mi">97</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
</pre></div>
</div>
<p>如果需要填充，可以使用显式类型转换:keccak256(“\x00\x12”)与keccak256(uint16(0x12))相同。<code class="docutils literal"><span class="pre">keccak256("\x00\x12")</span></code><code class="docutils literal"><span class="pre">keccak256(uint16(0x12))</span></code></p>
<p>注意，常量将使用存储它们所需的最小字节数来填充。这意味着，例如，keccak256(0) == keccak256(uint8(0))和keccak256(0x12345678) == keccak256(uint32(0x12345678))。<code class="docutils literal"><span class="pre">keccak256(0)</span> <span class="pre">==</span> <span class="pre">keccak256(uint8(0))</span></code><code class="docutils literal"><span class="pre">keccak256(0x12345678)</span> <span class="pre">==</span> <span class="pre">keccak256(uint32(0x12345678))</span></code></p>
<p>这可能是因为你在一个私人区块链上遇到了sha256、ripemd160或ec的out - gas。这样做的原因是，这些合约是作为所谓的预编译合约实现的，而这些合约只有在收到第一个消息之后才真正存在(尽管它们的合约代码是硬编码的)。对不存在的合约的消息会更昂贵，因此执行会遇到一个非气体错误。解决这个问题的办法是在你把合约用在你的实际合约之前先给每个合约发送一个。这不是官方或测试网的问题。<code class="docutils literal"><span class="pre">sha256</span></code><code class="docutils literal"><span class="pre">ripemd160</span></code><code class="docutils literal"><span class="pre">ecrecover</span></code><em>private blockchain</em></p>
</div>
<div class="section" id="address-related">
<span id="index-6"></span><span id="id1"></span><h5>Address Related<a class="headerlink" href="#address-related" title="Permalink to this headline">¶</a></h5>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">&lt;address&gt;.balance</span></code> (<code class="docutils literal"><span class="pre">uint256</span></code>):</dt>
<dd>balance of the <a class="reference internal" href="index.html#address"><span class="std std-ref">Address</span></a> in Wei</dd>
<dt><code class="docutils literal"><span class="pre">&lt;address&gt;.transfer(uint256</span> <span class="pre">amount)</span></code>:</dt>
<dd>send given amount of Wei to <a class="reference internal" href="index.html#address"><span class="std std-ref">Address</span></a>, throws on failure, forwards 2300 gas stipend, not adjustable</dd>
<dt><code class="docutils literal"><span class="pre">&lt;address&gt;.send(uint256</span> <span class="pre">amount)</span> <span class="pre">returns</span> <span class="pre">(bool)</span></code>:</dt>
<dd>send given amount of Wei to <a class="reference internal" href="index.html#address"><span class="std std-ref">Address</span></a>, returns <code class="docutils literal"><span class="pre">false</span></code> on failure, forwards 2300 gas stipend, not adjustable</dd>
<dt><code class="docutils literal"><span class="pre">&lt;address&gt;.call(...)</span> <span class="pre">returns</span> <span class="pre">(bool)</span></code>:</dt>
<dd>issue low-level <code class="docutils literal"><span class="pre">CALL</span></code>, returns <code class="docutils literal"><span class="pre">false</span></code> on failure, forwards all available gas, adjustable</dd>
<dt><code class="docutils literal"><span class="pre">&lt;address&gt;.callcode(...)</span> <span class="pre">returns</span> <span class="pre">(bool)</span></code>:</dt>
<dd>issue low-level <code class="docutils literal"><span class="pre">CALLCODE</span></code>, returns <code class="docutils literal"><span class="pre">false</span></code> on failure, forwards all available gas, adjustable</dd>
<dt><code class="docutils literal"><span class="pre">&lt;address&gt;.delegatecall(...)</span> <span class="pre">returns</span> <span class="pre">(bool)</span></code>:</dt>
<dd>issue low-level <code class="docutils literal"><span class="pre">DELEGATECALL</span></code>, returns <code class="docutils literal"><span class="pre">false</span></code> on failure, forwards all available gas, adjustable</dd>
</dl>
<p>有关更多信息，请参见地址部分。<a class="reference internal" href="index.html#address"><span class="std std-ref">Address</span></a></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">使用send有一些危险:如果调用堆栈深度为1024(这可能总是由调用者强制)，传输失败，并且如果收件人耗尽了气体，也会失败。因此，为了确保安全的以太传输，总是要检查发送的返回值，使用转移或者更好的:使用一个模式，接收者收回钱。<code class="docutils literal"><span class="pre">send</span></code><code class="docutils literal"><span class="pre">send</span></code><code class="docutils literal"><span class="pre">transfer</span></code></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">如果存储变量是通过低级别的委托来访问的，那么两个contractsmust的存储布局就会对齐，以使被调用的合约能够按名称正确地访问调用合约的存储变量。如果将存储指针作为函数参数传递给高级库，这当然不是问题。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">我们不鼓励使用callcode，并且在将来会被删除。<code class="docutils literal"><span class="pre">callcode</span></code></p>
</div>
</div>
<div class="section" id="contract-related">
<span id="index-7"></span><h5>Contract Related<a class="headerlink" href="#contract-related" title="Permalink to this headline">¶</a></h5>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">this</span></code> (current contract’s type):</dt>
<dd>the current contract, explicitly convertible to <a class="reference internal" href="index.html#address"><span class="std std-ref">Address</span></a></dd>
<dt><code class="docutils literal"><span class="pre">selfdestruct(address</span> <span class="pre">recipient)</span></code>:</dt>
<dd>destroy the current contract, sending its funds to the given <a class="reference internal" href="index.html#address"><span class="std std-ref">Address</span></a></dd>
<dt><code class="docutils literal"><span class="pre">suicide(address</span> <span class="pre">recipient)</span></code>:</dt>
<dd>deprecated alias to <code class="docutils literal"><span class="pre">selfdestruct</span></code></dd>
</dl>
<p>此外，当前合约的所有功能都可以直接调用，包括当前的功能。</p>
</div>
</div>
</div>
<span id="document-control-structures"></span><div class="section" id="expressions-and-control-structures">
<h3>Expressions and Control Structures<a class="headerlink" href="#expressions-and-control-structures" title="Permalink to this headline">¶</a></h3>
<div class="section" id="input-parameters-and-output-parameters">
<span id="index-0"></span><h4>Input Parameters and Output Parameters<a class="headerlink" href="#input-parameters-and-output-parameters" title="Permalink to this headline">¶</a></h4>
<p>和Javascript一样，函数可以将参数作为输入;与Javascript和C不同，它们也可以返回任意数量的参数作为输出。</p>
<div class="section" id="input-parameters">
<h5>Input Parameters<a class="headerlink" href="#input-parameters" title="Permalink to this headline">¶</a></h5>
<p>输入参数的声明方式与变量相同。作为例外，未使用的参数可以省略变量名。例如，假设我们想让我们的合约接受一种带有两个整数的外部调用，我们可以这样写:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Simple</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">taker</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_a</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">_b</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="p">{</span>
        <span class="c1">// do something with _a and _b.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="output-parameters">
<h5>Output Parameters<a class="headerlink" href="#output-parameters" title="Permalink to this headline">¶</a></h5>
<p>输出参数可以在转换关键字之后用相同的语法声明。例如，假设我们希望返回两个结果:两个给定整数的和和乘积，然后我们将写:<code class="docutils literal"><span class="pre">returns</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Simple</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">arithmetics</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_a</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">_b</span><span class="p">)</span>
        <span class="k">public</span>
        <span class="k">pure</span>
        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">o_sum</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">o_product</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">o_sum</span> <span class="o">=</span> <span class="nx">_a</span> <span class="o">+</span> <span class="nx">_b</span><span class="p">;</span>
        <span class="nx">o_product</span> <span class="o">=</span> <span class="nx">_a</span> <span class="o">*</span> <span class="nx">_b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>可以省略输出参数的名称。还可以使用return语句指定输出值。返回语句还可以返回多个值，请参见返回多个值。返回参数初始化为零;如果它们不是明确的集合，它们就会保持为零。<code class="docutils literal"><span class="pre">return</span></code><code class="docutils literal"><span class="pre">return</span></code><a class="reference internal" href="#multi-return"><span class="std std-ref">Returning Multiple Values</span></a></p>
<p>输入参数和输出参数可以作为函数体中的表达式。在这里，它们也可以在左边的作业中使用。</p>
</div>
</div>
<div class="section" id="control-structures">
<span id="index-1"></span><h4>Control Structures<a class="headerlink" href="#control-structures" title="Permalink to this headline">¶</a></h4>
<p>除了开关和goto外，JavaScript的大部分控制结构都是可用的。例如:if, else, while, do, for, break, continue, return， ?:用C或JavaScript所知道的常用语义。<code class="docutils literal"><span class="pre">switch</span></code><code class="docutils literal"><span class="pre">goto</span></code><code class="docutils literal"><span class="pre">if</span></code><code class="docutils literal"><span class="pre">else</span></code><code class="docutils literal"><span class="pre">while</span></code><code class="docutils literal"><span class="pre">do</span></code><code class="docutils literal"><span class="pre">for</span></code><code class="docutils literal"><span class="pre">break</span></code><code class="docutils literal"><span class="pre">continue</span></code><code class="docutils literal"><span class="pre">return</span></code><code class="docutils literal"><span class="pre">?</span> <span class="pre">:</span></code></p>
<p>在条件语句中不能省略括号，但是可以在单语句体周围执行卷曲的分支。<em>not</em></p>
<p>注意，在C和JavaScript中，没有从非布尔到布尔类型的类型转换，所以如果(1){…不validSolidity }。<code class="docutils literal"><span class="pre">if</span> <span class="pre">(1)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code><em>not</em></p>
<div class="section" id="returning-multiple-values">
<span id="multi-return"></span><h5>Returning Multiple Values<a class="headerlink" href="#returning-multiple-values" title="Permalink to this headline">¶</a></h5>
<p>当一个函数有多个输出参数时，返回(v0, v1，…，vn)可以返回多个值。组件的数量必须与输出参数的数量相同。<code class="docutils literal"><span class="pre">return</span> <span class="pre">(v0,</span> <span class="pre">v1,</span> <span class="pre">...,</span>
<span class="pre">vn)</span></code></p>
</div>
</div>
<div class="section" id="function-calls">
<span id="index-2"></span><span id="id1"></span><h4>Function Calls<a class="headerlink" href="#function-calls" title="Permalink to this headline">¶</a></h4>
<div class="section" id="internal-function-calls">
<h5>Internal Function Calls<a class="headerlink" href="#internal-function-calls" title="Permalink to this headline">¶</a></h5>
<p>当前合约的功能可以直接调用(“内部”)，也可以递归地调用，就像在这个荒谬的例子中所看到的那样:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">g</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">ret</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">f</span><span class="p">();</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">ret</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">g</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="o">+</span> <span class="nx">f</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这些函数调用被转换成EVM中的简单跳转。这就产生了当前内存不被清除的影响，也就是说，通过内存引用内部调用的函数是非常有效的。只能在内部调用samecontract的函数。</p>
</div>
<div class="section" id="external-function-calls">
<h5>External Function Calls<a class="headerlink" href="#external-function-calls" title="Permalink to this headline">¶</a></h5>
<p>表情this.g(8);和c.g(2);(c是contractinstance)也是有效的函数调用，但是这次，函数将被称为“外部”，通过消息调用而不是直接通过跳转。请注意，在构造函数中不能使用函数调用，因为实际的合约还没有创建。<code class="docutils literal"><span class="pre">this.g(8);</span></code><code class="docutils literal"><span class="pre">c.g(2);</span></code><code class="docutils literal"><span class="pre">c</span></code><code class="docutils literal"><span class="pre">this</span></code></p>
<p>其他合约的功能必须对外调用。对于外部调用，所有函数参数都必须复制到内存中。</p>
<p>当调用其他合约的功能时，可以用特殊的选项。value()和。gas()分别指定给该调用的Wei和gas()。<code class="docutils literal"><span class="pre">.value()</span></code><code class="docutils literal"><span class="pre">.gas()</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">InfoFeed</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">info</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">ret</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Consumer</span> <span class="p">{</span>
    <span class="nx">InfoFeed</span> <span class="nx">feed</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">setFeed</span><span class="p">(</span><span class="kt">address</span> <span class="nx">addr</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">feed</span> <span class="o">=</span> <span class="nx">InfoFeed</span><span class="p">(</span><span class="nx">addr</span><span class="p">);</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">callFeed</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">feed</span><span class="p">.</span><span class="nx">info</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="mi">10</span><span class="p">).</span><span class="nx">gas</span><span class="p">(</span><span class="mi">800</span><span class="p">)();</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>应使用的修饰符必须用于信息，否则，.value()选项将不可用。<code class="docutils literal"><span class="pre">payable</span></code><code class="docutils literal"><span class="pre">info</span></code><cite>.value()</cite></p>
<p>注意，表达式InfoFeed(addr)执行了显式类型转换，“我们知道在给定地址的合约类型是InfoFeed”，而这并没有执行构造函数。显式类型转换必须极其谨慎地处理。不要在你不确定合约类型的合约上打电话。<code class="docutils literal"><span class="pre">InfoFeed(addr)</span></code><code class="docutils literal"><span class="pre">InfoFeed</span></code></p>
<p>我们还可以使用函数setFeed(InfoFeed _feed) {feed = _feed;直接}。要注意的是，feed.info.value(10).gas(800)只(本地)设置了用函数调用发送的气体的值和数量，并且只有最后的括号执行实际调用。<code class="docutils literal"><span class="pre">function</span> <span class="pre">setFeed(InfoFeed</span> <span class="pre">_feed)</span> <span class="pre">{</span> <span class="pre">feed</span> <span class="pre">=</span> <span class="pre">_feed;</span> <span class="pre">}</span></code><code class="docutils literal"><span class="pre">feed.info.value(10).gas(800)</span></code></p>
<p>如果被调用的合约不存在，则函数调用会导致异常(在该帐户不包含代码的情况下)，或者如果被调用的合约本身抛出异常或耗尽气体。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">任何与其他合约的相互作用都会带来潜在的危险，特别是如果合约的源代码事先不知道的话。目前的合约将控制权移交给被称为合约，这可能在任何事情上都有可能。即使被称为合约继承了已知的父合约，继承合约只需要有一个正确的接口。然而，合约的执行可以是完全任意的，从而构成危险。此外，要做好准备，以防它在第一次调用返回之前调用系统的其他合约，甚至返回到调用合约。这意味着，所谓的合约可以通过其功能改变调用合约的状态变量。以一种方式来编写您的函数，例如，在您的合约中对状态变量进行任何更改之后，调用toexternal函数，这样您的合约就不会受到重入性攻击的影响。</p>
</div>
</div>
<div class="section" id="named-calls-and-anonymous-function-parameters">
<h5>Named Calls and Anonymous Function Parameters<a class="headerlink" href="#named-calls-and-anonymous-function-parameters" title="Permalink to this headline">¶</a></h5>
<p>函数调用参数也可以以名称、任何顺序、如果它们被包含在{}中，可以在下面的示例中看到。参数列表必须与函数声明中的参数列表一致，但可以是任意顺序的。<code class="docutils literal"><span class="pre">{</span> <span class="pre">}</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">key</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">g</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// named arguments</span>
        <span class="nx">f</span><span class="p">({</span><span class="nx">value</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nx">key</span><span class="o">:</span> <span class="mi">3</span><span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="omitted-function-parameter-names">
<h5>Omitted Function Parameter Names<a class="headerlink" href="#omitted-function-parameter-names" title="Permalink to this headline">¶</a></h5>
<p>未使用参数的名称(特别是返回参数)可以省略。这些参数仍然存在于堆栈中，但它们是不可访问的。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="c1">// omitted name for parameter</span>
    <span class="kd">function</span> <span class="nx">func</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">k</span><span class="p">,</span> <span class="kt">uint</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">k</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="creating-contracts-via-new">
<span id="creating-contracts"></span><span id="index-3"></span><h4>Creating Contracts via <code class="docutils literal"><span class="pre">new</span></code><a class="headerlink" href="#creating-contracts-via-new" title="Permalink to this headline">¶</a></h4>
<p>合约可以使用新关键字创建新合约。正在创建的合约的完整代码必须提前知道，因此不可能出现递归依赖关系。<code class="docutils literal"><span class="pre">new</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">D</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="nx">x</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">D</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">)</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="nx">D</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">D</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span> <span class="c1">// will be executed as part of C's constructor</span>

    <span class="kd">function</span> <span class="nx">createD</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">arg</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">D</span> <span class="nx">newD</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">D</span><span class="p">(</span><span class="nx">arg</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">createAndEndowD</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">arg</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">amount</span><span class="p">)</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="c1">// Send ether along with the creation</span>
        <span class="nx">D</span> <span class="nx">newD</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nx">D</span><span class="p">).</span><span class="nx">value</span><span class="p">(</span><span class="nx">amount</span><span class="p">)(</span><span class="nx">arg</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>正如在示例中所看到的，在使用.value()选项创建一个D实例时，可以向前推进以太，但是不可能限制气体的数量。如果创建失败(由于堆栈溢出，没有足够的平衡或其他问题)，抛出异常。<code class="docutils literal"><span class="pre">D</span></code><code class="docutils literal"><span class="pre">.value()</span></code></p>
</div>
<div class="section" id="order-of-evaluation-of-expressions">
<h4>Order of Evaluation of Expressions<a class="headerlink" href="#order-of-evaluation-of-expressions" title="Permalink to this headline">¶</a></h4>
<p>表达式的评估顺序没有指定(更正式地说，表达式树中一个节点的子节点被计算的顺序没有指定，但是它们当然是在节点本身之前进行评估的)。只有保证语句是按顺序执行的，并完成了布尔表达式的短路。有关更多信息，请参见操作符优先顺序。<a class="reference internal" href="index.html#order"><span class="std std-ref">Order of Precedence of Operators</span></a></p>
</div>
<div class="section" id="assignment">
<span id="index-4"></span><h4>Assignment<a class="headerlink" href="#assignment" title="Permalink to this headline">¶</a></h4>
<div class="section" id="destructuring-assignments-and-returning-multiple-values">
<span id="index-5"></span><h5>Destructuring Assignments and Returning Multiple Values<a class="headerlink" href="#destructuring-assignments-and-returning-multiple-values" title="Permalink to this headline">¶</a></h5>
<p>在内部，Solidity允许tuple类型，即在编译时大小为常量的潜在不同类型的对象列表。这些元组可以同时返回多个值，同时也可以将它们分配给多个变量(或一般的LValues):</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="nx">data</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">g</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// Variables declared with type</span>
        <span class="kt">uint</span> <span class="nx">x</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nx">b</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="nx">y</span><span class="p">;</span>
        <span class="c1">// Tuple values can be assigned to these pre-existing variables</span>
        <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span>
        <span class="c1">// Common trick to swap values -- does not work for non-value storage types.</span>
        <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span>
        <span class="c1">// Components can be left out (also for variable declarations).</span>
        <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">,,)</span> <span class="o">=</span> <span class="nx">f</span><span class="p">();</span> <span class="c1">// Sets the length to 7</span>
        <span class="c1">// Components can only be left out at the left-hand-side of assignments, with</span>
        <span class="c1">// one exception:</span>
        <span class="p">(</span><span class="nx">x</span><span class="p">,)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,);</span>
        <span class="c1">// (1,) is the only way to specify a 1-component tuple, because (1) is</span>
        <span class="c1">// equivalent to 1.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在版本0.4.24之前，可以分配较小的元组，在左边或右边填充(以前是空的)。现在不赞成，双方必须拥有相同数量的组件。</p>
</div>
</div>
<div class="section" id="complications-for-arrays-and-structs">
<h5>Complications for Arrays and Structs<a class="headerlink" href="#complications-for-arrays-and-structs" title="Permalink to this headline">¶</a></h5>
<p>赋值的语义对于数组和结构等非值类型来说比较复杂。给状态变量赋值总是创建一个独立的副本。另一方面，给局部变量赋值只会为基本类型创建一个独立的副本，即适合32个字节的静态类型。如果将结构或数组(包括字节和字符串)从状态变量分配给局部变量，则本地变量保存对原始状态变量的引用。对局部变量的第二个赋值不会修改状态，但只改变引用。对本地变量的成员(或元素)的赋值确实会改变状态。<em>to</em><code class="docutils literal"><span class="pre">bytes</span></code><code class="docutils literal"><span class="pre">string</span></code><em>do</em></p>
</div>
</div>
<div class="section" id="scoping-and-declarations">
<span id="default-value"></span><span id="index-6"></span><h4>Scoping and Declarations<a class="headerlink" href="#scoping-and-declarations" title="Permalink to this headline">¶</a></h4>
<p>一个被声明的变量将有一个初始的默认值，它的字节表示都是零。变量的“默认值”是典型的“零状态”类型。例如，boolis的默认值是false。uint或int类型的默认值为0。对于静态大小的数组和bytes1到bytes32，每个单独元素将被初始化为对应于其类型的默认值。最后，对于动态大小的数组，bytesand string，默认值是一个空数组或字符串。<code class="docutils literal"><span class="pre">bool</span></code><code class="docutils literal"><span class="pre">false</span></code><code class="docutils literal"><span class="pre">uint</span></code><code class="docutils literal"><span class="pre">int</span></code><code class="docutils literal"><span class="pre">0</span></code><code class="docutils literal"><span class="pre">bytes1</span></code><code class="docutils literal"><span class="pre">bytes32</span></code><code class="docutils literal"><span class="pre">bytes</span></code><code class="docutils literal"><span class="pre">string</span></code></p>
<p>在函数内的任何地方声明的变量将在整个函数的范围内，无论它在何处声明(这将很快改变，见下文)。这是因为Solidity继承了JavaScript的范围规则。这与许多语言形成了对比，在这些语言中，变量只作用于被声明到语义块结束的地方。因此，下面的代码是非法的，导致编译器抛出错误，标识符已经声明:<em>entire function</em><code class="docutils literal"><span class="pre">Identifier</span> <span class="pre">already</span> <span class="pre">declared</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="c1">// This will not compile</span>

<span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">ScopingErrors</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">scoping</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="nx">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">uint</span> <span class="nx">same1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="nx">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">uint</span> <span class="nx">same1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// Illegal, second declaration of same1</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">minimalScoping</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="kt">uint</span> <span class="nx">same2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="p">{</span>
            <span class="kt">uint</span> <span class="nx">same2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// Illegal, second declaration of same2</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">forLoopScoping</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">same3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">same3</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">same3</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">same3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">same3</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">same3</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">// Illegal, second declaration of same3</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>除此之外，如果一个变量被声明，它将在函数的开始处被初始化到它的默认值。因此，下面的代码是合法的，尽管写得很糟糕:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// baz is implicitly initialized as 0</span>
        <span class="kt">uint</span> <span class="nx">bar</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">bar</span> <span class="o">+=</span> <span class="nx">baz</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">uint</span> <span class="nx">baz</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span><span class="c1">// never executes</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">bar</span><span class="p">;</span><span class="c1">// returns 5</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="scoping-starting-from-version-0-5-0">
<h5>Scoping starting from Version 0.5.0<a class="headerlink" href="#scoping-starting-from-version-0-5-0" title="Permalink to this headline">¶</a></h5>
<p>从0.5.0开始，Solidity将会改变到C99(以及许多其他语言)的更广泛的范围规则:变量在声明结束后可以从其声明中看到，直到一个{}块的结束。作为该规则的一个例外，在for循环的初始化部分中声明的变量只在for循环结束时才可见。<code class="docutils literal"><span class="pre">{</span> <span class="pre">}</span></code></p>
<p>在代码块之外声明的变量和其他项，例如函数、合约、用户定义类型等，都不会改变它们的范围。这意味着在声明和调用函数之前，您可以使用状态变量。</p>
<p>这些规则现在已经作为一个实验特性被引入了。</p>
<p>因此，下面的示例将在没有警告的情况下编译，这两个变量具有相同的名称，但不具有联合作用域。在非0.5.0模式中，它们具有相同的范围(函数最小范围)，因此它不会在那里编译。<code class="docutils literal"><span class="pre">minimalScoping</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="k">pragma</span> <span class="nx">experimental</span> <span class="s2">"v0.5.0"</span><span class="p">;</span>
<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">minimalScoping</span><span class="p">()</span> <span class="k">pure</span> <span class="k">public</span> <span class="p">{</span>
        <span class="p">{</span>
            <span class="kt">uint</span> <span class="nx">same2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="p">{</span>
            <span class="kt">uint</span> <span class="nx">same2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>作为C99范围规则的一个特殊示例，请注意，在接下来的步骤中，x的第一个赋值将实际分配外部变量，而不是内部变量。无论如何，您将得到一个关于被跟踪的外部变量的警告。<code class="docutils literal"><span class="pre">x</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="k">pragma</span> <span class="nx">experimental</span> <span class="s2">"v0.5.0"</span><span class="p">;</span>
<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">pure</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">{</span>
            <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// this will assign to the outer variable</span>
            <span class="kt">uint</span> <span class="nx">x</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// x has value 2</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="error-handling-assert-require-revert-and-exceptions">
<span id="index-7"></span><h4>Error handling: Assert, Require, Revert and Exceptions<a class="headerlink" href="#error-handling-assert-require-revert-and-exceptions" title="Permalink to this headline">¶</a></h4>
<p>Solidity使用状态反转异常来处理错误。这样的异常将撤销当前调用(及其所有子调用)中对状态所做的所有更改，并将错误标记给调用者。方便函数断言和要求可以用于检查条件并在条件未满足时抛出异常。assert函数只能用于测试内部错误，并检查不变量。需求函数应该被用来确保有效的条件，比如输入，或者合约状态变量，或者验证从调用到外部合约的返回值。如果使用得当，分析工具可以评估您的合约，以确定将达到失败断言的条件和函数调用。功能正常的代码永远不能达到失败的断言语句;如果发生这种情况，你的合约中有一个漏洞，你应该改正。<code class="docutils literal"><span class="pre">assert</span></code><code class="docutils literal"><span class="pre">require</span></code><code class="docutils literal"><span class="pre">assert</span></code><code class="docutils literal"><span class="pre">require</span></code><code class="docutils literal"><span class="pre">assert</span></code></p>
<p>还有另外两种触发异常的方法:恢复函数可以用来标记错误并对当前调用进行修改。可以提供包含关于错误的详细信息的字符串消息，该消息将返回给调用者。弃用的关键字抛出还可以用作恢复()的替代方法(但只有在没有错误消息的情况下)。<code class="docutils literal"><span class="pre">revert</span></code><code class="docutils literal"><span class="pre">throw</span></code><code class="docutils literal"><span class="pre">revert()</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在版本0.4.13中，throw关键字被弃用，并将在未来被逐步淘汰。<code class="docutils literal"><span class="pre">throw</span></code></p>
</div>
<p>当在子调用中发生异常时，它们会自动“冒泡”(即抛出异常)。这条规则的例外是sendand低级函数调用、委托和callcode——这些返回false在caseof中，而不是“冒泡”。<code class="docutils literal"><span class="pre">send</span></code><code class="docutils literal"><span class="pre">call</span></code><code class="docutils literal"><span class="pre">delegatecall</span></code><code class="docutils literal"><span class="pre">callcode</span></code><code class="docutils literal"><span class="pre">false</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">如果被调用的帐户不存在，作为EVM设计的一部分，那么低级调用、委托和callcode将返回成功。存在必须在调用之前进行检查。<code class="docutils literal"><span class="pre">call</span></code><code class="docutils literal"><span class="pre">delegatecall</span></code><code class="docutils literal"><span class="pre">callcode</span></code></p>
</div>
<p>捕捉异常是不可能的。</p>
<p>在下面的示例中，您可以看到如何使用需求来轻松检查输入的条件，以及如何使用assert来进行内部错误检查。注意，您可以选择性地为需要提供消息字符串，但不是为了断言。<code class="docutils literal"><span class="pre">require</span></code><code class="docutils literal"><span class="pre">assert</span></code><code class="docutils literal"><span class="pre">require</span></code><code class="docutils literal"><span class="pre">assert</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Sharer</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">sendHalf</span><span class="p">(</span><span class="kt">address</span> <span class="nx">addr</span><span class="p">)</span> <span class="k">public</span> <span class="k">payable</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">"Even value required."</span><span class="p">);</span>
        <span class="kt">uint</span> <span class="nx">balanceBeforeTransfer</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">;</span>
        <span class="nx">addr</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
        <span class="c1">// Since transfer throws an exception on failure and</span>
        <span class="c1">// cannot call back here, there should be no way for us to</span>
        <span class="c1">// still have half of the money.</span>
        <span class="nb">assert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">balance</span> <span class="o">==</span> <span class="nx">balanceBeforeTransfer</span> <span class="o">-</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在以下情况中生成了一个assert样式的异常:<code class="docutils literal"><span class="pre">assert</span></code></p>
<ol class="arabic simple">
<li>If you access an array at a too large or negative index (i.e. <code class="docutils literal"><span class="pre">x[i]</span></code> where <code class="docutils literal"><span class="pre">i</span> <span class="pre">&gt;=</span> <span class="pre">x.length</span></code> or <code class="docutils literal"><span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>).</li>
<li>If you access a fixed-length <code class="docutils literal"><span class="pre">bytesN</span></code> at a too large or negative index.</li>
<li>If you divide or modulo by zero (e.g. <code class="docutils literal"><span class="pre">5</span> <span class="pre">/</span> <span class="pre">0</span></code> or <code class="docutils literal"><span class="pre">23</span> <span class="pre">%</span> <span class="pre">0</span></code>).</li>
<li>If you shift by a negative amount.</li>
<li>If you convert a value too big or negative into an enum type.</li>
<li>If you call a zero-initialized variable of internal function type.</li>
<li>If you call <code class="docutils literal"><span class="pre">assert</span></code> with an argument that evaluates to false.</li>
</ol>
<p>在以下情况中生成了requirestyle异常:<code class="docutils literal"><span class="pre">require</span></code></p>
<ol class="arabic simple">
<li>Calling <code class="docutils literal"><span class="pre">throw</span></code>.</li>
<li>Calling <code class="docutils literal"><span class="pre">require</span></code> with an argument that evaluates to <code class="docutils literal"><span class="pre">false</span></code>.</li>
<li>If you call a function via a message call but it does not finish properly (i.e. it runs out of gas, has no matching function, or throws an exception itself), except when a low level operation <code class="docutils literal"><span class="pre">call</span></code>, <code class="docutils literal"><span class="pre">send</span></code>, <code class="docutils literal"><span class="pre">delegatecall</span></code> or <code class="docutils literal"><span class="pre">callcode</span></code> is used.  The low level operations never throw exceptions but indicate failures by returning <code class="docutils literal"><span class="pre">false</span></code>.</li>
<li>If you create a contract using the <code class="docutils literal"><span class="pre">new</span></code> keyword but the contract creation does not finish properly (see above for the definition of “not finish properly”).</li>
<li>If you perform an external function call targeting a contract that contains no code.</li>
<li>If your contract receives Ether via a public function without <code class="docutils literal"><span class="pre">payable</span></code> modifier (including the constructor and the fallback function).</li>
<li>If your contract receives Ether via a public getter function.</li>
<li>If a <code class="docutils literal"><span class="pre">.transfer()</span></code> fails.</li>
</ol>
<p>在内部，Solidity执行一个requirestyle异常的恢复操作(指令0xfd)，并执行一个无效的操作(指令0xfe)来抛出一个assert样式的异常。在这两种情况下，这将导致EVM恢复对状态的所有更改。恢复的原因是没有安全的方法继续执行，因为预期的效果没有发生。因为我们希望保留事务的原子性，最安全的做法是还原所有更改并使整个事务(或至少调用)没有影响。注意，assert风格的异常会消耗调用的所有气体，而whilerequirestyle异常将不会消耗从都市释放开始的任何气体。<code class="docutils literal"><span class="pre">0xfd</span></code><code class="docutils literal"><span class="pre">require</span></code><code class="docutils literal"><span class="pre">0xfe</span></code><code class="docutils literal"><span class="pre">assert</span></code><code class="docutils literal"><span class="pre">assert</span></code><code class="docutils literal"><span class="pre">require</span></code></p>
<p>下面的示例演示如何将错误字符串一起使用，并要求:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">VendingMachine</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">buy</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">amount</span><span class="p">)</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">amount</span> <span class="o">&gt;</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">/</span> <span class="mi">2</span> <span class="kt">ether</span><span class="p">)</span>
            <span class="nb">revert</span><span class="p">(</span><span class="s2">"Not enough Ether provided."</span><span class="p">);</span>
        <span class="c1">// Alternative way to do it:</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nx">amount</span> <span class="o">&lt;=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">/</span> <span class="mi">2</span> <span class="kt">ether</span><span class="p">,</span>
            <span class="s2">"Not enough Ether provided."</span>
        <span class="p">);</span>
        <span class="c1">// Perform the purchase.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>所提供的字符串将会被编码，就好像它是一个函数错误(字符串)的调用。在上面的例子中，还原(“没有提供足够的醚”);将导致下列十六进制数据被困扰为错误返回数据:<a class="reference internal" href="index.html#abi"><span class="std std-ref">abi-encoded</span></a><code class="docutils literal"><span class="pre">Error(string)</span></code><code class="docutils literal"><span class="pre">revert("Not</span> <span class="pre">enough</span> <span class="pre">Ether</span> <span class="pre">provided.");</span></code></p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="mh">0x08c379a0</span>                                                         <span class="c1">// Function selector for Error(string)</span>
<span class="mh">0x0000000000000000000000000000000000000000000000000000000000000020</span> <span class="c1">// Data offset</span>
<span class="mh">0x000000000000000000000000000000000000000000000000000000000000001a</span> <span class="c1">// String length</span>
<span class="mh">0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000</span> <span class="c1">// String data</span>
</pre></div>
</div>
</div>
</div>
<span id="document-contracts"></span><div class="section" id="contracts">
<span id="index-0"></span><h3>Contracts<a class="headerlink" href="#contracts" title="Permalink to this headline">¶</a></h3>
<p>Solidity中的合约类似于面向对象语言的类。它们包含状态变量和可以修改这些变量的函数的持久数据。在不同的合约(实例)上调用一个函数将performan EVM函数调用，从而切换上下文，使状态变量无法访问。</p>
<div class="section" id="creating-contracts">
<span id="index-1"></span><h4>Creating Contracts<a class="headerlink" href="#creating-contracts" title="Permalink to this headline">¶</a></h4>
<p>合约可以通过以太交易或从实体合约中创建“外部”。</p>
<p>ide，比如Remix，使用UI元素使创建过程无缝化。<a class="reference external" href="https://remix.ethereum.org/">Remix</a></p>
<p>通过使用JavaScript API web3.js，最好地在Ethereum上创建合约。到今天为止，它有一个名为web3.eth的方法。Contractto促进合约的创建。<a class="reference external" href="https://github.com/ethereum/web3.js">web3.js</a><a class="reference external" href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract">web3.eth.Contract</a></p>
<p>当一个合约被创建时，它的构造函数(一个用theconstructor关键字声明的函数)被执行一次。构造函数是可选的。只有一个构造函数是允许的，这意味着不支持这个意义上的加载。<code class="docutils literal"><span class="pre">constructor</span></code></p>
<p id="index-2">在内部，构造函数的参数通过ABI编码后经过编码，但如果使用web3.js，则不必关心这个问题。<a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI encoded</span></a><code class="docutils literal"><span class="pre">web3.js</span></code></p>
<p>如果一个合约想要创建另一个合约，那么创建的合约的源代码(和二进制)必须被创建者知道。这意味着循环创建依赖是不可能的。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">OwnedToken</span> <span class="p">{</span>
    <span class="c1">// TokenCreator is a contract type that is defined below.</span>
    <span class="c1">// It is fine to reference it as long as it is not used</span>
    <span class="c1">// to create a new contract.</span>
    <span class="nx">TokenCreator</span> <span class="nx">creator</span><span class="p">;</span>
    <span class="kt">address</span> <span class="nx">owner</span><span class="p">;</span>
    <span class="kt">bytes32</span> <span class="nx">name</span><span class="p">;</span>

    <span class="c1">// This is the constructor which registers the</span>
    <span class="c1">// creator and the assigned name.</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="kt">bytes32</span> <span class="nx">_name</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// State variables are accessed via their name</span>
        <span class="c1">// and not via e.g. this.owner. This also applies</span>
        <span class="c1">// to functions and especially in the constructors,</span>
        <span class="c1">// you can only call them like that ("internally"),</span>
        <span class="c1">// because the contract itself does not exist yet.</span>
        <span class="nx">owner</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
        <span class="c1">// We do an explicit type conversion from `address`</span>
        <span class="c1">// to `TokenCreator` and assume that the type of</span>
        <span class="c1">// the calling contract is TokenCreator, there is</span>
        <span class="c1">// no real way to check that.</span>
        <span class="nx">creator</span> <span class="o">=</span> <span class="nx">TokenCreator</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">);</span>
        <span class="nx">name</span> <span class="o">=</span> <span class="nx">_name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">changeName</span><span class="p">(</span><span class="kt">bytes32</span> <span class="nx">newName</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// Only the creator can alter the name --</span>
        <span class="c1">// the comparison is possible since contracts</span>
        <span class="c1">// are implicitly convertible to addresses.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="kt">address</span><span class="p">(</span><span class="nx">creator</span><span class="p">))</span>
            <span class="nx">name</span> <span class="o">=</span> <span class="nx">newName</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">transfer</span><span class="p">(</span><span class="kt">address</span> <span class="nx">newOwner</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// Only the current owner can transfer the token.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">owner</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
        <span class="c1">// We also want to ask the creator if the transfer</span>
        <span class="c1">// is fine. Note that this calls a function of the</span>
        <span class="c1">// contract defined below. If the call fails (e.g.</span>
        <span class="c1">// due to out-of-gas), the execution here stops</span>
        <span class="c1">// immediately.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">creator</span><span class="p">.</span><span class="nx">isTokenTransferOK</span><span class="p">(</span><span class="nx">owner</span><span class="p">,</span> <span class="nx">newOwner</span><span class="p">))</span>
            <span class="nx">owner</span> <span class="o">=</span> <span class="nx">newOwner</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">TokenCreator</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">createToken</span><span class="p">(</span><span class="kt">bytes32</span> <span class="nx">name</span><span class="p">)</span>
       <span class="k">public</span>
       <span class="k">returns</span> <span class="p">(</span><span class="nx">OwnedToken</span> <span class="nx">tokenAddress</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Create a new Token contract and return its address.</span>
        <span class="c1">// From the JavaScript side, the return type is simply</span>
        <span class="c1">// `address`, as this is the closest type available in</span>
        <span class="c1">// the ABI.</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">OwnedToken</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">changeName</span><span class="p">(</span><span class="nx">OwnedToken</span> <span class="nx">tokenAddress</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="nx">name</span><span class="p">)</span>  <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// Again, the external type of `tokenAddress` is</span>
        <span class="c1">// simply `address`.</span>
        <span class="nx">tokenAddress</span><span class="p">.</span><span class="nx">changeName</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">isTokenTransferOK</span><span class="p">(</span><span class="kt">address</span> <span class="nx">currentOwner</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">newOwner</span><span class="p">)</span>
        <span class="k">public</span>
        <span class="k">view</span>
        <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="nx">ok</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Check some arbitrary condition.</span>
        <span class="kt">address</span> <span class="nx">tokenAddress</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">keccak256</span><span class="p">(</span><span class="nx">newOwner</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">bytes20</span><span class="p">(</span><span class="nx">tokenAddress</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="visibility-and-getters">
<span id="index-3"></span><span id="id1"></span><h4>Visibility and Getters<a class="headerlink" href="#visibility-and-getters" title="Permalink to this headline">¶</a></h4>
<p>因为Solidity知道两种函数调用(即不创建实际的EVM调用的内部函数调用(也称为calleda“消息调用”)和外部函数调用(externalones))，函数和状态变量有四种类型。</p>
<p>函数可以指定为外部的、公共的、内部的或私有的，其中默认的ispublic。对于状态变量，外部是不可能的，默认是内部的。<code class="docutils literal"><span class="pre">external</span></code><code class="docutils literal"><span class="pre">public</span></code><code class="docutils literal"><span class="pre">internal</span></code><code class="docutils literal"><span class="pre">private</span></code><code class="docutils literal"><span class="pre">public</span></code><code class="docutils literal"><span class="pre">external</span></code><code class="docutils literal"><span class="pre">internal</span></code></p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">external</span></code>:</dt>
<dd>External functions are part of the contract
interface, which means they can be called from other contracts and
via transactions. An external function <code class="docutils literal"><span class="pre">f</span></code> cannot be called
internally (i.e. <code class="docutils literal"><span class="pre">f()</span></code> does not work, but <code class="docutils literal"><span class="pre">this.f()</span></code> works).
External functions are sometimes more efficient when
they receive large arrays of data.</dd>
<dt><code class="docutils literal"><span class="pre">public</span></code>:</dt>
<dd>Public functions are part of the contract
interface and can be either called internally or via
messages. For public state variables, an automatic getter
function (see below) is generated.</dd>
<dt><code class="docutils literal"><span class="pre">internal</span></code>:</dt>
<dd>Those functions and state variables can only be
accessed internally (i.e. from within the current contract
or contracts deriving from it), without using <code class="docutils literal"><span class="pre">this</span></code>.</dd>
<dt><code class="docutils literal"><span class="pre">private</span></code>:</dt>
<dd>Private functions and state variables are only
visible for the contract they are defined in and not in
derived contracts.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">合约里面的一切都是外部观察者可以看到的。使某些东西私有只会阻止其他合约访问和修改信息，但是在区块链之外的整个世界仍然是可见的。<code class="docutils literal"><span class="pre">private</span></code></p>
</div>
<p>在类型forstate变量和函数的参数列表和返回参数列表之间给出了可见性说明符。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">)</span> <span class="k">private</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">setData</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">)</span> <span class="k">internal</span> <span class="p">{</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在下面的示例中，D可以调用c.getData()来检索状态存储中数据的值，但是不能调用f. Contract E是从c派生出来的，因此可以调用compute。<code class="docutils literal"><span class="pre">D</span></code><code class="docutils literal"><span class="pre">c.getData()</span></code><code class="docutils literal"><span class="pre">data</span></code><code class="docutils literal"><span class="pre">f</span></code><code class="docutils literal"><span class="pre">E</span></code><code class="docutils literal"><span class="pre">C</span></code><code class="docutils literal"><span class="pre">compute</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="c1">// This will not compile</span>

<span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="k">private</span> <span class="nx">data</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">)</span> <span class="k">private</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">setData</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">a</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">getData</span><span class="p">()</span> <span class="k">public</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">data</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">compute</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">b</span><span class="p">)</span> <span class="k">internal</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">D</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">readData</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">C</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">();</span>
        <span class="kt">uint</span> <span class="nx">local</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">f</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span> <span class="c1">// error: member `f` is not visible</span>
        <span class="nx">c</span><span class="p">.</span><span class="nx">setData</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
        <span class="nx">local</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">getData</span><span class="p">();</span>
        <span class="nx">local</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">compute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// error: member `compute` is not visible</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">E</span> <span class="k">is</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">g</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">C</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">();</span>
        <span class="kt">uint</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">compute</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// access to internal member (from derived to parent contract)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="getter-functions">
<span id="index-4"></span><span id="id2"></span><h5>Getter Functions<a class="headerlink" href="#getter-functions" title="Permalink to this headline">¶</a></h5>
<p>编译器自动为所有公共状态变量创建getter函数。对于下面给出的合约，编译器将生成一个名为data的函数，该函数不接受任何参数，并返回一个uint，即statevariable数据的值。状态变量的初始化可以在声明中完成。<strong>public</strong><code class="docutils literal"><span class="pre">data</span></code><code class="docutils literal"><span class="pre">uint</span></code><code class="docutils literal"><span class="pre">data</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">data</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Caller</span> <span class="p">{</span>
    <span class="nx">C</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">();</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">local</span> <span class="o">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">data</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>getter函数具有外部可见性。如果在内部访问了这些元素(即没有这个)，则将其作为一个状态变量进行评估。如果是外部访问的(即用这个。)，它被评估为一个函数。<code class="docutils literal"><span class="pre">this.</span></code><code class="docutils literal"><span class="pre">this.</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">data</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">x</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">data</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// internal access</span>
        <span class="kt">uint</span> <span class="nx">val</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">();</span> <span class="c1">// external access</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下一个例子稍微复杂一点:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Complex</span> <span class="p">{</span>
    <span class="kd">struct</span> <span class="nx">Data</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">a</span><span class="p">;</span>
        <span class="kt">bytes3</span> <span class="nx">b</span><span class="p">;</span>
        <span class="k">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="nx">map</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">mapping</span> <span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="k">mapping</span><span class="p">(</span><span class="kt">bool</span> <span class="o">=&gt;</span> <span class="nx">Data</span><span class="p">[]))</span> <span class="k">public</span> <span class="nx">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>它将生成如下形式的函数:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">data</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">arg1</span><span class="p">,</span> <span class="kt">bool</span> <span class="nx">arg2</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">arg3</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">,</span> <span class="kt">bytes3</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">arg1</span><span class="p">][</span><span class="nx">arg2</span><span class="p">][</span><span class="nx">arg3</span><span class="p">].</span><span class="nx">a</span><span class="p">;</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">arg1</span><span class="p">][</span><span class="nx">arg2</span><span class="p">][</span><span class="nx">arg3</span><span class="p">].</span><span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意，结构中的映射被省略了，因为没有好方法提供映射的键。</p>
</div>
</div>
<div class="section" id="function-modifiers">
<span id="modifiers"></span><span id="index-5"></span><h4>Function Modifiers<a class="headerlink" href="#function-modifiers" title="Permalink to this headline">¶</a></h4>
<p>修饰符可以用来很容易地改变函数的行为。例如，它们可以在执行函数之前自动检查一个条件。修饰符是合约的可继承属性，可能被派生的合约覆盖。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">owned</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">owner</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">address</span> <span class="nx">owner</span><span class="p">;</span>

    <span class="c1">// This contract only defines a modifier but does not use</span>
    <span class="c1">// it: it will be used in derived contracts.</span>
    <span class="c1">// The function body is inserted where the special symbol</span>
    <span class="c1">// `_;` in the definition of a modifier appears.</span>
    <span class="c1">// This means that if the owner calls this function, the</span>
    <span class="c1">// function is executed and otherwise, an exception is</span>
    <span class="c1">// thrown.</span>
    <span class="kd">modifier</span> <span class="nx">onlyOwner</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">owner</span><span class="p">,</span>
            <span class="s2">"Only owner can call this function."</span>
        <span class="p">);</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">mortal</span> <span class="k">is</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="c1">// This contract inherits the `onlyOwner` modifier from</span>
    <span class="c1">// `owned` and applies it to the `close` function, which</span>
    <span class="c1">// causes that calls to `close` only have an effect if</span>
    <span class="c1">// they are made by the stored owner.</span>
    <span class="kd">function</span> <span class="nx">close</span><span class="p">()</span> <span class="k">public</span> <span class="nx">onlyOwner</span> <span class="p">{</span>
        <span class="nb">selfdestruct</span><span class="p">(</span><span class="nx">owner</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">priced</span> <span class="p">{</span>
    <span class="c1">// Modifiers can receive arguments:</span>
    <span class="kd">modifier</span> <span class="nx">costs</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">price</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;=</span> <span class="nx">price</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">_</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Register</span> <span class="k">is</span> <span class="nx">priced</span><span class="p">,</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="k">mapping</span> <span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">registeredAddresses</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="nx">price</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">Register</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">initialPrice</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">price</span> <span class="o">=</span> <span class="nx">initialPrice</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// It is important to also provide the</span>
    <span class="c1">// `payable` keyword here, otherwise the function will</span>
    <span class="c1">// automatically reject all Ether sent to it.</span>
    <span class="kd">function</span> <span class="nx">register</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="nx">costs</span><span class="p">(</span><span class="nx">price</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">registeredAddresses</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">changePrice</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_price</span><span class="p">)</span> <span class="k">public</span> <span class="nx">onlyOwner</span> <span class="p">{</span>
        <span class="nx">price</span> <span class="o">=</span> <span class="nx">_price</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Mutex</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="nx">locked</span><span class="p">;</span>
    <span class="kd">modifier</span> <span class="nx">noReentrancy</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="o">!</span><span class="nx">locked</span><span class="p">,</span>
            <span class="s2">"Reentrant call."</span>
        <span class="p">);</span>
        <span class="nx">locked</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">_</span><span class="p">;</span>
        <span class="nx">locked</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// This function is protected by a mutex, which means that</span>
    <span class="cs">/// reentrant calls from within `msg.sender.call` cannot call `f` again.</span>
    <span class="cs">/// The `return 7` statement assigns 7 to the return value but still</span>
    <span class="cs">/// executes the statement `locked = false` in the modifier.</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="nx">noReentrancy</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">call</span><span class="p">());</span>
        <span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>将多个修饰符应用于一个函数，指定它们在awhitespace分隔的列表中，并按照所呈现的顺序进行评估。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">在较早版本的Solidity中，功能修改器的返回语句的行为不同。<code class="docutils literal"><span class="pre">return</span></code></p>
</div>
<p>修饰符或函数体的显式返回只会离开当前修饰符或函数体。在前面的修饰符中“_”之后，返回变量被分配并继续控制流。</p>
<p>任意表达式允许修改参数，在此上下文中，所有从函数可见的符号都可以在修饰符中看到。在修改器中，Symbolsintroduced在函数中是不可见的(因为它们可能通过重写来改变)。</p>
</div>
<div class="section" id="constant-state-variables">
<span id="index-6"></span><h4>Constant State Variables<a class="headerlink" href="#constant-state-variables" title="Permalink to this headline">¶</a></h4>
<p>状态变量可以声明为常量。在这种情况下，它们必须从表达式中分配，表达式在编译时是常量。任何访问存储的表达式，区块链数据(例如，现在，这个。或执行数据(msg)。不允许使用价值或gasleft())或调用外部合约。可能对内存分配产生副作用的表达式是允许的，但是那些可能对其他内存对象产生副作用的则不允许。内置的functionskeccak256、sha256、ripemd160、ec、addmod和mulmodare允许(尽管它们确实调用外部合约)。<code class="docutils literal"><span class="pre">constant</span></code><code class="docutils literal"><span class="pre">now</span></code><code class="docutils literal"><span class="pre">this.balance</span></code><code class="docutils literal"><span class="pre">block.number</span></code><code class="docutils literal"><span class="pre">msg.value</span></code><code class="docutils literal"><span class="pre">gasleft()</span></code><code class="docutils literal"><span class="pre">keccak256</span></code><code class="docutils literal"><span class="pre">sha256</span></code><code class="docutils literal"><span class="pre">ripemd160</span></code><code class="docutils literal"><span class="pre">ecrecover</span></code><code class="docutils literal"><span class="pre">addmod</span></code><code class="docutils literal"><span class="pre">mulmod</span></code></p>
<p>允许对内存分配器产生副作用的原因是，它应该能够构造复杂的对象，例如:lookup-tables。这个功能还不能完全使用。</p>
<p>编译器不为这些变量保留一个存储槽，并且每一个事件都被各自的常量表达式替换(这可能由优化器计算为单个值)。</p>
<p>并不是所有类型的常量都在此时实现。唯一支持的类型是arevalue类型和字符串。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="k">constant</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">32</span><span class="o">**</span><span class="mi">22</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span>
    <span class="kt">string</span> <span class="k">constant</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">"abc"</span><span class="p">;</span>
    <span class="kt">bytes32</span> <span class="k">constant</span> <span class="nx">myHash</span> <span class="o">=</span> <span class="nb">keccak256</span><span class="p">(</span><span class="s2">"abc"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="functions">
<span id="index-7"></span><span id="id3"></span><h4>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h4>
<div class="section" id="view-functions">
<span id="index-8"></span><span id="id4"></span><h5>View Functions<a class="headerlink" href="#view-functions" title="Permalink to this headline">¶</a></h5>
<p>函数可以声明视图，在这种情况下，它们保证不修改状态。<code class="docutils literal"><span class="pre">view</span></code></p>
<p>下列声明被认为是修改国家:</p>
<ol class="arabic simple">
<li>Writing to state variables.</li>
<li><a class="reference internal" href="#events"><span class="std std-ref">Emitting events</span></a>.</li>
<li><a class="reference internal" href="index.html#creating-contracts"><span class="std std-ref">Creating other contracts</span></a>.</li>
<li>Using <code class="docutils literal"><span class="pre">selfdestruct</span></code>.</li>
<li>Sending Ether via calls.</li>
<li>Calling any function not marked <code class="docutils literal"><span class="pre">view</span></code> or <code class="docutils literal"><span class="pre">pure</span></code>.</li>
<li>Using low-level calls.</li>
<li>Using inline assembly that contains certain opcodes.</li>
</ol>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">b</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="p">(</span><span class="nx">b</span> <span class="o">+</span> <span class="mi">42</span><span class="p">)</span> <span class="o">+</span> <span class="nb">now</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">constant</span></code>函数的常量是视图的别名，但这是不赞成的，将在版本0.5.0中删除。<code class="docutils literal"><span class="pre">view</span></code></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Getter方法被标记为视图。<code class="docutils literal"><span class="pre">view</span></code></p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">如果使用了无效的显式类型转换，即使调用了视图函数，也可能进行状态修改。当调用这些函数时，您可以切换编译器来使用STATICCALL，并通过addingpragma实验“v0.5.0”来防止修改到EVM级别上的状态;<code class="docutils literal"><span class="pre">view</span></code><code class="docutils literal"><span class="pre">STATICCALL</span></code><code class="docutils literal"><span class="pre">pragma</span> <span class="pre">experimental</span> <span class="pre">"v0.5.0";</span></code></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">编译器没有强制执行视图方法不修改状态。不过，它提出了一个警告。<code class="docutils literal"><span class="pre">view</span></code></p>
</div>
</div>
<div class="section" id="pure-functions">
<span id="index-9"></span><span id="id5"></span><h5>Pure Functions<a class="headerlink" href="#pure-functions" title="Permalink to this headline">¶</a></h5>
<p>函数可以声明为纯的，在这种情况下，它们保证不读取或修改状态。<code class="docutils literal"><span class="pre">pure</span></code></p>
<p>除上述国家修改说明的清单外，还考虑从国家阅读:</p>
<ol class="arabic simple">
<li>Reading from state variables.</li>
<li>Accessing <code class="docutils literal"><span class="pre">this.balance</span></code> or <code class="docutils literal"><span class="pre">&lt;address&gt;.balance</span></code>.</li>
<li>Accessing any of the members of <code class="docutils literal"><span class="pre">block</span></code>, <code class="docutils literal"><span class="pre">tx</span></code>, <code class="docutils literal"><span class="pre">msg</span></code> (with the exception of <code class="docutils literal"><span class="pre">msg.sig</span></code> and <code class="docutils literal"><span class="pre">msg.data</span></code>).</li>
<li>Calling any function not marked <code class="docutils literal"><span class="pre">pure</span></code>.</li>
<li>Using inline assembly that contains certain opcodes.</li>
</ol>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">b</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span> <span class="o">*</span> <span class="p">(</span><span class="nx">b</span> <span class="o">+</span> <span class="mi">42</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">如果使用了无效的显式类型转换，即使调用了一个纯函数，也可能进行状态修改。当调用这些函数时，您可以切换编译器来使用STATICCALL，并通过addingpragma实验“v0.5.0”来防止修改到EVM级别上的状态;<code class="docutils literal"><span class="pre">pure</span></code><code class="docutils literal"><span class="pre">STATICCALL</span></code><code class="docutils literal"><span class="pre">pragma</span> <span class="pre">experimental</span> <span class="pre">"v0.5.0";</span></code></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">在EVM的水平上，不可能阻止函数读取状态，只有这样才能防止它们写入状态(即:只有视图可以在EVM级别执行，纯不能)。<code class="docutils literal"><span class="pre">view</span></code><code class="docutils literal"><span class="pre">pure</span></code></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">在版本0.4.17之前，编译器并没有强制执行，即不读取状态。<code class="docutils literal"><span class="pre">pure</span></code></p>
</div>
</div>
<div class="section" id="fallback-function">
<span id="index-10"></span><span id="id6"></span><h5>Fallback Function<a class="headerlink" href="#fallback-function" title="Permalink to this headline">¶</a></h5>
<p>一个合约可以有一个未命名的函数。这个函数不能有任何报酬，不能返回任何东西。如果其他函数没有与给定的函数标识符匹配(或者如果没有提供任何数据)，它将在对合约的调用中执行。</p>
<p>此外，无论何时该合约接收到明文(没有数据)，该函数都会执行。此外，为了接收乙醚，必须标明备用功能。如果不存在这样的功能，合约就不能通过常规交易接收。<code class="docutils literal"><span class="pre">payable</span></code></p>
<p>在最坏的情况下，回退函数只能依赖于2300个可用的气体(例如，在使用发送或传输时)，除了基本日志记录之外，没有太多空间执行其他操作。以下操作将消耗超过2300气量的天然气:</p>
<ul class="simple">
<li>Writing to storage</li>
<li>Creating a contract</li>
<li>Calling an external function which consumes a large amount of gas</li>
<li>Sending Ether</li>
</ul>
<p>和任何函数一样，只要有足够的气体，回退函数就可以执行复杂的操作。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">虽然回退函数不能有参数，但仍然可以使用msg。获取随调用提供的任何有效负载的数据。<code class="docutils literal"><span class="pre">msg.data</span></code></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">直接接收以太的合约(不使用函数调用，即使用发送或传输)，但不定义回退功能抛出异常，返回以太(这在Solidity v0.4.0之前是不同的)。所以如果你想让你的合约得到以太，你必须实现一个回退函数。<code class="docutils literal"><span class="pre">send</span></code><code class="docutils literal"><span class="pre">transfer</span></code></p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>没有可支付的回退功能的合约可以作为一个coinbase交易的接收方(也就是矿块奖励)或自毁的目的地接收以太。<cite>coinbase transaction</cite><cite>miner block reward</cite><code class="docutils literal"><span class="pre">selfdestruct</span></code></p>
<p>合约不能对这样的以太传输作出反应，因此也不能拒绝它们。这是一个设计选择的EVM和固体不能围绕它工作。</p>
<p class="last">这也意味着。余额可以高于合约中执行的一些手工会计的总和(即在回退函数中有一个计数器)。<code class="docutils literal"><span class="pre">this.balance</span></code></p>
</div>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Test</span> <span class="p">{</span>
    <span class="c1">// This function is called for all messages sent to</span>
    <span class="c1">// this contract (there is no other function).</span>
    <span class="c1">// Sending Ether to this contract will cause an exception,</span>
    <span class="c1">// because the fallback function does not have the `payable`</span>
    <span class="c1">// modifier.</span>
    <span class="kd">function</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">uint</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// This contract keeps all Ether sent to it with no way</span>
<span class="c1">// to get it back.</span>
<span class="kd">contract</span> <span class="nx">Sink</span> <span class="p">{</span>
    <span class="kd">function</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Caller</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">callTest</span><span class="p">(</span><span class="nx">Test</span> <span class="nx">test</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">test</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="mh">0xabcdef01</span><span class="p">);</span> <span class="c1">// hash does not exist</span>
        <span class="c1">// results in test.x becoming == 1.</span>

        <span class="c1">// The following will not compile, but even</span>
        <span class="c1">// if someone sends ether to that contract,</span>
        <span class="c1">// the transaction will fail and reject the</span>
        <span class="c1">// Ether.</span>
        <span class="c1">//test.send(2 ether);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-overloading">
<span id="overload-function"></span><span id="index-11"></span><h5>Function Overloading<a class="headerlink" href="#function-overloading" title="Permalink to this headline">¶</a></h5>
<p>合约可以具有相同名称的多个函数，但可以使用不同的参数。这也适用于继承函数。下面的示例显示了在合约A范围内的f函数的重载。<code class="docutils literal"><span class="pre">f</span></code><code class="docutils literal"><span class="pre">A</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_in</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_in</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="nx">_key</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">out</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>重载的函数也存在于外部接口中。这是一个错误，如果两个外部可见的函数不同于它们的固体类型，而不是它们的外部类型。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="c1">// This will not compile</span>
<span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">B</span> <span class="nx">_in</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="nx">B</span> <span class="nx">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">out</span> <span class="o">=</span> <span class="nx">_in</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">address</span> <span class="nx">_in</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span> <span class="nx">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">out</span> <span class="o">=</span> <span class="nx">_in</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">B</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以上两个函数重载都接受了ABI的地址类型，尽管它们在内部是不同的。<code class="docutils literal"><span class="pre">f</span></code></p>
<div class="section" id="overload-resolution-and-argument-matching">
<h6>Overload resolution and Argument matching<a class="headerlink" href="#overload-resolution-and-argument-matching" title="Permalink to this headline">¶</a></h6>
<p>通过匹配函数调用中提供的参数的当前范围内的函数声明来选择重载函数。如果所有参数都可以隐式地转换为预期的类型，则选择函数作为重载候选对象。如果没有确切的日期，决议就会失败。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">返回参数没有考虑到重载解析。</p>
</div>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint8</span> <span class="nx">_in</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint8</span> <span class="nx">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">out</span> <span class="o">=</span> <span class="nx">_in</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint256</span> <span class="nx">_in</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint256</span> <span class="nx">out</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">out</span> <span class="o">=</span> <span class="nx">_in</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>调用f(50)会创建一个类型错误，因为50可以隐式地转换为uint8和uint256类型。另一方面，f(256)将解析为f(uint256)重载，因为256不能被隐含地转换为uint8。<code class="docutils literal"><span class="pre">f(50)</span></code><code class="docutils literal"><span class="pre">50</span></code><code class="docutils literal"><span class="pre">uint8</span></code><code class="docutils literal"><span class="pre">uint256</span></code><code class="docutils literal"><span class="pre">f(256)</span></code><code class="docutils literal"><span class="pre">f(uint256)</span></code><code class="docutils literal"><span class="pre">256</span></code><code class="docutils literal"><span class="pre">uint8</span></code></p>
</div>
</div>
</div>
<div class="section" id="events">
<span id="index-12"></span><span id="id7"></span><h4>Events<a class="headerlink" href="#events" title="Permalink to this headline">¶</a></h4>
<p>事件可以方便地使用EVM日志记录设备，而这反过来又可以用来“调用”dapp用户界面中的JavaScript回调，该应用程序监听这些事件。</p>
<p>事件是可继承的合约成员。当它们被调用时，它们会导致将参数存储在事务的日志中——一个特殊的数据结构在区块链中。这些日志与合约的地址相关联，并将被合并到区块链中，只要一个区块是可访问的(永远是边界和宅基地，但这可能会随着宁静而改变)。从内部合约(甚至不包括创建它们的合约)中无法访问日志的andevent数据。</p>
<p>对于日志的SPV证明是可能的，因此，如果一个外部实体提供了这样一个证明，它可以检查在区块链中是否存在日志。但是请注意，由于合约只能看到最后的256块散列，所以必须提供块标题。</p>
<p>最多有三个参数可以接收被索引的属性，这样就可以搜索相应的参数:可以在用户界面中过滤特定的值。<code class="docutils literal"><span class="pre">indexed</span></code></p>
<p>如果数组(包括字符串和字节)被用作索引参数，那么它的keccak -256散列将作为主题存储。<code class="docutils literal"><span class="pre">string</span></code><code class="docutils literal"><span class="pre">bytes</span></code></p>
<p>事件签名的散列是一个主题，但如果您使用匿名指示符声明该事件。这意味着不可能通过名称过滤特定的匿名事件。<code class="docutils literal"><span class="pre">anonymous</span></code></p>
<p>所有非索引的参数将存储在日志的数据部分中。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">索引参数本身不会存储。您只能搜索值，但是不可能自己检索值。</p>
</div>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">ClientReceipt</span> <span class="p">{</span>
    <span class="kd">event</span> <span class="nx">Deposit</span><span class="p">(</span>
        <span class="kt">address</span> <span class="k">indexed</span> <span class="nx">_from</span><span class="p">,</span>
        <span class="kt">bytes32</span> <span class="k">indexed</span> <span class="nx">_id</span><span class="p">,</span>
        <span class="kt">uint</span> <span class="nx">_value</span>
    <span class="p">);</span>

    <span class="kd">function</span> <span class="nx">deposit</span><span class="p">(</span><span class="kt">bytes32</span> <span class="nx">_id</span><span class="p">)</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="c1">// Events are emitted using `emit`, followed by</span>
        <span class="c1">// the name of the event and the arguments</span>
        <span class="c1">// (if any) in parentheses. Any such invocation</span>
        <span class="c1">// (even deeply nested) can be detected from</span>
        <span class="c1">// the JavaScript API by filtering for `Deposit`.</span>
        <span class="nx">emit</span> <span class="nx">Deposit</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">,</span> <span class="nx">_id</span><span class="p">,</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>JavaScript API的使用如下:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">abi</span> <span class="o">=</span> <span class="cm">/* abi as generated by the compiler */</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">ClientReceipt</span> <span class="o">=</span> <span class="nx">web3</span><span class="p">.</span><span class="nx">eth</span><span class="p">.</span><span class="kd">contract</span><span class="p">(</span><span class="nx">abi</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">clientReceipt</span> <span class="o">=</span> <span class="nx">ClientReceipt</span><span class="p">.</span><span class="nx">at</span><span class="p">(</span><span class="s2">"0x1234...ab67"</span> <span class="cm">/* address */</span><span class="p">);</span>

<span class="kd">var</span> <span class="kd">event</span> <span class="o">=</span> <span class="nx">clientReceipt</span><span class="p">.</span><span class="nx">Deposit</span><span class="p">();</span>

<span class="c1">// watch for changes</span>
<span class="kd">event</span><span class="p">.</span><span class="nx">watch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">result</span><span class="p">){</span>
    <span class="c1">// result will contain various information</span>
    <span class="c1">// including the argumets given to the `Deposit`</span>
    <span class="c1">// call.</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">error</span><span class="p">)</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// Or pass a callback to start watching immediately</span>
<span class="kd">var</span> <span class="kd">event</span> <span class="o">=</span> <span class="nx">clientReceipt</span><span class="p">.</span><span class="nx">Deposit</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">error</span><span class="p">)</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<div class="section" id="low-level-interface-to-logs">
<span id="index-13"></span><h5>Low-Level Interface to Logs<a class="headerlink" href="#low-level-interface-to-logs" title="Permalink to this headline">¶</a></h5>
<p>还可以通过函数log0、log1、log2、log3和log4访问loggingmechanism的底层接口。logi使用bytes32类型的i + 1参数，其中的firstargument将被用于日志的数据部分和其他sas主题。上面的事件调用可以以相同的方式执行。<code class="docutils literal"><span class="pre">log0</span></code><code class="docutils literal"><span class="pre">log1</span></code><code class="docutils literal"><span class="pre">log2</span></code><code class="docutils literal"><span class="pre">log3</span></code><code class="docutils literal"><span class="pre">log4</span></code><code class="docutils literal"><span class="pre">logi</span></code><code class="docutils literal"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span></code><code class="docutils literal"><span class="pre">bytes32</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">10</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="kt">bytes32</span> <span class="nx">_id</span> <span class="o">=</span> <span class="mh">0x420042</span><span class="p">;</span>
        <span class="nb">log3</span><span class="p">(</span>
            <span class="kt">bytes32</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">),</span>
            <span class="kt">bytes32</span><span class="p">(</span><span class="mh">0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20</span><span class="p">),</span>
            <span class="kt">bytes32</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">),</span>
            <span class="nx">_id</span>
        <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果长十六进制数等于keccak256(“存款(地址，bytes32,uint256)”)，则该事件的签名。<code class="docutils literal"><span class="pre">keccak256("Deposit(address,bytes32,uint256)")</span></code></p>
</div>
<div class="section" id="additional-resources-for-understanding-events">
<h5>Additional Resources for Understanding Events<a class="headerlink" href="#additional-resources-for-understanding-events" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><a class="reference external" href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events">Javascript documentation</a></li>
<li><a class="reference external" href="https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol">Example usage of events</a></li>
<li><a class="reference external" href="https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js">How to access them in js</a></li>
</ul>
</div>
</div>
<div class="section" id="inheritance">
<span id="index-14"></span><h4>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this headline">¶</a></h4>
<p>通过复制代码包括多态性，Solidity支持多重继承。</p>
<p>所有的函数调用都是虚拟的，这意味着除了在显式给定的合约名称之外，调用最派生的函数。</p>
<p>当一个合约从多个合约继承时，在区块链上只创建一个singlecontract，并且从所有基础合约中复制的代码复制到已创建的合约中。</p>
<p>一般的继承系统是非常类似的toPython，特别是关于多重继承。<a class="reference external" href="https://docs.python.org/3/tutorial/classes.html#inheritance">Python’s</a></p>
<p>下面的示例给出了详细信息。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="p">{</span> <span class="nx">owner</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">address</span> <span class="nx">owner</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Use `is` to derive from another contract. Derived</span>
<span class="c1">// contracts can access all non-private members including</span>
<span class="c1">// internal functions and state variables. These cannot be</span>
<span class="c1">// accessed externally via `this`, though.</span>
<span class="kd">contract</span> <span class="nx">mortal</span> <span class="k">is</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">kill</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">owner</span><span class="p">)</span> <span class="nb">selfdestruct</span><span class="p">(</span><span class="nx">owner</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// These abstract contracts are only provided to make the</span>
<span class="c1">// interface known to the compiler. Note the function</span>
<span class="c1">// without body. If a contract does not implement all</span>
<span class="c1">// functions it can only be used as an interface.</span>
<span class="kd">contract</span> <span class="nx">Config</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">lookup</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">id</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span> <span class="nx">adr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">NameReg</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">register</span><span class="p">(</span><span class="kt">bytes32</span> <span class="nx">name</span><span class="p">)</span> <span class="k">public</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">unregister</span><span class="p">()</span> <span class="k">public</span><span class="p">;</span>
 <span class="p">}</span>

<span class="c1">// Multiple inheritance is possible. Note that `owned` is</span>
<span class="c1">// also a base class of `mortal`, yet there is only a single</span>
<span class="c1">// instance of `owned` (as for virtual inheritance in C++).</span>
<span class="kd">contract</span> <span class="nx">named</span> <span class="k">is</span> <span class="nx">owned</span><span class="p">,</span> <span class="nx">mortal</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="kt">bytes32</span> <span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">Config</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">Config</span><span class="p">(</span><span class="mh">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span><span class="p">);</span>
        <span class="nx">NameReg</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">lookup</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="nx">register</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Functions can be overridden by another function with the same name and</span>
    <span class="c1">// the same number/types of inputs.  If the overriding function has different</span>
    <span class="c1">// types of output parameters, that causes an error.</span>
    <span class="c1">// Both local and message-based function calls take these overrides</span>
    <span class="c1">// into account.</span>
    <span class="kd">function</span> <span class="nx">kill</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">owner</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">Config</span> <span class="nx">config</span> <span class="o">=</span> <span class="nx">Config</span><span class="p">(</span><span class="mh">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span><span class="p">);</span>
            <span class="nx">NameReg</span><span class="p">(</span><span class="nx">config</span><span class="p">.</span><span class="nx">lookup</span><span class="p">(</span><span class="mi">1</span><span class="p">)).</span><span class="nx">unregister</span><span class="p">();</span>
            <span class="c1">// It is still possible to call a specific</span>
            <span class="c1">// overridden function.</span>
            <span class="nx">mortal</span><span class="p">.</span><span class="nx">kill</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// If a constructor takes an argument, it needs to be</span>
<span class="c1">// provided in the header (or modifier-invocation-style at</span>
<span class="c1">// the constructor of the derived contract (see below)).</span>
<span class="kd">contract</span> <span class="nx">PriceFeed</span> <span class="k">is</span> <span class="nx">owned</span><span class="p">,</span> <span class="nx">mortal</span><span class="p">,</span> <span class="nx">named</span><span class="p">(</span><span class="s2">"GoldFeed"</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">function</span> <span class="nx">updateInfo</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">newInfo</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">owner</span><span class="p">)</span> <span class="nx">info</span> <span class="o">=</span> <span class="nx">newInfo</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="kd">function</span> <span class="nx">get</span><span class="p">()</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">info</span><span class="p">;</span> <span class="p">}</span>

   <span class="kt">uint</span> <span class="nx">info</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意以上，我们调用mortal.kill()来“转发”销毁请求。这样做的方式是有问题的，如下面的例子所示:<code class="docutils literal"><span class="pre">mortal.kill()</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">owner</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">address</span> <span class="nx">owner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">mortal</span> <span class="k">is</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">kill</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">owner</span><span class="p">)</span> <span class="nb">selfdestruct</span><span class="p">(</span><span class="nx">owner</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Base1</span> <span class="k">is</span> <span class="nx">mortal</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">kill</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="cm">/* do cleanup 1 */</span> <span class="nx">mortal</span><span class="p">.</span><span class="nx">kill</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Base2</span> <span class="k">is</span> <span class="nx">mortal</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">kill</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="cm">/* do cleanup 2 */</span> <span class="nx">mortal</span><span class="p">.</span><span class="nx">kill</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Final</span> <span class="k">is</span> <span class="nx">Base1</span><span class="p">,</span> <span class="nx">Base2</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>调用fin. kill()将调用Base2。kill作为大多数派生的重写，但是这个函数将通过passbase1。kill，基本上是因为它甚至不知道base1。这里的方法是使用super:<code class="docutils literal"><span class="pre">Final.kill()</span></code><code class="docutils literal"><span class="pre">Base2.kill</span></code><code class="docutils literal"><span class="pre">Base1.kill</span></code><code class="docutils literal"><span class="pre">Base1</span></code><code class="docutils literal"><span class="pre">super</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">owner</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">address</span> <span class="nx">owner</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">mortal</span> <span class="k">is</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">kill</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">owner</span><span class="p">)</span> <span class="nb">selfdestruct</span><span class="p">(</span><span class="nx">owner</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Base1</span> <span class="k">is</span> <span class="nx">mortal</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">kill</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="cm">/* do cleanup 1 */</span> <span class="k">super</span><span class="p">.</span><span class="nx">kill</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>


<span class="kd">contract</span> <span class="nx">Base2</span> <span class="k">is</span> <span class="nx">mortal</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">kill</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="cm">/* do cleanup 2 */</span> <span class="k">super</span><span class="p">.</span><span class="nx">kill</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Final</span> <span class="k">is</span> <span class="nx">Base1</span><span class="p">,</span> <span class="nx">Base2</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果Base2调用super的函数，它不会简单地调用它的一个基础合约上的这个函数。更确切地说，它将这个函数调用在final图的下一个基础合约上，因此它将调用Base1.kill()(注意最后的继承顺序是-从最派生的合约开始:final, Base2, Base1, die，拥有)。在使用super时调用的实际函数，在使用它的类的上下文中是不知道的，尽管它的类型是已知的。这类似于普通的虚拟方法查找。<code class="docutils literal"><span class="pre">Base2</span></code><code class="docutils literal"><span class="pre">super</span></code><code class="docutils literal"><span class="pre">Base1.kill()</span></code></p>
<div class="section" id="constructors">
<span id="index-15"></span><h5>Constructors<a class="headerlink" href="#constructors" title="Permalink to this headline">¶</a></h5>
<p>构造函数是一个可选的函数，它使用构造函数关键字声明，该关键字是在合约创建时执行的。构造函数可以是公共的，也可以是内部的。如果没有构造函数，合约将假定默认构造函数:contructor()公共{}。<code class="docutils literal"><span class="pre">constructor</span></code><code class="docutils literal"><span class="pre">public</span></code><code class="docutils literal"><span class="pre">internal</span></code><code class="docutils literal"><span class="pre">contructor()</span> <span class="pre">public</span> <span class="pre">{}</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">a</span><span class="p">;</span>

    <span class="nx">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_a</span><span class="p">)</span> <span class="k">internal</span> <span class="p">{</span>
        <span class="nx">a</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">B</span> <span class="k">is</span> <span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">()</span> <span class="k">public</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>作为内部的构造函数，该合约被标记为抽象。<code class="docutils literal"><span class="pre">internal</span></code><a class="reference internal" href="#abstract-contract"><span class="std std-ref">abstract</span></a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在版本0.4.22之前，构造函数被定义为具有与合约相同名称的函数。该语法现在已被弃用。</p>
</div>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">a</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_a</span><span class="p">)</span> <span class="k">internal</span> <span class="p">{</span>
        <span class="nx">a</span> <span class="o">=</span> <span class="nx">_a</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">B</span> <span class="k">is</span> <span class="nx">A</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">B</span><span class="p">()</span> <span class="k">public</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="arguments-for-base-constructors">
<span id="index-16"></span><h5>Arguments for Base Constructors<a class="headerlink" href="#arguments-for-base-constructors" title="Permalink to this headline">¶</a></h5>
<p>所有基础合约的构造函数将被调用，遵循下面的解释规则。如果基本构造函数有参数，则派生合约需要指定所有这些参数。这可以通过以下两种方式实现:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Base</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="nx">x</span><span class="p">;</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_x</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">_x</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Derived1</span> <span class="k">is</span> <span class="nx">Base</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_y</span><span class="p">)</span> <span class="k">public</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Derived2</span> <span class="k">is</span> <span class="nx">Base</span> <span class="p">{</span>
    <span class="nx">constructor</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_y</span><span class="p">)</span> <span class="nx">Base</span><span class="p">(</span><span class="nx">_y</span> <span class="o">*</span> <span class="nx">_y</span><span class="p">)</span> <span class="k">public</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>一种方法是直接在继承列表中(是Base(7))。另一个是作为派生构造函数(Base(_y * _y))头的一部分调用修饰符。第一个方法是，如果构造函数参数是一个常量，并且定义了合约的行为或描述它，那么就更方便了。第二种方法必须使用，如果基础的结构参数依赖于派生合约的参数。参数必须在继承列表中或在派生的constuctor中以modifier风格给出。在两个地方指定参数都是错误的。<code class="docutils literal"><span class="pre">is</span> <span class="pre">Base(7)</span></code><code class="docutils literal"><span class="pre">Base(_y</span> <span class="pre">*</span> <span class="pre">_y)</span></code></p>
<p>如果一个派生的合约没有将参数指定给它所有的baseconource的构造函数，那么它将是抽象的。</p>
</div>
<div class="section" id="multiple-inheritance-and-linearization">
<span id="index-17"></span><h5>Multiple Inheritance and Linearization<a class="headerlink" href="#multiple-inheritance-and-linearization" title="Permalink to this headline">¶</a></h5>
<p>允许多重继承的语言必须处理几个问题。一个是钻石问题。Solidity类似于Python，因为它使用“C3线性化”来强制DAG中的基类的特定顺序。这就导致了单调性的理想性质，但不允许某些继承图。特别是，基类在is指令中给出的顺序是:您必须将命令的直接基础合约从“最基本的”到“最派生的”。注意，这个顺序与Python中使用的顺序不同。在下面的代码中，Solidity将会给出错误的“继承图的线性化”。<a class="reference external" href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">Diamond Problem</a><a class="reference external" href="https://en.wikipedia.org/wiki/C3_linearization">C3 Linearization</a><code class="docutils literal"><span class="pre">is</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="c1">// This will not compile</span>

<span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">X</span> <span class="p">{}</span>
<span class="kd">contract</span> <span class="nx">A</span> <span class="k">is</span> <span class="nx">X</span> <span class="p">{}</span>
<span class="kd">contract</span> <span class="nx">C</span> <span class="k">is</span> <span class="nx">A</span><span class="p">,</span> <span class="nx">X</span> <span class="p">{}</span>
</pre></div>
</div>
<p>这样做的原因是C请求X覆盖了A(在这个顺序中指定了A, X)，但是一个itselests要覆盖X，这是一个无法解决的矛盾。<code class="docutils literal"><span class="pre">C</span></code><code class="docutils literal"><span class="pre">X</span></code><code class="docutils literal"><span class="pre">A</span></code><code class="docutils literal"><span class="pre">A,</span> <span class="pre">X</span></code><code class="docutils literal"><span class="pre">A</span></code><code class="docutils literal"><span class="pre">X</span></code></p>
</div>
<div class="section" id="inheriting-different-kinds-of-members-of-the-same-name">
<h5>Inheriting Different Kinds of Members of the Same Name<a class="headerlink" href="#inheriting-different-kinds-of-members-of-the-same-name" title="Permalink to this headline">¶</a></h5>
<p>当继承结果与一个函数和一个相同名称的修饰符发生关系时，它被认为是一个错误。这个错误也是由一个事件和一个同名的修饰符产生的，一个函数和一个同名的事件。作为异常，状态变量getter可以覆盖公共函数。</p>
</div>
</div>
<div class="section" id="abstract-contracts">
<span id="abstract-contract"></span><span id="index-18"></span><h4>Abstract Contracts<a class="headerlink" href="#abstract-contracts" title="Permalink to this headline">¶</a></h4>
<p>当至少其中一个函数缺少实现时，合约被标记为抽象(注意，函数声明头被终止):<code class="docutils literal"><span class="pre">;</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Feline</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">utterance</span><span class="p">()</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这样的合约不能被编译(即使它们包含实现的功能和未实现的功能)，但它们可以作为基础合约使用:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Feline</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">utterance</span><span class="p">()</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">Cat</span> <span class="k">is</span> <span class="nx">Feline</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">utterance</span><span class="p">()</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes32</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="s2">"miaow"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果合约从抽象合约中继承而不是通过重写实现所有未实现的功能，那么它本身就是抽象的。</p>
<p>注意，没有实现的函数与函数类型不同，尽管它们的语法看起来非常相似。<a class="reference internal" href="index.html#function-types"><span class="std std-ref">Function Type</span></a></p>
<p>没有实现的函数示例(函数声明):</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="kt">address</span><span class="p">)</span> <span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">);</span>
</pre></div>
</div>
<p>函数类型的示例(变量声明，其中变量为类型函数):<code class="docutils literal"><span class="pre">function</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="p">(</span><span class="kt">address</span><span class="p">)</span> <span class="k">external</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">)</span> <span class="nx">foo</span><span class="p">;</span>
</pre></div>
</div>
<p>抽象合约将合约的定义与它的实现解耦，提供了更好的可扩展性和自文档化，并简化了模板方法和删除代码重复等模式。<a class="reference external" href="https://en.wikipedia.org/wiki/Template_method_pattern">Template method</a></p>
</div>
<div class="section" id="interfaces">
<span id="index-19"></span><h4>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h4>
<p>接口类似于抽象合约，但它们不能实现任何功能。还有更多的限制:</p>
<ol class="arabic simple">
<li>Cannot inherit other contracts or interfaces.</li>
<li>Cannot define constructor.</li>
<li>Cannot define variables.</li>
<li>Cannot define structs.</li>
<li>Cannot define enums.</li>
</ol>
<p>其中一些限制可能会在未来被取消。</p>
<p>接口基本上局限于合约ABI所能表示的内容，而且在不丢失任何信息的情况下，应该可以实现ABI和接口之间的转换。</p>
<p>接口用它们自己的关键字表示:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>

<span class="kd">interface</span> <span class="nx">Token</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">transfer</span><span class="p">(</span><span class="kt">address</span> <span class="nx">recipient</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">amount</span><span class="p">)</span> <span class="k">public</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>合约可以继承接口，因为它们将继承其他合约。</p>
</div>
<div class="section" id="libraries">
<span id="index-20"></span><span id="id8"></span><h4>Libraries<a class="headerlink" href="#libraries" title="Permalink to this headline">¶</a></h4>
<p>类库类似于合约，但它们的目的是只在特定的地址上部署一次，并且它们的代码在EVM的特性中被重用(CALLCODE直到Homestead)。这意味着如果调用了库函数，它们的代码将在调用合约的上下文中执行，也就是说，这指向了合约，特别是调用合约的存储可以被访问。作为一个库是一个单独的源代码，它只能访问调用合约的变量，如果它们是显式提供的(否则就无法命名它们)。如果不修改状态(也就是说，如果它们是视图或纯函数)，那么库函数只能直接调用(即不使用委托)，因为假定库是无状态的。特别地，如果不使用Solidity的类型系统，就不可能破坏一个库。<code class="docutils literal"><span class="pre">DELEGATECALL</span></code><code class="docutils literal"><span class="pre">CALLCODE</span></code><code class="docutils literal"><span class="pre">this</span></code><code class="docutils literal"><span class="pre">DELEGATECALL</span></code><code class="docutils literal"><span class="pre">view</span></code><code class="docutils literal"><span class="pre">pure</span></code></p>
<p>库可以看作是使用它们的合约的隐式基础合约。它们不会在继承层次结构中显式地可见，但是callsto库函数看起来就像对显式的basecon(如果L是库的名称)函数的调用。此外，图书馆的内部功能在所有的合约中都是可见的，就像图书馆是基础合约一样。当然，调用内部函数使用内部调用约定，这意味着所有内部类型都可以传递，内存类型将通过引用传递，而不是复制。为了在EVM中实现这一点，内部库函数的代码和从其中调用的所有函数在编译时将被拉入callingcontract，并且将使用一个常规的跳转调用来代替委托。<code class="docutils literal"><span class="pre">L.f()</span></code><code class="docutils literal"><span class="pre">L</span></code><code class="docutils literal"><span class="pre">internal</span></code><code class="docutils literal"><span class="pre">JUMP</span></code><code class="docutils literal"><span class="pre">DELEGATECALL</span></code></p>
<p id="index-21">下面的例子说明了如何使用库(但是一定要检查使用amore高级示例来实现一个集合)。<a class="reference internal" href="#using-for"><span class="std std-ref">using for</span></a></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">library</span> <span class="nx">Set</span> <span class="p">{</span>
  <span class="c1">// We define a new struct datatype that will be used to</span>
  <span class="c1">// hold its data in the calling contract.</span>
  <span class="kd">struct</span> <span class="nx">Data</span> <span class="p">{</span> <span class="k">mapping</span><span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">flags</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Note that the first parameter is of type "storage</span>
  <span class="c1">// reference" and thus only its storage address and not</span>
  <span class="c1">// its contents is passed as part of the call.  This is a</span>
  <span class="c1">// special feature of library functions.  It is idiomatic</span>
  <span class="c1">// to call the first parameter `self`, if the function can</span>
  <span class="c1">// be seen as a method of that object.</span>
  <span class="kd">function</span> <span class="nx">insert</span><span class="p">(</span><span class="nx">Data</span> <span class="k">storage</span> <span class="nx">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span>
      <span class="k">public</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">flags</span><span class="p">[</span><span class="nx">value</span><span class="p">])</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// already there</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">flags</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">remove</span><span class="p">(</span><span class="nx">Data</span> <span class="k">storage</span> <span class="nx">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span>
      <span class="k">public</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">self</span><span class="p">.</span><span class="nx">flags</span><span class="p">[</span><span class="nx">value</span><span class="p">])</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// not there</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">flags</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">contains</span><span class="p">(</span><span class="nx">Data</span> <span class="k">storage</span> <span class="nx">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span>
      <span class="k">public</span>
      <span class="k">view</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">flags</span><span class="p">[</span><span class="nx">value</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="nx">Set</span><span class="p">.</span><span class="nx">Data</span> <span class="nx">knownValues</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">register</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// The library functions can be called without a</span>
        <span class="c1">// specific instance of the library, since the</span>
        <span class="c1">// "instance" will be the current contract.</span>
        <span class="nb">require</span><span class="p">(</span><span class="nx">Set</span><span class="p">.</span><span class="nx">insert</span><span class="p">(</span><span class="nx">knownValues</span><span class="p">,</span> <span class="nx">value</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="c1">// In this contract, we can also directly access knownValues.flags, if we want.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当然，您不必遵循这种方法来使用uselibraries:它们也可以在不定义结构数据类型的情况下使用。函数也可以在没有任何storagereference参数的情况下工作，它们可以有多个存储引用参数和任何位置。</p>
<p>调用到Set.contains, Set.insert和Set.removeare都被编译成一个外部合约/库的调用(委托)。如果您使用库，请注意实际的外部函数调用是穿孔的。发送方,味精。但是，在这个调用中，值和这个值将保留它们的值(在Homestead之前，因为使用了CALLCODE, msg)。发送方andmsg。值改变,尽管)。<code class="docutils literal"><span class="pre">Set.contains</span></code><code class="docutils literal"><span class="pre">Set.insert</span></code><code class="docutils literal"><span class="pre">Set.remove</span></code><code class="docutils literal"><span class="pre">DELEGATECALL</span></code><code class="docutils literal"><span class="pre">msg.sender</span></code><code class="docutils literal"><span class="pre">msg.value</span></code><code class="docutils literal"><span class="pre">this</span></code><code class="docutils literal"><span class="pre">CALLCODE</span></code><code class="docutils literal"><span class="pre">msg.sender</span></code><code class="docutils literal"><span class="pre">msg.value</span></code></p>
<p>下面的示例展示了如何在库中使用内存类型和内部函数来实现自定义类型，而不需要外部函数调用的开销:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">library</span> <span class="nx">BigInt</span> <span class="p">{</span>
    <span class="kd">struct</span> <span class="nx">bigint</span> <span class="p">{</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="nx">limbs</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">fromUint</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="nx">bigint</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">limbs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="mi">1</span><span class="p">);</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">limbs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">bigint</span> <span class="nx">_a</span><span class="p">,</span> <span class="nx">bigint</span> <span class="nx">_b</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="nx">bigint</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">r</span><span class="p">.</span><span class="nx">limbs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="nx">max</span><span class="p">(</span><span class="nx">_a</span><span class="p">.</span><span class="nx">limbs</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">_b</span><span class="p">.</span><span class="nx">limbs</span><span class="p">.</span><span class="nx">length</span><span class="p">));</span>
        <span class="kt">uint</span> <span class="nx">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">limbs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">uint</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">limb</span><span class="p">(</span><span class="nx">_a</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
            <span class="kt">uint</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">limb</span><span class="p">(</span><span class="nx">_b</span><span class="p">,</span> <span class="nx">i</span><span class="p">);</span>
            <span class="nx">r</span><span class="p">.</span><span class="nx">limbs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">carry</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">&lt;</span> <span class="nx">a</span> <span class="o">||</span> <span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">==</span> <span class="kt">uint</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
                <span class="nx">carry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="nx">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">carry</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// too bad, we have to add a limb</span>
            <span class="kt">uint</span><span class="p">[]</span> <span class="k">memory</span> <span class="nx">newLimbs</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">uint</span><span class="p">[](</span><span class="nx">r</span><span class="p">.</span><span class="nx">limbs</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">limbs</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
                <span class="nx">newLimbs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">limbs</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="nx">newLimbs</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">carry</span><span class="p">;</span>
            <span class="nx">r</span><span class="p">.</span><span class="nx">limbs</span> <span class="o">=</span> <span class="nx">newLimbs</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">limb</span><span class="p">(</span><span class="nx">bigint</span> <span class="nx">_a</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">_limb</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">_limb</span> <span class="o">&lt;</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">limbs</span><span class="p">.</span><span class="nx">length</span> <span class="o">?</span> <span class="nx">_a</span><span class="p">.</span><span class="nx">limbs</span><span class="p">[</span><span class="nx">_limb</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">max</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">b</span><span class="p">)</span> <span class="k">private</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span> <span class="o">&gt;</span> <span class="nx">b</span> <span class="o">?</span> <span class="nx">a</span> <span class="o">:</span> <span class="nx">b</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="k">using</span> <span class="nx">BigInt</span> <span class="k">for</span> <span class="nx">BigInt</span><span class="p">.</span><span class="nx">bigint</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="k">pure</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">.</span><span class="nx">fromUint</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
        <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">BigInt</span><span class="p">.</span><span class="nx">fromUint</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
        <span class="kd">var</span> <span class="nx">z</span> <span class="o">=</span> <span class="nx">x</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>由于编译器无法知道库将在何处部署，所以这些地址必须由链接器填充到最终的字节码(请参阅使用Commandline编译器来使用该命令行编译器来链接)。如果地址不作为参数给编译器，编译后的十六进制代码将包含表单__Set______的占位符(whereSet是库的名称)。通过将所有40个符号替换为对图书馆合约地址的hexencoding，可以手工完成这个地址。<a class="reference internal" href="index.html#commandline-compiler"><span class="std std-ref">Using the Commandline Compiler</span></a><code class="docutils literal"><span class="pre">__Set______</span></code><code class="docutils literal"><span class="pre">Set</span></code></p>
<p>与合约相比，图书馆的限制:</p>
<ul class="simple">
<li>No state variables</li>
<li>Cannot inherit nor be inherited</li>
<li>Cannot receive Ether</li>
</ul>
<p>(这些可能会在稍后被取消。)</p>
<div class="section" id="call-protection-for-libraries">
<h5>Call Protection For Libraries<a class="headerlink" href="#call-protection-for-libraries" title="Permalink to this headline">¶</a></h5>
<p>正如在介绍中所提到的，如果一个库的代码是使用一个调用而不是一个委托或CALLCODE执行的，它将会恢复，除非调用一个视图或纯函数。<code class="docutils literal"><span class="pre">CALL</span></code><code class="docutils literal"><span class="pre">DELEGATECALL</span></code><code class="docutils literal"><span class="pre">CALLCODE</span></code><code class="docutils literal"><span class="pre">view</span></code><code class="docutils literal"><span class="pre">pure</span></code></p>
<p>EVM并没有提供一种直接的方法来检测是否调用了调用，但是contractcan使用地址操作码来查找当前正在运行的“where”。生成的代码将此addressto与构建时使用的地址进行比较，以确定modeof调用。<code class="docutils literal"><span class="pre">CALL</span></code><code class="docutils literal"><span class="pre">ADDRESS</span></code></p>
<p>更具体地说，库的运行时代码总是带有一个push指令，这是一个0字节的编译时间。当部署代码运行时，由当前地址替换为内存中的constantis，并将此修改后的代码存储在合约中。在运行时，这会导致部署时地址是被推送到堆栈上的第一个常量，而dispatchercode则将当前地址与此常量进行比较，以获得任何非视图和非纯函数。</p>
</div>
</div>
<div class="section" id="using-for">
<span id="index-22"></span><span id="id9"></span><h4>Using For<a class="headerlink" href="#using-for" title="Permalink to this headline">¶</a></h4>
<p>A为B的指令;可以将libraryfunctions(从库A)附加到任何类型(B)。这些函数将接收被调用的对象作为第一个参数(就像self变量inPython)。<code class="docutils literal"><span class="pre">using</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">B;</span></code><code class="docutils literal"><span class="pre">A</span></code><code class="docutils literal"><span class="pre">B</span></code><code class="docutils literal"><span class="pre">self</span></code></p>
<p>使用for *的效果;是从库A的函数附加到任何类型。<code class="docutils literal"><span class="pre">using</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">*;</span></code><code class="docutils literal"><span class="pre">A</span></code></p>
<p>在这两种情况下，所有函数，甚至是第一个参数的类型与对象类型不匹配的函数都是附加的。在函数被调用的点上检查类型，并执行功能重载解析。</p>
<p>A用于B;指令是当前作用域的活动，它现在只局限于一个合约，但是稍后将被提升到全局范围，因此，通过包含一个模块，它的数据类型包括库函数，而无需添加更多的代码。<code class="docutils literal"><span class="pre">using</span> <span class="pre">A</span> <span class="pre">for</span> <span class="pre">B;</span></code></p>
<p>让我们以这种方式重写这些库中的set示例:<a class="reference internal" href="#libraries"><span class="std std-ref">Libraries</span></a></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="c1">// This is the same code as before, just without comments</span>
<span class="kd">library</span> <span class="nx">Set</span> <span class="p">{</span>
  <span class="kd">struct</span> <span class="nx">Data</span> <span class="p">{</span> <span class="k">mapping</span><span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="kt">bool</span><span class="p">)</span> <span class="nx">flags</span><span class="p">;</span> <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">insert</span><span class="p">(</span><span class="nx">Data</span> <span class="k">storage</span> <span class="nx">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span>
      <span class="k">public</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">flags</span><span class="p">[</span><span class="nx">value</span><span class="p">])</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// already there</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">flags</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">remove</span><span class="p">(</span><span class="nx">Data</span> <span class="k">storage</span> <span class="nx">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span>
      <span class="k">public</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">self</span><span class="p">.</span><span class="nx">flags</span><span class="p">[</span><span class="nx">value</span><span class="p">])</span>
          <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// not there</span>
      <span class="nx">self</span><span class="p">.</span><span class="nx">flags</span><span class="p">[</span><span class="nx">value</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">contains</span><span class="p">(</span><span class="nx">Data</span> <span class="k">storage</span> <span class="nx">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span>
      <span class="k">public</span>
      <span class="k">view</span>
      <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span>
  <span class="p">{</span>
      <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">flags</span><span class="p">[</span><span class="nx">value</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="k">using</span> <span class="nx">Set</span> <span class="k">for</span> <span class="nx">Set</span><span class="p">.</span><span class="nx">Data</span><span class="p">;</span> <span class="c1">// this is the crucial change</span>
    <span class="nx">Set</span><span class="p">.</span><span class="nx">Data</span> <span class="nx">knownValues</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">register</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// Here, all variables of type Set.Data have</span>
        <span class="c1">// corresponding member functions.</span>
        <span class="c1">// The following function call is identical to</span>
        <span class="c1">// `Set.insert(knownValues, value)`</span>
        <span class="nb">require</span><span class="p">(</span><span class="nx">knownValues</span><span class="p">.</span><span class="nx">insert</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>也有可能以这种方式扩展基本类型:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">library</span> <span class="nx">Search</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">indexOf</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="k">storage</span> <span class="nx">self</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span>
        <span class="k">public</span>
        <span class="k">view</span>
        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">self</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">value</span><span class="p">)</span> <span class="k">return</span> <span class="nx">i</span><span class="p">;</span>
        <span class="k">return</span> <span class="kt">uint</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="k">using</span> <span class="nx">Search</span> <span class="k">for</span> <span class="kt">uint</span><span class="p">[];</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="nx">data</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">append</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">value</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">replace</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_old</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">_new</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// This performs the library function call</span>
        <span class="kt">uint</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">_old</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">==</span> <span class="kt">uint</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="nx">data</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">_new</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="nx">data</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_new</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意，所有库调用都是实际的EVM函数调用。这意味着如果您传递内存或值类型，将执行一个副本，即使是这个变量。只有在使用存储引用变量时，才会出现穿孔的情况。<code class="docutils literal"><span class="pre">self</span></code></p>
</div>
</div>
<span id="document-assembly"></span><div class="section" id="solidity-assembly">
<h3>Solidity Assembly<a class="headerlink" href="#solidity-assembly" title="Permalink to this headline">¶</a></h3>
<p id="index-0">Solidity定义了一种汇编语言，它也可以不带固态地使用。这种汇编语言也可以用作固化源代码中的“内联汇编”。我们首先描述如何使用内联程序集，以及它与独立程序集的区别，然后指定程序集本身。</p>
<div class="section" id="inline-assembly">
<span id="id1"></span><h4>Inline Assembly<a class="headerlink" href="#inline-assembly" title="Permalink to this headline">¶</a></h4>
<p>对于更细粒度的控制，特别是为了通过编写库来增强语言，可以将Solidity语句与内联汇编语言结合在一个虚拟机的语言中。由于EVM是一个堆栈机器，所以通常很难处理正确的堆栈槽，并在堆栈的正确点上提供对操作码的参数。Solidity的内联程序集试图通过以下特性在编写手动程序集时促进该问题和其他问题:</p>
<ul class="simple">
<li>functional-style opcodes: <code class="docutils literal"><span class="pre">mul(1,</span> <span class="pre">add(2,</span> <span class="pre">3))</span></code> instead of <code class="docutils literal"><span class="pre">push1</span> <span class="pre">3</span> <span class="pre">push1</span> <span class="pre">2</span> <span class="pre">add</span> <span class="pre">push1</span> <span class="pre">1</span> <span class="pre">mul</span></code></li>
<li>assembly-local variables: <code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(2,</span> <span class="pre">3)</span>  <span class="pre">let</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">mload(0x40)</span>  <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(x,</span> <span class="pre">y)</span></code></li>
<li>access to external variables: <code class="docutils literal"><span class="pre">function</span> <span class="pre">f(uint</span> <span class="pre">x)</span> <span class="pre">public</span> <span class="pre">{</span> <span class="pre">assembly</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">sub(x,</span> <span class="pre">1)</span> <span class="pre">}</span> <span class="pre">}</span></code></li>
<li>labels: <code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">10</span>  <span class="pre">repeat:</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">sub(x,</span> <span class="pre">1)</span> <span class="pre">jumpi(repeat,</span> <span class="pre">eq(x,</span> <span class="pre">0))</span></code></li>
<li>loops: <code class="docutils literal"><span class="pre">for</span> <span class="pre">{</span> <span class="pre">let</span> <span class="pre">i</span> <span class="pre">:=</span> <span class="pre">0</span> <span class="pre">}</span> <span class="pre">lt(i,</span> <span class="pre">x)</span> <span class="pre">{</span> <span class="pre">i</span> <span class="pre">:=</span> <span class="pre">add(i,</span> <span class="pre">1)</span> <span class="pre">}</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">mul(2,</span> <span class="pre">y)</span> <span class="pre">}</span></code></li>
<li>if statements: <code class="docutils literal"><span class="pre">if</span> <span class="pre">slt(x,</span> <span class="pre">0)</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">sub(0,</span> <span class="pre">x)</span> <span class="pre">}</span></code></li>
<li>switch statements: <code class="docutils literal"><span class="pre">switch</span> <span class="pre">x</span> <span class="pre">case</span> <span class="pre">0</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">mul(x,</span> <span class="pre">2)</span> <span class="pre">}</span> <span class="pre">default</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">0</span> <span class="pre">}</span></code></li>
<li>function calls: <code class="docutils literal"><span class="pre">function</span> <span class="pre">f(x)</span> <span class="pre">-&gt;</span> <span class="pre">y</span> <span class="pre">{</span> <span class="pre">switch</span> <span class="pre">x</span> <span class="pre">case</span> <span class="pre">0</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">1</span> <span class="pre">}</span> <span class="pre">default</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">mul(x,</span> <span class="pre">f(sub(x,</span> <span class="pre">1)))</span> <span class="pre">}</span>   <span class="pre">}</span></code></li>
</ul>
<p>现在我们要详细描述内联汇编语言。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">内联程序集是一种低级别访问Ethereum虚拟机的方法。这丢弃了固体的几个重要的安全特性。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">TODO:写一下内联汇编的范围规则有一点不同，以及在使用库的内部函数时出现的复杂性。此外，还可以写一些由编译器定义的符号。</p>
</div>
<div class="section" id="example">
<h5>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h5>
<p>下面的示例提供了库代码来访问另一个合约的代码，并将其加载到一个字节变量中。这是不可能的，在所有的“朴素的可靠性”和想法是，装配图书馆将被用来提高语言的这种方式。<code class="docutils literal"><span class="pre">bytes</span></code></p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">library</span> <span class="nx">GetCode</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">at</span><span class="p">(</span><span class="kt">address</span> <span class="nx">_addr</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bytes</span> <span class="nx">o_code</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
            <span class="c1">// retrieve the size of the code, this needs assembly</span>
            <span class="kr">let</span> <span class="nx">size</span> <span class="o">:=</span> <span class="nx">extcodesize</span><span class="p">(</span><span class="nx">_addr</span><span class="p">)</span>
            <span class="c1">// allocate output byte array - this could also be done without assembly</span>
            <span class="c1">// by using o_code = new bytes(size)</span>
            <span class="nx">o_code</span> <span class="o">:=</span> <span class="nx">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
            <span class="c1">// new "memory end" including padding</span>
            <span class="nx">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="nx">add</span><span class="p">(</span><span class="nx">o_code</span><span class="p">,</span> <span class="nx">and</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="mh">0x1f</span><span class="p">),</span> <span class="nx">not</span><span class="p">(</span><span class="mh">0x1f</span><span class="p">))))</span>
            <span class="c1">// store length in memory</span>
            <span class="nx">mstore</span><span class="p">(</span><span class="nx">o_code</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
            <span class="c1">// actually retrieve the code, this needs assembly</span>
            <span class="nx">extcodecopy</span><span class="p">(</span><span class="nx">_addr</span><span class="p">,</span> <span class="nx">add</span><span class="p">(</span><span class="nx">o_code</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在优化器无法生成有效代码的情况下，内联程序集也可能是有益的。请注意，因为编译器不执行检查，所以要编写程序集要困难得多，所以只有当您真正知道自己在做什么时，才应该使用它来处理复杂的事情。</p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">library</span> <span class="nx">VectorSum</span> <span class="p">{</span>
    <span class="c1">// This function is less efficient because the optimizer currently fails to</span>
    <span class="c1">// remove the bounds checks in array access.</span>
    <span class="kd">function</span> <span class="nx">sumSolidity</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="nx">_data</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">o_sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">_data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
            <span class="nx">o_sum</span> <span class="o">+=</span> <span class="nx">_data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// We know that we only access the array in bounds, so we can avoid the check.</span>
    <span class="c1">// 0x20 needs to be added to an array because the first slot contains the</span>
    <span class="c1">// array length.</span>
    <span class="kd">function</span> <span class="nx">sumAsm</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="nx">_data</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">o_sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">_data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">assembly</span> <span class="p">{</span>
                <span class="nx">o_sum</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">o_sum</span><span class="p">,</span> <span class="nx">mload</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="nx">_data</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="nx">mul</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">))))</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Same as above, but accomplish the entire code within inline assembly.</span>
    <span class="kd">function</span> <span class="nx">sumPureAsm</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="nx">_data</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">o_sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
           <span class="c1">// Load the length (first 32 bytes)</span>
           <span class="kr">let</span> <span class="nx">len</span> <span class="o">:=</span> <span class="nx">mload</span><span class="p">(</span><span class="nx">_data</span><span class="p">)</span>

           <span class="c1">// Skip over the length field.</span>
           <span class="c1">//</span>
           <span class="c1">// Keep temporary variable so it can be incremented in place.</span>
           <span class="c1">//</span>
           <span class="c1">// NOTE: incrementing _data would result in an unusable</span>
           <span class="c1">//       _data variable after this assembly block</span>
           <span class="kr">let</span> <span class="nx">data</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">_data</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>

           <span class="c1">// Iterate until the bound is not met.</span>
           <span class="k">for</span>
               <span class="p">{</span> <span class="kr">let</span> <span class="nx">end</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">len</span><span class="p">)</span> <span class="p">}</span>
               <span class="nx">lt</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
               <span class="p">{</span> <span class="nx">data</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">}</span>
           <span class="p">{</span>
               <span class="nx">o_sum</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">o_sum</span><span class="p">,</span> <span class="nx">mload</span><span class="p">(</span><span class="nx">data</span><span class="p">))</span>
           <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="syntax">
<h5>Syntax<a class="headerlink" href="#syntax" title="Permalink to this headline">¶</a></h5>
<p>程序集解析注释、文字和标识符完全是可靠的，所以您可以使用通常的//和/* */注释。内联程序集的标记是程序集{…}和内部这些花括号，可以使用以下内容(更多细节请参阅后面的章节)<code class="docutils literal"><span class="pre">//</span></code><code class="docutils literal"><span class="pre">/*</span> <span class="pre">*/</span></code><code class="docutils literal"><span class="pre">assembly</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code></p>
<blockquote>
<div><ul class="simple">
<li>literals, i.e. <code class="docutils literal"><span class="pre">0x123</span></code>, <code class="docutils literal"><span class="pre">42</span></code> or <code class="docutils literal"><span class="pre">"abc"</span></code> (strings up to 32 characters)</li>
<li>opcodes (in “instruction style”), e.g. <code class="docutils literal"><span class="pre">mload</span> <span class="pre">sload</span> <span class="pre">dup1</span> <span class="pre">sstore</span></code>, for a list see below</li>
<li>opcodes in functional style, e.g. <code class="docutils literal"><span class="pre">add(1,</span> <span class="pre">mlod(0))</span></code></li>
<li>labels, e.g. <code class="docutils literal"><span class="pre">name:</span></code></li>
<li>variable declarations, e.g. <code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">7</span></code>, <code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(y,</span> <span class="pre">3)</span></code> or <code class="docutils literal"><span class="pre">let</span> <span class="pre">x</span></code> (initial value of empty (0) is assigned)</li>
<li>identifiers (labels or assembly-local variables and externals if used as inline assembly), e.g. <code class="docutils literal"><span class="pre">jump(name)</span></code>, <code class="docutils literal"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">add</span></code></li>
<li>assignments (in “instruction style”), e.g. <code class="docutils literal"><span class="pre">3</span> <span class="pre">=:</span> <span class="pre">x</span></code></li>
<li>assignments in functional style, e.g. <code class="docutils literal"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">add(y,</span> <span class="pre">3)</span></code></li>
<li>blocks where local variables are scoped inside, e.g. <code class="docutils literal"><span class="pre">{</span> <span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">3</span> <span class="pre">{</span> <span class="pre">let</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">add(x,</span> <span class="pre">1)</span> <span class="pre">}</span> <span class="pre">}</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="opcodes">
<h5>Opcodes<a class="headerlink" href="#opcodes" title="Permalink to this headline">¶</a></h5>
<p>本文档不希望对Ethereum虚拟机进行完整的描述，但是下面的列表可以作为其操作码的参考。</p>
<p>如果一个操作码接受参数(总是从堆栈的顶部)，它们将在括号中给出。注意，在非功能性的样式中，可以看到参数的顺序是颠倒的(下面解释)。操作码标记为-不要将一个项目推到堆栈上，那些标记为*特殊的和所有其他的都将一个项目推到堆栈上。以F、H、B或C标记的操作码分别出现在边疆、宅基地、拜占庭或君士坦丁堡。君士坦丁堡仍在计划中，所有的指示都标记为这样，将导致无效的指令异常。<code class="docutils literal"><span class="pre">-</span></code><code class="docutils literal"><span class="pre">*</span></code><code class="docutils literal"><span class="pre">F</span></code><code class="docutils literal"><span class="pre">H</span></code><code class="docutils literal"><span class="pre">B</span></code><code class="docutils literal"><span class="pre">C</span></code></p>
<p>在下面，mem[a…b]表示从位置a开始到(不包括)位置b和存储[p]的内存字节，表示位置p的存储内容。<code class="docutils literal"><span class="pre">mem[a...b)</span></code><code class="docutils literal"><span class="pre">a</span></code><code class="docutils literal"><span class="pre">b</span></code><code class="docutils literal"><span class="pre">storage[p]</span></code><code class="docutils literal"><span class="pre">p</span></code></p>
<p>不能直接使用opcode pushi和jumpdest。<code class="docutils literal"><span class="pre">pushi</span></code><code class="docutils literal"><span class="pre">jumpdest</span></code></p>
<p>在语法中，操作码被表示为预定义的标识符。</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%"/>
<col width="5%"/>
<col width="3%"/>
<col width="66%"/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Instruction</th>
<th class="head"> </th>
<th class="head"> </th>
<th class="head">Explanation</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="2">stop</td>
<td rowspan="2"><cite>-</cite></td>
<td rowspan="2">F</td>
<td rowspan="2">stop execution, identical to return(0,0)</td>
</tr>
<tr class="row-odd"></tr>
<tr class="row-even"><td>add(x, y)</td>
<td> </td>
<td>F</td>
<td>x + y</td>
</tr>
<tr class="row-odd"><td>sub(x, y)</td>
<td> </td>
<td>F</td>
<td>x - y</td>
</tr>
<tr class="row-even"><td>mul(x, y)</td>
<td> </td>
<td>F</td>
<td>x * y</td>
</tr>
<tr class="row-odd"><td>div(x, y)</td>
<td> </td>
<td>F</td>
<td>x / y</td>
</tr>
<tr class="row-even"><td>sdiv(x, y)</td>
<td> </td>
<td>F</td>
<td>x / y, for signed numbers in two’s complement</td>
</tr>
<tr class="row-odd"><td>mod(x, y)</td>
<td> </td>
<td>F</td>
<td>x % y</td>
</tr>
<tr class="row-even"><td>smod(x, y)</td>
<td> </td>
<td>F</td>
<td>x % y, for signed numbers in two’s complement</td>
</tr>
<tr class="row-odd"><td>exp(x, y)</td>
<td> </td>
<td>F</td>
<td>x to the power of y</td>
</tr>
<tr class="row-even"><td>not(x)</td>
<td> </td>
<td>F</td>
<td>~x, every bit of x is negated</td>
</tr>
<tr class="row-odd"><td>lt(x, y)</td>
<td> </td>
<td>F</td>
<td>1 if x &lt; y, 0 otherwise</td>
</tr>
<tr class="row-even"><td>gt(x, y)</td>
<td> </td>
<td>F</td>
<td>1 if x &gt; y, 0 otherwise</td>
</tr>
<tr class="row-odd"><td>slt(x, y)</td>
<td> </td>
<td>F</td>
<td>1 if x &lt; y, 0 otherwise, for signed numbers in two’s complement</td>
</tr>
<tr class="row-even"><td>sgt(x, y)</td>
<td> </td>
<td>F</td>
<td>1 if x &gt; y, 0 otherwise, for signed numbers in two’s complement</td>
</tr>
<tr class="row-odd"><td>eq(x, y)</td>
<td> </td>
<td>F</td>
<td>1 if x == y, 0 otherwise</td>
</tr>
<tr class="row-even"><td>iszero(x)</td>
<td> </td>
<td>F</td>
<td>1 if x == 0, 0 otherwise</td>
</tr>
<tr class="row-odd"><td>and(x, y)</td>
<td> </td>
<td>F</td>
<td>bitwise and of x and y</td>
</tr>
<tr class="row-even"><td>or(x, y)</td>
<td> </td>
<td>F</td>
<td>bitwise or of x and y</td>
</tr>
<tr class="row-odd"><td>xor(x, y)</td>
<td> </td>
<td>F</td>
<td>bitwise xor of x and y</td>
</tr>
<tr class="row-even"><td>byte(n, x)</td>
<td> </td>
<td>F</td>
<td>nth byte of x, where the most significant byte is the 0th byte</td>
</tr>
<tr class="row-odd"><td>shl(x, y)</td>
<td> </td>
<td>C</td>
<td>logical shift left y by x bits</td>
</tr>
<tr class="row-even"><td>shr(x, y)</td>
<td> </td>
<td>C</td>
<td>logical shift right y by x bits</td>
</tr>
<tr class="row-odd"><td>sar(x, y)</td>
<td> </td>
<td>C</td>
<td>arithmetic shift right y by x bits</td>
</tr>
<tr class="row-even"><td>addmod(x, y, m)</td>
<td> </td>
<td>F</td>
<td>(x + y) % m with arbitrary precision arithmetics</td>
</tr>
<tr class="row-odd"><td>mulmod(x, y, m)</td>
<td> </td>
<td>F</td>
<td>(x * y) % m with arbitrary precision arithmetics</td>
</tr>
<tr class="row-even"><td>signextend(i, x)</td>
<td> </td>
<td>F</td>
<td>sign extend from (i*8+7)th bit counting from least significant</td>
</tr>
<tr class="row-odd"><td>keccak256(p, n)</td>
<td> </td>
<td>F</td>
<td>keccak(mem[p…(p+n)))</td>
</tr>
<tr class="row-even"><td>sha3(p, n)</td>
<td> </td>
<td>F</td>
<td>keccak(mem[p…(p+n)))</td>
</tr>
<tr class="row-odd"><td>jump(label)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>jump to label / code position</td>
</tr>
<tr class="row-even"><td>jumpi(label, cond)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>jump to label if cond is nonzero</td>
</tr>
<tr class="row-odd"><td>pc</td>
<td> </td>
<td>F</td>
<td>current position in code</td>
</tr>
<tr class="row-even"><td>pop(x)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>remove the element pushed by x</td>
</tr>
<tr class="row-odd"><td>dup1 … dup16</td>
<td> </td>
<td>F</td>
<td>copy ith stack slot to the top (counting from top)</td>
</tr>
<tr class="row-even"><td>swap1 … swap16</td>
<td><cite>*</cite></td>
<td>F</td>
<td>swap topmost and ith stack slot below it</td>
</tr>
<tr class="row-odd"><td>mload(p)</td>
<td> </td>
<td>F</td>
<td>mem[p..(p+32))</td>
</tr>
<tr class="row-even"><td>mstore(p, v)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>mem[p..(p+32)) := v</td>
</tr>
<tr class="row-odd"><td>mstore8(p, v)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>mem[p] := v &amp; 0xff (only modifies a single byte)</td>
</tr>
<tr class="row-even"><td>sload(p)</td>
<td> </td>
<td>F</td>
<td>storage[p]</td>
</tr>
<tr class="row-odd"><td>sstore(p, v)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>storage[p] := v</td>
</tr>
<tr class="row-even"><td>msize</td>
<td> </td>
<td>F</td>
<td>size of memory, i.e. largest accessed memory index</td>
</tr>
<tr class="row-odd"><td>gas</td>
<td> </td>
<td>F</td>
<td>gas still available to execution</td>
</tr>
<tr class="row-even"><td>address</td>
<td> </td>
<td>F</td>
<td>address of the current contract / execution context</td>
</tr>
<tr class="row-odd"><td>balance(a)</td>
<td> </td>
<td>F</td>
<td>wei balance at address a</td>
</tr>
<tr class="row-even"><td>caller</td>
<td> </td>
<td>F</td>
<td>call sender (excluding <code class="docutils literal"><span class="pre">delegatecall</span></code>)</td>
</tr>
<tr class="row-odd"><td>callvalue</td>
<td> </td>
<td>F</td>
<td>wei sent together with the current call</td>
</tr>
<tr class="row-even"><td>calldataload(p)</td>
<td> </td>
<td>F</td>
<td>call data starting from position p (32 bytes)</td>
</tr>
<tr class="row-odd"><td>calldatasize</td>
<td> </td>
<td>F</td>
<td>size of call data in bytes</td>
</tr>
<tr class="row-even"><td>calldatacopy(t, f, s)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>copy s bytes from calldata at position f to mem at position t</td>
</tr>
<tr class="row-odd"><td>codesize</td>
<td> </td>
<td>F</td>
<td>size of the code of the current contract / execution context</td>
</tr>
<tr class="row-even"><td>codecopy(t, f, s)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>copy s bytes from code at position f to mem at position t</td>
</tr>
<tr class="row-odd"><td>extcodesize(a)</td>
<td> </td>
<td>F</td>
<td>size of the code at address a</td>
</tr>
<tr class="row-even"><td>extcodecopy(a, t, f, s)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>like codecopy(t, f, s) but take code at address a</td>
</tr>
<tr class="row-odd"><td>returndatasize</td>
<td> </td>
<td>B</td>
<td>size of the last returndata</td>
</tr>
<tr class="row-even"><td>returndatacopy(t, f, s)</td>
<td><cite>-</cite></td>
<td>B</td>
<td>copy s bytes from returndata at position f to mem at position t</td>
</tr>
<tr class="row-odd"><td>create(v, p, s)</td>
<td> </td>
<td>F</td>
<td>create new contract with code mem[p..(p+s)) and send v wei
and return the new address</td>
</tr>
<tr class="row-even"><td>create2(v, n, p, s)</td>
<td> </td>
<td>C</td>
<td>create new contract with code mem[p..(p+s)) at address
keccak256(&lt;address&gt; . n . keccak256(mem[p..(p+s))) and send v
wei and return the new address</td>
</tr>
<tr class="row-odd"><td>call(g, a, v, in,
insize, out, outsize)</td>
<td> </td>
<td>F</td>
<td>call contract at address a with input mem[in..(in+insize))
providing g gas and v wei and output area
mem[out..(out+outsize)) returning 0 on error (eg. out of gas)
and 1 on success</td>
</tr>
<tr class="row-even"><td>callcode(g, a, v, in,
insize, out, outsize)</td>
<td> </td>
<td>F</td>
<td>identical to <code class="docutils literal"><span class="pre">call</span></code> but only use the code from a and stay
in the context of the current contract otherwise</td>
</tr>
<tr class="row-odd"><td>delegatecall(g, a, in,
insize, out, outsize)</td>
<td> </td>
<td>H</td>
<td>identical to <code class="docutils literal"><span class="pre">callcode</span></code> but also keep <code class="docutils literal"><span class="pre">caller</span></code>
and <code class="docutils literal"><span class="pre">callvalue</span></code></td>
</tr>
<tr class="row-even"><td>staticcall(g, a, in,
insize, out, outsize)</td>
<td> </td>
<td>B</td>
<td>identical to <code class="docutils literal"><span class="pre">call(g,</span> <span class="pre">a,</span> <span class="pre">0,</span> <span class="pre">in,</span> <span class="pre">insize,</span> <span class="pre">out,</span> <span class="pre">outsize)</span></code> but do
not allow state modifications</td>
</tr>
<tr class="row-odd"><td>return(p, s)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>end execution, return data mem[p..(p+s))</td>
</tr>
<tr class="row-even"><td>revert(p, s)</td>
<td><cite>-</cite></td>
<td>B</td>
<td>end execution, revert state changes, return data mem[p..(p+s))</td>
</tr>
<tr class="row-odd"><td>selfdestruct(a)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>end execution, destroy current contract and send funds to a</td>
</tr>
<tr class="row-even"><td>invalid</td>
<td><cite>-</cite></td>
<td>F</td>
<td>end execution with invalid instruction</td>
</tr>
<tr class="row-odd"><td>log0(p, s)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>log without topics and data mem[p..(p+s))</td>
</tr>
<tr class="row-even"><td>log1(p, s, t1)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>log with topic t1 and data mem[p..(p+s))</td>
</tr>
<tr class="row-odd"><td>log2(p, s, t1, t2)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>log with topics t1, t2 and data mem[p..(p+s))</td>
</tr>
<tr class="row-even"><td>log3(p, s, t1, t2, t3)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>log with topics t1, t2, t3 and data mem[p..(p+s))</td>
</tr>
<tr class="row-odd"><td>log4(p, s, t1, t2, t3,
t4)</td>
<td><cite>-</cite></td>
<td>F</td>
<td>log with topics t1, t2, t3, t4 and data mem[p..(p+s))</td>
</tr>
<tr class="row-even"><td>origin</td>
<td> </td>
<td>F</td>
<td>transaction sender</td>
</tr>
<tr class="row-odd"><td>gasprice</td>
<td> </td>
<td>F</td>
<td>gas price of the transaction</td>
</tr>
<tr class="row-even"><td>blockhash(b)</td>
<td> </td>
<td>F</td>
<td>hash of block nr b - only for last 256 blocks excluding current</td>
</tr>
<tr class="row-odd"><td>coinbase</td>
<td> </td>
<td>F</td>
<td>current mining beneficiary</td>
</tr>
<tr class="row-even"><td>timestamp</td>
<td> </td>
<td>F</td>
<td>timestamp of the current block in seconds since the epoch</td>
</tr>
<tr class="row-odd"><td>number</td>
<td> </td>
<td>F</td>
<td>current block number</td>
</tr>
<tr class="row-even"><td>difficulty</td>
<td> </td>
<td>F</td>
<td>difficulty of the current block</td>
</tr>
<tr class="row-odd"><td>gaslimit</td>
<td> </td>
<td>F</td>
<td>block gas limit of the current block</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="literals">
<h5>Literals<a class="headerlink" href="#literals" title="Permalink to this headline">¶</a></h5>
<p>您可以用十进制或十六进制表示法使用整数常量，并自动生成适当的PUSHi指令。下面创建了codeto add 2和3，结果是5，然后用字符串“abc”计算这个位。字符串存储左对齐，不能超过32字节。<code class="docutils literal"><span class="pre">PUSHi</span></code></p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">assembly</span> <span class="p">{</span> <span class="mi">2</span> <span class="mi">3</span> <span class="nx">add</span> <span class="s2">"abc"</span> <span class="nx">and</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="functional-style">
<h5>Functional Style<a class="headerlink" href="#functional-style" title="Permalink to this headline">¶</a></h5>
<p>您可以以同样的方式输入opcode，它们将以字节码结束。例如，对于位置0x80的内存中的内容，应该是。<code class="docutils literal"><span class="pre">3</span></code><code class="docutils literal"><span class="pre">0x80</span></code></p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="mi">3</span> <span class="mh">0x80</span> <span class="nx">mload</span> <span class="nx">add</span> <span class="mh">0x80</span> <span class="nx">mstore</span>
</pre></div>
</div>
<p>由于通常很难看出某些操作码的实际参数是什么，所以Solidity内联程序集也提供了一种“函数式”的符号，在这里，同样的代码将被写入如下。</p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">mstore</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="nx">add</span><span class="p">(</span><span class="nx">mload</span><span class="p">(</span><span class="mh">0x80</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>函数式表达式不能在内部使用教学风格，即1 2 mstore(0x80, add)不是有效的程序集，必须写asmstore(0x80，添加(2,1))。对于不带参数的操作码，可以省略括号。<code class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">mstore(0x80,</span> <span class="pre">add)</span></code><code class="docutils literal"><span class="pre">mstore(0x80,</span> <span class="pre">add(2,</span> <span class="pre">1))</span></code></p>
<p>注意，在函数风格中，参数的顺序是颠倒的，而不是指令样式。如果使用functionalstyle，第一个参数将位于堆栈顶部。</p>
</div>
<div class="section" id="access-to-external-variables-and-functions">
<h5>Access to External Variables and Functions<a class="headerlink" href="#access-to-external-variables-and-functions" title="Permalink to this headline">¶</a></h5>
<p>可以通过简单地使用它们的名称来访问Solidity变量和其他标识符。对于内存变量，这将推动地址而不是堆栈上的值。存储变量是不同的:存储中的值可能不占用afull存储槽，因此它们的“地址”由槽和槽内的字节数组成。要检索变量x指向的槽，您使用x_slot并检索使用x_offset的字节偏移量。<code class="docutils literal"><span class="pre">x</span></code><code class="docutils literal"><span class="pre">x_slot</span></code><code class="docutils literal"><span class="pre">x_offset</span></code></p>
<p>在作业中(见下文)，我们甚至可以使用本地的Solidity变量来赋值。</p>
<p>内联程序集外部的函数也可以被访问:程序集将会推入它们的条目标签(使用虚拟函数解析)。这是一种叫“semantisin solidity”的方法:</p>
<blockquote>
<div><ul class="simple">
<li>the caller pushes <code class="docutils literal"><span class="pre">return</span> <span class="pre">label</span></code>, <code class="docutils literal"><span class="pre">arg1</span></code>, <code class="docutils literal"><span class="pre">arg2</span></code>, …, <code class="docutils literal"><span class="pre">argn</span></code></li>
<li>the call returns with <code class="docutils literal"><span class="pre">ret1</span></code>, <code class="docutils literal"><span class="pre">ret2</span></code>, …, <code class="docutils literal"><span class="pre">retm</span></code></li>
</ul>
</div></blockquote>
<p>这个特性使用起来仍然有点麻烦，因为堆栈抵消了调用期间的本质更改，因此对局部变量的引用将是错误的。</p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="nx">b</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
            <span class="nx">r</span> <span class="o">:=</span> <span class="nx">mul</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">sload</span><span class="p">(</span><span class="nx">b_slot</span><span class="p">))</span> <span class="c1">// ignore the offset, we know it is zero</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">如果您访问的类型的变量小于256位(例如uint64、address、bytes16或字节)，那么您就不能对该类型的编码的部分进行任何假设。特别是，不要认为它们是零。为了安全起见，在使用它之前，必须正确地清除数据:uint32 x = f();集合{x:=和(x, 0xffffffff) /*现在使用x */}来清除签名类型，您可以使用signextend操作码。<code class="docutils literal"><span class="pre">uint64</span></code><code class="docutils literal"><span class="pre">address</span></code><code class="docutils literal"><span class="pre">bytes16</span></code><code class="docutils literal"><span class="pre">byte</span></code><code class="docutils literal"><span class="pre">uint32</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">f();</span> <span class="pre">assembly</span> <span class="pre">{</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">and(x,</span> <span class="pre">0xffffffff)</span> <span class="pre">/*</span> <span class="pre">now</span> <span class="pre">use</span> <span class="pre">x</span> <span class="pre">*/</span> <span class="pre">}</span></code><code class="docutils literal"><span class="pre">signextend</span></code></p>
</div>
</div>
<div class="section" id="labels">
<h5>Labels<a class="headerlink" href="#labels" title="Permalink to this headline">¶</a></h5>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">标签已被启用。请使用函数、循环、if或switch语句。</p>
</div>
<p>EVM程序集的另一个问题是，跳转和jumpi使用绝对地址，这很容易改变。Solidity内联程序集提供标签，使使用跳转更容易。注意，标签是一个低层次的特性，不需要标签就可以编写高效的程序集，只需使用汇编函数、循环、if和switch指令(见下文)。下面的代码计算了斐波那契数列中的一个元素。<code class="docutils literal"><span class="pre">jump</span></code><code class="docutils literal"><span class="pre">jumpi</span></code></p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kr">let</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nx">calldataload</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="kr">let</span> <span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="kr">let</span> <span class="nx">b</span> <span class="o">:=</span> <span class="nx">a</span>
<span class="nx">loop</span><span class="o">:</span>
    <span class="nx">jumpi</span><span class="p">(</span><span class="nx">loopend</span><span class="p">,</span> <span class="nx">eq</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="nx">a</span> <span class="nx">add</span> <span class="nx">swap1</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="nx">sub</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">jump</span><span class="p">(</span><span class="nx">loop</span><span class="p">)</span>
<span class="nx">loopend</span><span class="o">:</span>
    <span class="nx">mstore</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意，如果安装程序知道当前堆栈的高度，那么自动访问栈变量只能工作。如果跳转源和目标具有不同的堆栈高度，则此操作失败。使用这样的跳转仍然很好，但是在这种情况下，您不应该访问任何堆栈变量(甚至是程序集变量)。</p>
<p>此外，堆栈高度分析器通过opcode(而不是根据控制流)进行代码操作，因此在下面的例子中，装配人员对标签2的堆栈高度有错误的印象:<code class="docutils literal"><span class="pre">two</span></code></p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kr">let</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">8</span>
    <span class="nx">jump</span><span class="p">(</span><span class="nx">two</span><span class="p">)</span>
    <span class="nx">one</span><span class="o">:</span>
        <span class="c1">// Here the stack height is 2 (because we pushed x and 7),</span>
        <span class="c1">// but the assembler thinks it is 1 because it reads</span>
        <span class="c1">// from top to bottom.</span>
        <span class="c1">// Accessing the stack variable x here will lead to errors.</span>
        <span class="nx">x</span> <span class="o">:=</span> <span class="mi">9</span>
        <span class="nx">jump</span><span class="p">(</span><span class="nx">three</span><span class="p">)</span>
    <span class="nx">two</span><span class="o">:</span>
        <span class="mi">7</span> <span class="c1">// push something onto the stack</span>
        <span class="nx">jump</span><span class="p">(</span><span class="nx">one</span><span class="p">)</span>
    <span class="nx">three</span><span class="o">:</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="declaring-assembly-local-variables">
<h5>Declaring Assembly-Local Variables<a class="headerlink" href="#declaring-assembly-local-variables" title="Permalink to this headline">¶</a></h5>
<p>您可以使用let关键字来声明仅在内联汇编中可见的变量，而且实际上只在当前{…}块中声明。let指令将创建一个新的堆栈插槽，它将为该变量保留，并在阻塞结束时自动删除。您需要为该变量提供一个初始值，该值仅为0，但它也可以是一个复杂的函数式表达式。<code class="docutils literal"><span class="pre">let</span></code><code class="docutils literal"><span class="pre">{...}</span></code><code class="docutils literal"><span class="pre">let</span></code><code class="docutils literal"><span class="pre">0</span></code></p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">assembly</span> <span class="p">{</span>
            <span class="kr">let</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nx">mstore</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kr">let</span> <span class="nx">y</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">sload</span><span class="p">(</span><span class="nx">v</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nx">b</span> <span class="o">:=</span> <span class="nx">y</span>
            <span class="p">}</span> <span class="c1">// y is "deallocated" here</span>
            <span class="nx">b</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
        <span class="p">}</span> <span class="c1">// v is "deallocated" here</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="assignments">
<h5>Assignments<a class="headerlink" href="#assignments" title="Permalink to this headline">¶</a></h5>
<p>赋值可以用于组装局部变量和函数-localvariables。注意，当您分配到指向tomemory或存储的变量时，您只会更改指针而不是数据。</p>
<p>有两种任务:功能风格和教学风格。对于functional-style赋值(变量:=值)，您需要提供一种值，该值在函数式的表达式中，结果正好是一个堆栈valueand用于指示样式(=:variable)，值是从堆栈顶部取的。对于这两种方法，冒号都指向变量的名称。通过将变量的值替换为新值来执行。<code class="docutils literal"><span class="pre">variable</span> <span class="pre">:=</span> <span class="pre">value</span></code><code class="docutils literal"><span class="pre">=:</span> <span class="pre">variable</span></code></p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kr">let</span> <span class="nx">v</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">// functional-style assignment as part of variable declaration</span>
    <span class="kr">let</span> <span class="nx">g</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="nx">sload</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="o">=:</span> <span class="nx">v</span> <span class="c1">// instruction style assignment, puts the result of sload(10) into v</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Instruction-style任务是弃用。</p>
</div>
</div>
<div class="section" id="if">
<h5>If<a class="headerlink" href="#if" title="Permalink to this headline">¶</a></h5>
<p>if语句可以用于有条件地执行代码。没有“else”部分，考虑使用“switch”(参见下面)，如果您需要多个选项。</p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="k">if</span> <span class="nx">eq</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nb">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对身体的花括号是必需的。</p>
</div>
<div class="section" id="switch">
<h5>Switch<a class="headerlink" href="#switch" title="Permalink to this headline">¶</a></h5>
<p>您可以使用switch语句作为“if/else”的基本版本。它取一个表达式的值并将其与几个常量进行比较。与匹配常数对应的分支被取走。与某些编程语言的容易出错的行为相反，控制流不会从一个案例延续到下一个案例。可能出现一个名为default的回退或defaultcase。<code class="docutils literal"><span class="pre">default</span></code></p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kr">let</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="kr">switch</span> <span class="nx">calldataload</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="kr">case</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">:=</span> <span class="nx">calldataload</span><span class="p">(</span><span class="mh">0x24</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kr">default</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">:=</span> <span class="nx">calldataload</span><span class="p">(</span><span class="mh">0x44</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">sstore</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">div</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这种情况列表不需要花括号，但是acase的主体确实需要它们。</p>
</div>
<div class="section" id="loops">
<h5>Loops<a class="headerlink" href="#loops" title="Permalink to this headline">¶</a></h5>
<p>程序集支持一个简单的for-style循环。For-style循环有一个包含初始化部分、条件和后迭代部分的头。条件必须是函数式的表达式，而其他两个则是块。如果初始化部分声明了任何变量，则将这些变量的范围扩展到正文(包括条件和后迭代部分)。</p>
<p>下面的示例计算内存区域的和。</p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kr">let</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span> <span class="kr">let</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">}</span> <span class="nx">lt</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span> <span class="p">}</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">mload</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于循环也可以编写，这样它们就会像while循环一样运行:简单地将初始化和后迭代部分清空。</p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kr">let</span> <span class="nx">x</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="kr">let</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="p">{</span> <span class="p">}</span> <span class="nx">lt</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mh">0x100</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">{</span>     <span class="c1">// while(i &lt; 0x100)</span>
        <span class="nx">x</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">mload</span><span class="p">(</span><span class="nx">i</span><span class="p">))</span>
        <span class="nx">i</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="functions">
<h5>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h5>
<p>程序集允许定义低级函数。它们从堆栈中获取它们的参数(和返回PC)，并将结果放到堆栈中。调用函数与执行functionalstyleopcode看起来是一样的。</p>
<p>函数可以在任何地方定义，并且可以在声明的块中看到。在函数内，您不能访问该函数之外定义的局部变量。没有明确的returnstatement。<code class="docutils literal"><span class="pre">return</span></code></p>
<p>如果调用一个返回多个值的函数，则必须使用a、b:= f(x)或让a、b:= f(x)将它们赋值给一个元组。<code class="docutils literal"><span class="pre">a,</span> <span class="pre">b</span> <span class="pre">:=</span> <span class="pre">f(x)</span></code><code class="docutils literal"><span class="pre">let</span> <span class="pre">a,</span> <span class="pre">b</span> <span class="pre">:=</span> <span class="pre">f(x)</span></code></p>
<p>下面的例子通过平方和乘法实现幂函数。</p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kd">function</span> <span class="nx">power</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">exponent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">result</span> <span class="p">{</span>
        <span class="kr">switch</span> <span class="nx">exponent</span>
        <span class="kr">case</span> <span class="mi">0</span> <span class="p">{</span> <span class="nx">result</span> <span class="o">:=</span> <span class="mi">1</span> <span class="p">}</span>
        <span class="kr">case</span> <span class="mi">1</span> <span class="p">{</span> <span class="nx">result</span> <span class="o">:=</span> <span class="nx">base</span> <span class="p">}</span>
        <span class="kr">default</span> <span class="p">{</span>
            <span class="nx">result</span> <span class="o">:=</span> <span class="nx">power</span><span class="p">(</span><span class="nx">mul</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">base</span><span class="p">),</span> <span class="nx">div</span><span class="p">(</span><span class="nx">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="kr">switch</span> <span class="nx">mod</span><span class="p">(</span><span class="nx">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="kr">case</span> <span class="mi">1</span> <span class="p">{</span> <span class="nx">result</span> <span class="o">:=</span> <span class="nx">mul</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="things-to-avoid">
<h5>Things to Avoid<a class="headerlink" href="#things-to-avoid" title="Permalink to this headline">¶</a></h5>
<p>内联程序集可能具有相当高的外观，但实际上是非常低级的。函数调用、循环、ifs和交换机通过简单的编写规则进行转换，然后，汇编器为您做的唯一一件事就是重新安排功能样式的操作码、管理跳转标签、计数堆栈高度的变量访问，以及在到达他们的块时，为装配局部变量移除栈槽。特别是对于这两种情况，要知道汇编程序只从上到下计数堆栈高度，而不必遵循控制流。此外，像swap这样的操作只会交换堆栈的内容，而不是交换变量的位置。</p>
</div>
<div class="section" id="conventions-in-solidity">
<h5>Conventions in Solidity<a class="headerlink" href="#conventions-in-solidity" title="Permalink to this headline">¶</a></h5>
<p>与EVM装配相比，Solidity知道小于256位的类型。uint24。为了使它们更有效率，大多数算术运算只把它们当作256位的数字，而高阶位只在必要时才被清理，即在进行比较之前，在它们被写入内存之前不久。这意味着如果您从内联程序集中访问了这样的变量，您可能需要手动清理更高阶的bitsfirst。<code class="docutils literal"><span class="pre">uint24</span></code></p>
<p>Solidity以一种非常简单的方式管理内存:在内存中的位置0x40有一个“空闲内存指针”。如果您想分配内存，只需从该点使用memoryfrom并相应地更新指针。<code class="docutils literal"><span class="pre">0x40</span></code></p>
<p>第一个64字节的内存可以用作短期故障的“暂存空间”。在空闲内存指针(即从0x60开始)之后的32字节意味着永久为零，并被用作空的动态内存数组的初始值。<code class="docutils literal"><span class="pre">0x60</span></code></p>
<p>内存数组中的元素总是占用32字节的倍数(是的，这个i7对字节来说是正确的，但不是字节和字符串)。多维内存是指向内存数组的指针。动态数组的长度存储在数组的第一个槽中，然后只存储数组元素。<code class="docutils literal"><span class="pre">byte[]</span></code><code class="docutils literal"><span class="pre">bytes</span></code><code class="docutils literal"><span class="pre">string</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">静态大小的内存数组没有长度字段，但是它将被添加到允许静态和动态大小的数组之间更好的可转换性，soplease不依赖于此。</p>
</div>
</div>
</div>
<div class="section" id="standalone-assembly">
<h4>Standalone Assembly<a class="headerlink" href="#standalone-assembly" title="Permalink to this headline">¶</a></h4>
<p>上面所描述的汇编语言也可以是独立的，实际上，计划是将它用作Solidity编译器的中间语言。在这种形式下，它试图实现几个目标:</p>
<ol class="arabic simple">
<li>Programs written in it should be readable, even if the code is generated by a compiler from Solidity.</li>
<li>The translation from assembly to bytecode should contain as few “surprises” as possible.</li>
<li>Control flow should be easy to detect to help in formal verification and optimization.</li>
</ol>
<p>为了实现第一个和最后一个目标，装配提供了对循环的高级构造，如果和switch语句和函数调用。应该有可能编写不使用显式交换、DUP、跳转和JUMPI语句的汇编程序，因为前两个混淆了数据流和最后两个模糊控制流。此外，表单mul(add(x, y)， 7)的函数语句比纯的opcode语句更受青睐，比如7 y x添加mul，因为在第一个表单中，可以更容易地看到哪个操作数被用于哪个操作码。<code class="docutils literal"><span class="pre">for</span></code><code class="docutils literal"><span class="pre">if</span></code><code class="docutils literal"><span class="pre">switch</span></code><code class="docutils literal"><span class="pre">SWAP</span></code><code class="docutils literal"><span class="pre">DUP</span></code><code class="docutils literal"><span class="pre">JUMP</span></code><code class="docutils literal"><span class="pre">JUMPI</span></code><code class="docutils literal"><span class="pre">mul(add(x,</span> <span class="pre">y),</span> <span class="pre">7)</span></code><code class="docutils literal"><span class="pre">7</span> <span class="pre">y</span> <span class="pre">x</span> <span class="pre">add</span> <span class="pre">mul</span></code></p>
<p>第二个目标是通过非常常规的方式将更高级别的构造编译成字节码。汇编程序唯一的非本地操作是名称查找用户定义的标识符(函数、变量、…)，它遵循非常简单的规则，并从堆栈中清除本地变量。</p>
<p>范围:声明的标识符(标签、变量、函数、程序集)只在声明的块中可见(包括当前块的嵌套块)。访问跨功能边界的局部变量是不合法的，即使它们在范围内。阴影是不允许的。在声明之前不能访问本地变量，但是标签、函数和程序集可以。程序集是使用的特殊块，例如返回运行时代码或创建合约。在子程序集中不可见来自anouter程序集的标识符。</p>
<p>如果控制流经过一个块的末尾，那么将插入与该块中声明的局部变量数目匹配的pop指令。每当引用一个局部变量时，代码生成器就需要知道它在堆栈中的当前相对位置，因此需要跟踪当前所谓的堆栈高度。由于所有本地变量在块的末尾被删除，所以在块之前和之后的堆栈高度应该是相同的。如果不是这样，就会发出警告。</p>
<p>使用switch、for和函数，不使用跳转或jumpi手动就可以编写复杂的代码。这使得分析控制流更容易，这允许改进的形式验证和优化。<code class="docutils literal"><span class="pre">switch</span></code><code class="docutils literal"><span class="pre">for</span></code><code class="docutils literal"><span class="pre">jump</span></code><code class="docutils literal"><span class="pre">jumpi</span></code></p>
<p>此外，如果允许手动跳转，计算堆栈高度相当复杂。堆栈上所有本地变量的位置都需要被知道，否则，在一个块的末尾的堆栈中，对局部变量的引用或对局部变量的自动删除都将正常工作。</p>
<p>例子:</p>
<p>我们将遵循从Solidity到assembly的示例编译。我们考虑以下固体程序的运行时字节码:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">x</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
      <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">y</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>将产生以下大会:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">{</span>
  <span class="nx">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">)</span> <span class="c1">// store the "free memory pointer"</span>
  <span class="c1">// function dispatcher</span>
  <span class="kr">switch</span> <span class="nx">div</span><span class="p">(</span><span class="nx">calldataload</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="nx">exp</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">226</span><span class="p">))</span>
  <span class="kr">case</span> <span class="mh">0xb3de648b</span> <span class="p">{</span>
    <span class="kr">let</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">calldataload</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
    <span class="kr">let</span> <span class="nx">ret</span> <span class="o">:=</span> <span class="nx">$allocate</span><span class="p">(</span><span class="mh">0x20</span><span class="p">)</span>
    <span class="nx">mstore</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="nx">r</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="nx">ret</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="kr">default</span> <span class="p">{</span> <span class="nb">revert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
  <span class="c1">// memory allocator</span>
  <span class="kd">function</span> <span class="nx">$allocate</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">pos</span> <span class="p">{</span>
    <span class="nx">pos</span> <span class="o">:=</span> <span class="nx">mload</span><span class="p">(</span><span class="mh">0x40</span><span class="p">)</span>
    <span class="nx">mstore</span><span class="p">(</span><span class="mh">0x40</span><span class="p">,</span> <span class="nx">add</span><span class="p">(</span><span class="nx">pos</span><span class="p">,</span> <span class="nx">size</span><span class="p">))</span>
  <span class="p">}</span>
  <span class="c1">// the contract function</span>
  <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">y</span> <span class="p">{</span>
    <span class="nx">y</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="p">{</span> <span class="kr">let</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span> <span class="p">}</span> <span class="nx">lt</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span> <span class="p">{</span>
      <span class="nx">y</span> <span class="o">:=</span> <span class="nx">mul</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="assembly-grammar">
<h5>Assembly Grammar<a class="headerlink" href="#assembly-grammar" title="Permalink to this headline">¶</a></h5>
<p>解析器的任务如下:</p>
<ul class="simple">
<li>Turn the byte stream into a token stream, discarding C++-style comments
(a special comment exists for source references, but we will not explain it here).</li>
<li>Turn the token stream into an AST according to the grammar below</li>
<li>Register identifiers with the block they are defined in (annotation to the
AST node) and note from which point on, variables can be accessed.</li>
</ul>
<p>汇编lexer遵循一个由Solidity本身定义的词。</p>
<p>空白用于分隔令牌，它由字符空间、制表符和换行符组成。注释是常规的JavaScript/ c++注释，其解释方式与空格相同。</p>
<p>语法:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">AssemblyBlock</span> <span class="o">=</span> <span class="s1">'{'</span> <span class="nx">AssemblyItem</span><span class="o">*</span> <span class="s1">'}'</span>
<span class="nx">AssemblyItem</span> <span class="o">=</span>
    <span class="nx">Identifier</span> <span class="o">|</span>
    <span class="nx">AssemblyBlock</span> <span class="o">|</span>
    <span class="nx">AssemblyExpression</span> <span class="o">|</span>
    <span class="nx">AssemblyLocalDefinition</span> <span class="o">|</span>
    <span class="nx">AssemblyAssignment</span> <span class="o">|</span>
    <span class="nx">AssemblyStackAssignment</span> <span class="o">|</span>
    <span class="nx">LabelDefinition</span> <span class="o">|</span>
    <span class="nx">AssemblyIf</span> <span class="o">|</span>
    <span class="nx">AssemblySwitch</span> <span class="o">|</span>
    <span class="nx">AssemblyFunctionDefinition</span> <span class="o">|</span>
    <span class="nx">AssemblyFor</span> <span class="o">|</span>
    <span class="s1">'break'</span> <span class="o">|</span>
    <span class="s1">'continue'</span> <span class="o">|</span>
    <span class="nx">SubAssembly</span>
<span class="nx">AssemblyExpression</span> <span class="o">=</span> <span class="nx">AssemblyCall</span> <span class="o">|</span> <span class="nx">Identifier</span> <span class="o">|</span> <span class="nx">AssemblyLiteral</span>
<span class="nx">AssemblyLiteral</span> <span class="o">=</span> <span class="nx">NumberLiteral</span> <span class="o">|</span> <span class="nx">StringLiteral</span> <span class="o">|</span> <span class="nx">HexLiteral</span>
<span class="nx">Identifier</span> <span class="o">=</span> <span class="p">[</span><span class="nx">a</span><span class="o">-</span><span class="nx">zA</span><span class="o">-</span><span class="nx">Z_$</span><span class="p">]</span> <span class="p">[</span><span class="nx">a</span><span class="o">-</span><span class="nx">zA</span><span class="o">-</span><span class="nx">Z_0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">*</span>
<span class="nx">AssemblyCall</span> <span class="o">=</span> <span class="nx">Identifier</span> <span class="s1">'('</span> <span class="p">(</span> <span class="nx">AssemblyExpression</span> <span class="p">(</span> <span class="s1">','</span> <span class="nx">AssemblyExpression</span> <span class="p">)</span><span class="o">*</span> <span class="p">)</span><span class="o">?</span> <span class="s1">')'</span>
<span class="nx">AssemblyLocalDefinition</span> <span class="o">=</span> <span class="s1">'let'</span> <span class="nx">IdentifierOrList</span> <span class="p">(</span> <span class="s1">':='</span> <span class="nx">AssemblyExpression</span> <span class="p">)</span><span class="o">?</span>
<span class="nx">AssemblyAssignment</span> <span class="o">=</span> <span class="nx">IdentifierOrList</span> <span class="s1">':='</span> <span class="nx">AssemblyExpression</span>
<span class="nx">IdentifierOrList</span> <span class="o">=</span> <span class="nx">Identifier</span> <span class="o">|</span> <span class="s1">'('</span> <span class="nx">IdentifierList</span> <span class="s1">')'</span>
<span class="nx">IdentifierList</span> <span class="o">=</span> <span class="nx">Identifier</span> <span class="p">(</span> <span class="s1">','</span> <span class="nx">Identifier</span><span class="p">)</span><span class="o">*</span>
<span class="nx">AssemblyStackAssignment</span> <span class="o">=</span> <span class="s1">'=:'</span> <span class="nx">Identifier</span>
<span class="nx">LabelDefinition</span> <span class="o">=</span> <span class="nx">Identifier</span> <span class="s1">':'</span>
<span class="nx">AssemblyIf</span> <span class="o">=</span> <span class="s1">'if'</span> <span class="nx">AssemblyExpression</span> <span class="nx">AssemblyBlock</span>
<span class="nx">AssemblySwitch</span> <span class="o">=</span> <span class="s1">'switch'</span> <span class="nx">AssemblyExpression</span> <span class="nx">AssemblyCase</span><span class="o">*</span>
    <span class="p">(</span> <span class="s1">'default'</span> <span class="nx">AssemblyBlock</span> <span class="p">)</span><span class="o">?</span>
<span class="nx">AssemblyCase</span> <span class="o">=</span> <span class="s1">'case'</span> <span class="nx">AssemblyExpression</span> <span class="nx">AssemblyBlock</span>
<span class="nx">AssemblyFunctionDefinition</span> <span class="o">=</span> <span class="s1">'function'</span> <span class="nx">Identifier</span> <span class="s1">'('</span> <span class="nx">IdentifierList</span><span class="o">?</span> <span class="s1">')'</span>
    <span class="p">(</span> <span class="s1">'-&gt;'</span> <span class="s1">'('</span> <span class="nx">IdentifierList</span> <span class="s1">')'</span> <span class="p">)</span><span class="o">?</span> <span class="nx">AssemblyBlock</span>
<span class="nx">AssemblyFor</span> <span class="o">=</span> <span class="s1">'for'</span> <span class="p">(</span> <span class="nx">AssemblyBlock</span> <span class="o">|</span> <span class="nx">AssemblyExpression</span> <span class="p">)</span>
    <span class="nx">AssemblyExpression</span> <span class="p">(</span> <span class="nx">AssemblyBlock</span> <span class="o">|</span> <span class="nx">AssemblyExpression</span> <span class="p">)</span> <span class="nx">AssemblyBlock</span>
<span class="nx">SubAssembly</span> <span class="o">=</span> <span class="s1">'assembly'</span> <span class="nx">Identifier</span> <span class="nx">AssemblyBlock</span>
<span class="nx">NumberLiteral</span> <span class="o">=</span> <span class="nx">HexNumber</span> <span class="o">|</span> <span class="nx">DecimalNumber</span>
<span class="nx">HexLiteral</span> <span class="o">=</span> <span class="s1">'hex'</span> <span class="p">(</span><span class="s1">'"'</span> <span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="nx">a</span><span class="o">-</span><span class="nx">fA</span><span class="o">-</span><span class="nx">F</span><span class="p">]{</span><span class="mi">2</span><span class="p">})</span><span class="o">*</span> <span class="s1">'"'</span> <span class="o">|</span> <span class="s1">'\''</span> <span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="nx">a</span><span class="o">-</span><span class="nx">fA</span><span class="o">-</span><span class="nx">F</span><span class="p">]{</span><span class="mi">2</span><span class="p">})</span><span class="o">*</span> <span class="s1">'\''</span><span class="p">)</span>
<span class="nx">StringLiteral</span> <span class="o">=</span> <span class="s1">'"'</span> <span class="p">([</span><span class="o">^</span><span class="s2">"\r\n\\] | '\\' .)* '"</span><span class="s1">'</span>
<span class="s1">HexNumber = '</span><span class="mi">0</span><span class="nx">x</span><span class="err">'</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="nx">a</span><span class="o">-</span><span class="nx">fA</span><span class="o">-</span><span class="nx">F</span><span class="p">]</span><span class="o">+</span>
<span class="nx">DecimalNumber</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-miscellaneous"></span><div class="section" id="miscellaneous">
<h3>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h3>
<div class="section" id="layout-of-state-variables-in-storage">
<span id="index-0"></span><h4>Layout of State Variables in Storage<a class="headerlink" href="#layout-of-state-variables-in-storage" title="Permalink to this headline">¶</a></h4>
<p>静态大小的变量(除了映射和动态大小的数组类型之外的所有变量)都是从0位置开始的连续存储。如果可能的话，多个需要小于32字节的条目将被打包到一个存储槽中，根据以下规则:<code class="docutils literal"><span class="pre">0</span></code></p>
<ul class="simple">
<li>The first item in a storage slot is stored lower-order aligned.</li>
<li>Elementary types use only that many bytes that are necessary to store them.</li>
<li>If an elementary type does not fit the remaining part of a storage slot, it is moved to the next storage slot.</li>
<li>Structs and array data always start a new slot and occupy whole slots (but items inside a struct or array are packed tightly according to these rules).</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>当使用小于32字节的元素时，您的合约的气体使用量可能会更高。这是因为EVM一次运行32个字节。因此，如果元素小于该元素，那么EVM必须使用更多的操作，以便将元素的大小从32字节减小到所需的大小。</p>
<p>如果您处理的是存储的值，那么使用缩减大小的参数是很有用的，因为编译器会将多个元素打包到一个存储槽中，因此，组合模拟将读取或写入到单个操作中。在处理函数参数或memoryvalues时，没有内在的好处，因为编译器没有打包这些值。</p>
<p class="last">最后，为了让EVM对此进行优化，请确保您尝试订购您的存储变量和结构成员，这样它们就可以紧密地打包。例如，按照uint128、uint128、uint256、uint256和uint128的顺序声明您的存储变量，因为前者只占用两个存储槽，而后者将占用三个存储空间。<code class="docutils literal"><span class="pre">struct</span></code><code class="docutils literal"><span class="pre">uint128,</span> <span class="pre">uint128,</span> <span class="pre">uint256</span></code><code class="docutils literal"><span class="pre">uint128,</span> <span class="pre">uint256,</span> <span class="pre">uint128</span></code></p>
</div>
<p>结构和数组的元素相互存储，就像它们被显式地给出一样。</p>
<p>由于其不可预测的大小，映射和动态大小的数组类型使用Keccak-256 hash计算来查找值或数组数据的起始位置。这些起始位置总是完整的堆栈槽。</p>
<p>根据上述规则，映射或动态数组itselfoccupies(未填充的)在某个位置上的存储位置(或递归地将此规则用于映射到映射或数组数组)。对于动态数组，这个槽存储数组中元素的数量(字节数组和字符串是一个例外，参见下面)。对于映射，槽是未使用的(但它是必需的，这样两个相等的映射会使用不同的散列分布)。数组数据位于keccak256(p)，对应于映射keyk的值位于keccak256(k)。p)。是连接。如果该值再次为初等类型，则通过添加keccak256(k)的偏移量找到位置。p)。<code class="docutils literal"><span class="pre">p</span></code><code class="docutils literal"><span class="pre">keccak256(p)</span></code><code class="docutils literal"><span class="pre">k</span></code><code class="docutils literal"><span class="pre">keccak256(k</span> <span class="pre">.</span> <span class="pre">p)</span></code><code class="docutils literal"><span class="pre">.</span></code><code class="docutils literal"><span class="pre">keccak256(k</span> <span class="pre">.</span> <span class="pre">p)</span></code></p>
<p><code class="docutils literal"><span class="pre">bytes</span></code>字节和字符串将它们的数据存储在相同的槽中，如果它们是短的，那么它们的长度也是存储的。特别是:如果数据最多是31个字节，那么它将存储在更高的字节(左对齐)和最低的字节存储长度* 2中。如果它较长，主槽存储长度* 2 + 1，并且数据存储在keccak256(槽)中。<code class="docutils literal"><span class="pre">string</span></code><code class="docutils literal"><span class="pre">31</span></code><code class="docutils literal"><span class="pre">length</span> <span class="pre">*</span> <span class="pre">2</span></code><code class="docutils literal"><span class="pre">length</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1</span></code><code class="docutils literal"><span class="pre">keccak256(slot)</span></code></p>
<p>因此，对于下面的合约片段:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
  <span class="kd">struct</span> <span class="nx">s</span> <span class="p">{</span> <span class="kt">uint</span> <span class="nx">a</span><span class="p">;</span> <span class="kt">uint</span> <span class="nx">b</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">uint</span> <span class="nx">x</span><span class="p">;</span>
  <span class="k">mapping</span><span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="k">mapping</span><span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="nx">s</span><span class="p">))</span> <span class="nx">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>数据的位置[4][9]。b在keccak256(uint256(9))。keccak256(uint256(4)。uint256(1)))+ 1。<code class="docutils literal"><span class="pre">data[4][9].b</span></code><code class="docutils literal"><span class="pre">keccak256(uint256(9)</span> <span class="pre">.</span> <span class="pre">keccak256(uint256(4)</span> <span class="pre">.</span> <span class="pre">uint256(1)))</span> <span class="pre">+</span> <span class="pre">1</span></code></p>
</div>
<div class="section" id="layout-in-memory">
<h4>Layout in Memory<a class="headerlink" href="#layout-in-memory" title="Permalink to this headline">¶</a></h4>
<p>Solidity保留4个32字节的槽:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">0x00</span></code> - <code class="docutils literal"><span class="pre">0x3f</span></code>: scratch space for hashing methods</li>
<li><code class="docutils literal"><span class="pre">0x40</span></code> - <code class="docutils literal"><span class="pre">0x5f</span></code>: currently allocated memory size (aka. free memory pointer)</li>
<li><code class="docutils literal"><span class="pre">0x60</span></code> - <code class="docutils literal"><span class="pre">0x7f</span></code>: zero slot</li>
</ul>
<p>在语句之间可以使用Scratch空间。在内联汇编)。zero slotis用作动态内存数组的初始值，不应该被写入到(最初的空闲内存指针指向0x80)。<code class="docutils literal"><span class="pre">0x80</span></code></p>
<p>Solidity总是将新对象放置在空闲内存指针中，而内存永远不会被释放(这在将来可能会发生变化)。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">在Solidity中有一些操作需要一个大于64字节的临时内存区域，因此不适合在scratch空间中使用。它们将被放置在空闲内存指向的地方，但是在它们的生命周期短的情况下，指针不会被更新。记忆可能是零，也可能不是。正因为如此，我们不应该期望空闲内存被归零。</p>
</div>
</div>
<div class="section" id="layout-of-call-data">
<h4>Layout of Call Data<a class="headerlink" href="#layout-of-call-data" title="Permalink to this headline">¶</a></h4>
<p>当一个Solidity合约被部署并且当它被从anaccount调用时，输入数据被假定为在ABIspecification中的格式。ABI规范要求将参数填充为32字节的倍数。内部函数调用使用不同的约定。<a class="reference internal" href="index.html#abi"><span class="std std-ref">the ABI
specification</span></a></p>
</div>
<div class="section" id="internals-cleaning-up-variables">
<h4>Internals - Cleaning Up Variables<a class="headerlink" href="#internals-cleaning-up-variables" title="Permalink to this headline">¶</a></h4>
<p>当一个值小于256位时，在某些情况下，剩余的bitsmust将被清除。Solidity编译器的目的是在任何操作之前清除这些剩余的部分，而这些操作可能会受到剩余部分中潜在的垃圾的不利影响。例如，在将值写入内存之前，剩余的部分需要清除，因为内存内容可以用于计算或作为消息调用的数据发送。同样地，在存储中设置一个值，其余的部分需要被清除，否则就可以观察到其含混的值。</p>
<p>另一方面，如果不影响立即执行的操作，我们就不清理。例如，因为任何非零值都是由JUMPI指令所考虑的，所以我们在将布尔值用作JUMPI的条件之前并没有清除。<code class="docutils literal"><span class="pre">true</span></code><code class="docutils literal"><span class="pre">JUMPI</span></code><code class="docutils literal"><span class="pre">JUMPI</span></code></p>
<p>除了上面的设计原则之外，当它被加载到堆栈上时，Solidity编译器将输入数据。</p>
<p>不同类型的清理无效值有不同的规则:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%"/>
<col width="31%"/>
<col width="39%"/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">Valid Values</th>
<th class="head">Invalid Values Mean</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>enum of n
members</td>
<td>0 until n - 1</td>
<td>exception</td>
</tr>
<tr class="row-odd"><td>bool</td>
<td>0 or 1</td>
<td>1</td>
</tr>
<tr class="row-even"><td>signed integers</td>
<td>sign-extended
word</td>
<td>currently silently
wraps; in the
future exceptions
will be thrown</td>
</tr>
<tr class="row-odd"><td>unsigned
integers</td>
<td>higher bits
zeroed</td>
<td>currently silently
wraps; in the
future exceptions
will be thrown</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="internals-the-optimizer">
<span id="index-1"></span><h4>Internals - The Optimizer<a class="headerlink" href="#internals-the-optimizer" title="Permalink to this headline">¶</a></h4>
<p>Solidity优化器在程序集上进行操作，因此它可以也可以被其他语言使用。它将指令序列分成跳跃和跳跃的基本块。在这些块中，对指令进行分析，对堆栈进行任何修改，将内存或存储记录为一个表达式，该表达式由一个指令和一个参数列表组成，这些参数实际上是指向其他表达式的指针。现在的主要思想是找到总是相等的表达式(在每个输入上)并将它们组合成一个表达式类。优化器首先尝试在已知表达式的列表中查找每个新表达式。如果这并不工作,根据规则表达式简化像常数+常数= sum_of_constants或X * 1 = X,因为这样做是递归地,我们也可以应用后者规则如果第二个因素是一个更复杂的表达式,我们知道它总是评估。修改存储和内存位置必须消除知识存储和内存位置不知道是不同的:如果我们第一次写位置x和y位置和两个输入变量,第二个可以覆盖第一个,我们不知道我们写后存储在x到y。另一方面,如果一个简化表达式的x - y等于一个非零常数,我们知道我们可以让我们的知识存储在x。<code class="docutils literal"><span class="pre">JUMPs</span></code><code class="docutils literal"><span class="pre">JUMPDESTs</span></code><code class="docutils literal"><span class="pre">constant</span> <span class="pre">+</span> <span class="pre">constant</span> <span class="pre">=</span> <span class="pre">sum_of_constants</span></code><code class="docutils literal"><span class="pre">X</span> <span class="pre">*</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">X</span></code></p>
<p>在这个过程的最后，我们知道哪些表达式必须在堆栈的末尾，并有一个对内存和存储的修改列表。这些信息与基本块一起存储，并用于链接它们。此外，关于堆栈、存储和内存配置的知识将被转发到下一个块(s)。如果我们知道所有跳转和JUMPI指令的目标，我们就可以构建一个完整的程序控制流图。如果只有一个目标我们不知道(这可能发生在原则上，跳转目标可以从输入计算)，我们必须消除所有关于块输入状态的知识，因为它可能是未知跳转的目标。如果一个JUMPI被发现它的条件等于一个常数，它就被转化为一个无条件的跳跃。<code class="docutils literal"><span class="pre">JUMP</span></code><code class="docutils literal"><span class="pre">JUMPI</span></code><code class="docutils literal"><span class="pre">JUMP</span></code><code class="docutils literal"><span class="pre">JUMPI</span></code></p>
<p>作为最后一步，每个块中的代码将完全重新生成。一个依赖关系图是由堆栈末端的堆栈上的表达式创建的，而不是这个图的每一个操作实际上都被删除了。现在，生成的代码将对内存和存储的修改应用于原始代码中所做的顺序(不需要进行修改)，最后生成所需的所有值，这些值都在正确的位置上。</p>
<p>这些步骤应用于每个基本块，如果新生成的代码更小，则用作替换。如果一个基本块在一个JUMPI中被分割，并且在分析过程中，条件计算为一个常量，则根据常量的值来替换JUMPI，因此代码就像这样。<code class="docutils literal"><span class="pre">JUMPI</span></code><code class="docutils literal"><span class="pre">JUMPI</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="nx">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">x</span><span class="p">]</span> <span class="o">!=</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">else</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>是否简化为代码，也可以从?</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">data</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>尽管指令包含了一开始的跳跃。</p>
</div>
<div class="section" id="source-mappings">
<span id="index-2"></span><h4>Source Mappings<a class="headerlink" href="#source-mappings" title="Permalink to this headline">¶</a></h4>
<p>作为AST输出的一部分，编译器提供了由AST中各自的节点表示的sourcecode的范围，这可以用于各种各样的用途，包括基于AST的静态分析工具和突出本地变量及其用途的调试工具。</p>
<p>此外，编译器还可以从生成该指令的源代码中的字节码生成一个映射。这对于在字节码级别上操作的静态分析工具来说是非常重要的，并且可以在调试器中显示当前位置并在调试器中进行断点处理。</p>
<p>这两种源映射都使用整数标识符来引用源文件。这些是通常被称为“sourceList”的源文件列表中的常规数组索引，它是组合json和json / npm编译器输出的一部分。<code class="docutils literal"><span class="pre">"sourceList"</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在没有与任何特定源文件相关联的指令的情况下，源映射指定一个-1的整数标识符。这可能发生在由编译器生成的内联汇编语句中产生的forbytecode节。<code class="docutils literal"><span class="pre">-1</span></code></p>
</div>
<p>AST内部的源映射使用以下符号:</p>
<p><code class="docutils literal"><span class="pre">s:l:f</span></code></p>
<p>其中s是源文件中范围开始的字节偏移量，l是源范围的长度，而f是上面提到的sourceindex。<code class="docutils literal"><span class="pre">s</span></code><code class="docutils literal"><span class="pre">l</span></code><code class="docutils literal"><span class="pre">f</span></code></p>
<p>字节码的源映射中的编码更为复杂:它是一个s:l:f:j的列表;每个元素都对应一个指令，即不能使用字节数，但必须使用指令偏移量(push指令比单个字节长)。字段s、l和f是如上所述的，j可以是eitheri, o或-表示跳转指令是否为函数，从函数返回，或者是作为循环的一部分的常规跳转。<code class="docutils literal"><span class="pre">s:l:f:j</span></code><code class="docutils literal"><span class="pre">;</span></code><code class="docutils literal"><span class="pre">s</span></code><code class="docutils literal"><span class="pre">l</span></code><code class="docutils literal"><span class="pre">f</span></code><code class="docutils literal"><span class="pre">j</span></code><code class="docutils literal"><span class="pre">i</span></code><code class="docutils literal"><span class="pre">o</span></code><code class="docutils literal"><span class="pre">-</span></code></p>
<p>为了压缩这些源映射，尤其是字节码，使用以下规则:</p>
<blockquote>
<div><ul class="simple">
<li>If a field is empty, the value of the preceding element is used.</li>
<li>If a <code class="docutils literal"><span class="pre">:</span></code> is missing, all following fields are considered empty.</li>
</ul>
</div></blockquote>
<p>这意味着下面的源映射表示相同的信息:</p>
<p><code class="docutils literal"><span class="pre">1:2:1;1:9:1;2:1:2;2:1:2;2:1:2</span></code></p>
<p><code class="docutils literal"><span class="pre">1:2:1;:9;2:1:2;;</span></code></p>
</div>
<div class="section" id="tips-and-tricks">
<h4>Tips and Tricks<a class="headerlink" href="#tips-and-tricks" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Use <code class="docutils literal"><span class="pre">delete</span></code> on arrays to delete all its elements.</li>
<li>Use shorter types for struct elements and sort them such that short types are grouped together. This can lower the gas costs as multiple <code class="docutils literal"><span class="pre">SSTORE</span></code> operations might be combined into a single (<code class="docutils literal"><span class="pre">SSTORE</span></code> costs 5000 or 20000 gas, so this is what you want to optimise). Use the gas price estimator (with optimiser enabled) to check!</li>
<li>Make your state variables public - the compiler will create <a class="reference internal" href="index.html#visibility-and-getters"><span class="std std-ref">getters</span></a> for you automatically.</li>
<li>If you end up checking conditions on input or state a lot at the beginning of your functions, try using <a class="reference internal" href="index.html#modifiers"><span class="std std-ref">Function Modifiers</span></a>.</li>
<li>If your contract has a function called <code class="docutils literal"><span class="pre">send</span></code> but you want to use the built-in send-function, use <code class="docutils literal"><span class="pre">address(contractVariable).send(amount)</span></code>.</li>
<li>Initialize storage structs with a single assignment: <code class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">MyStruct({a:</span> <span class="pre">1,</span> <span class="pre">b:</span> <span class="pre">2});</span></code></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">如果存储结构具有紧密的填充属性，则将其初始化为单独的赋值:x。= 1;x。b = 2;。这样，优化器就更容易一次更新存储，从而降低了分配的成本。<code class="docutils literal"><span class="pre">x.a</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">x.b</span> <span class="pre">=</span> <span class="pre">2;</span></code></p>
</div>
</div>
<div class="section" id="cheatsheet">
<h4>Cheatsheet<a class="headerlink" href="#cheatsheet" title="Permalink to this headline">¶</a></h4>
<div class="section" id="order-of-precedence-of-operators">
<span id="order"></span><span id="index-3"></span><h5>Order of Precedence of Operators<a class="headerlink" href="#order-of-precedence-of-operators" title="Permalink to this headline">¶</a></h5>
<p>下面是操作符的优先顺序，按评价顺序列出。</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%"/>
<col width="40%"/>
<col width="47%"/>
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Precedence</th>
<th class="head">Description</th>
<th class="head">Operator</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="6"><em>1</em></td>
<td>Postfix increment and decrement</td>
<td><code class="docutils literal"><span class="pre">++</span></code>, <code class="docutils literal"><span class="pre">--</span></code></td>
</tr>
<tr class="row-odd"><td>New expression</td>
<td><code class="docutils literal"><span class="pre">new</span> <span class="pre">&lt;typename&gt;</span></code></td>
</tr>
<tr class="row-even"><td>Array subscripting</td>
<td><code class="docutils literal"><span class="pre">&lt;array&gt;[&lt;index&gt;]</span></code></td>
</tr>
<tr class="row-odd"><td>Member access</td>
<td><code class="docutils literal"><span class="pre">&lt;object&gt;.&lt;member&gt;</span></code></td>
</tr>
<tr class="row-even"><td>Function-like call</td>
<td><code class="docutils literal"><span class="pre">&lt;func&gt;(&lt;args...&gt;)</span></code></td>
</tr>
<tr class="row-odd"><td>Parentheses</td>
<td><code class="docutils literal"><span class="pre">(&lt;statement&gt;)</span></code></td>
</tr>
<tr class="row-even"><td rowspan="5"><em>2</em></td>
<td>Prefix increment and decrement</td>
<td><code class="docutils literal"><span class="pre">++</span></code>, <code class="docutils literal"><span class="pre">--</span></code></td>
</tr>
<tr class="row-odd"><td>Unary plus and minus</td>
<td><code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code></td>
</tr>
<tr class="row-even"><td>Unary operations</td>
<td><code class="docutils literal"><span class="pre">delete</span></code></td>
</tr>
<tr class="row-odd"><td>Logical NOT</td>
<td><code class="docutils literal"><span class="pre">!</span></code></td>
</tr>
<tr class="row-even"><td>Bitwise NOT</td>
<td><code class="docutils literal"><span class="pre">~</span></code></td>
</tr>
<tr class="row-odd"><td><em>3</em></td>
<td>Exponentiation</td>
<td><code class="docutils literal"><span class="pre">**</span></code></td>
</tr>
<tr class="row-even"><td><em>4</em></td>
<td>Multiplication, division and modulo</td>
<td><code class="docutils literal"><span class="pre">*</span></code>, <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">%</span></code></td>
</tr>
<tr class="row-odd"><td><em>5</em></td>
<td>Addition and subtraction</td>
<td><code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code></td>
</tr>
<tr class="row-even"><td><em>6</em></td>
<td>Bitwise shift operators</td>
<td><code class="docutils literal"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;&gt;</span></code></td>
</tr>
<tr class="row-odd"><td><em>7</em></td>
<td>Bitwise AND</td>
<td><code class="docutils literal"><span class="pre">&amp;</span></code></td>
</tr>
<tr class="row-even"><td><em>8</em></td>
<td>Bitwise XOR</td>
<td><code class="docutils literal"><span class="pre">^</span></code></td>
</tr>
<tr class="row-odd"><td><em>9</em></td>
<td>Bitwise OR</td>
<td><code class="docutils literal"><span class="pre">|</span></code></td>
</tr>
<tr class="row-even"><td><em>10</em></td>
<td>Inequality operators</td>
<td><code class="docutils literal"><span class="pre">&lt;</span></code>, <code class="docutils literal"><span class="pre">&gt;</span></code>, <code class="docutils literal"><span class="pre">&lt;=</span></code>, <code class="docutils literal"><span class="pre">&gt;=</span></code></td>
</tr>
<tr class="row-odd"><td><em>11</em></td>
<td>Equality operators</td>
<td><code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">!=</span></code></td>
</tr>
<tr class="row-even"><td><em>12</em></td>
<td>Logical AND</td>
<td><code class="docutils literal"><span class="pre">&amp;&amp;</span></code></td>
</tr>
<tr class="row-odd"><td><em>13</em></td>
<td>Logical OR</td>
<td><code class="docutils literal"><span class="pre">||</span></code></td>
</tr>
<tr class="row-even"><td><em>14</em></td>
<td>Ternary operator</td>
<td><code class="docutils literal"><span class="pre">&lt;conditional&gt;</span> <span class="pre">?</span> <span class="pre">&lt;if-true&gt;</span> <span class="pre">:</span> <span class="pre">&lt;if-false&gt;</span></code></td>
</tr>
<tr class="row-odd"><td><em>15</em></td>
<td>Assignment operators</td>
<td><code class="docutils literal"><span class="pre">=</span></code>, <code class="docutils literal"><span class="pre">|=</span></code>, <code class="docutils literal"><span class="pre">^=</span></code>, <code class="docutils literal"><span class="pre">&amp;=</span></code>, <code class="docutils literal"><span class="pre">&lt;&lt;=</span></code>,
<code class="docutils literal"><span class="pre">&gt;&gt;=</span></code>, <code class="docutils literal"><span class="pre">+=</span></code>, <code class="docutils literal"><span class="pre">-=</span></code>, <code class="docutils literal"><span class="pre">*=</span></code>, <code class="docutils literal"><span class="pre">/=</span></code>,
<code class="docutils literal"><span class="pre">%=</span></code></td>
</tr>
<tr class="row-even"><td><em>16</em></td>
<td>Comma operator</td>
<td><code class="docutils literal"><span class="pre">,</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="global-variables">
<span id="index-4"></span><h5>Global Variables<a class="headerlink" href="#global-variables" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">abi.encode(...)</span> <span class="pre">returns</span> <span class="pre">(bytes)</span></code>: <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI</span></a>-encodes the given arguments</li>
<li><code class="docutils literal"><span class="pre">abi.encodePacked(...)</span> <span class="pre">returns</span> <span class="pre">(bytes)</span></code>: Performes <a class="reference internal" href="index.html#abi-packed-mode"><span class="std std-ref">packed encoding</span></a> of the given arguments</li>
<li><dl class="first docutils">
<dt><code class="docutils literal"><span class="pre">abi.encodeWithSelector(bytes4</span> <span class="pre">selector,</span> <span class="pre">...)</span> <span class="pre">returns</span> <span class="pre">(bytes)</span></code>: <a class="reference internal" href="index.html#abi"><span class="std std-ref">ABI</span></a>-encodes the given arguments</dt>
<dd>starting from the second and prepends the given four-byte selector</dd>
</dl>
</li>
<li><code class="docutils literal"><span class="pre">abi.encodeWithSignature(string</span> <span class="pre">signature,</span> <span class="pre">...)</span> <span class="pre">returns</span> <span class="pre">(bytes)</span></code>: Equivalent to <code class="docutils literal"><span class="pre">abi.encodeWithSelector(bytes4(keccak256(signature),</span> <span class="pre">...)`</span></code></li>
<li><code class="docutils literal"><span class="pre">block.blockhash(uint</span> <span class="pre">blockNumber)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>: hash of the given block - only works for 256 most recent, excluding current, blocks - deprecated in version 0.4.22 and replaced by <code class="docutils literal"><span class="pre">blockhash(uint</span> <span class="pre">blockNumber)</span></code>.</li>
<li><code class="docutils literal"><span class="pre">block.coinbase</span></code> (<code class="docutils literal"><span class="pre">address</span></code>): current block miner’s address</li>
<li><code class="docutils literal"><span class="pre">block.difficulty</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): current block difficulty</li>
<li><code class="docutils literal"><span class="pre">block.gaslimit</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): current block gaslimit</li>
<li><code class="docutils literal"><span class="pre">block.number</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): current block number</li>
<li><code class="docutils literal"><span class="pre">block.timestamp</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): current block timestamp</li>
<li><code class="docutils literal"><span class="pre">gasleft()</span> <span class="pre">returns</span> <span class="pre">(uint256)</span></code>: remaining gas</li>
<li><code class="docutils literal"><span class="pre">msg.data</span></code> (<code class="docutils literal"><span class="pre">bytes</span></code>): complete calldata</li>
<li><code class="docutils literal"><span class="pre">msg.gas</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): remaining gas - deprecated in version 0.4.21 and to be replaced by <code class="docutils literal"><span class="pre">gasleft()</span></code></li>
<li><code class="docutils literal"><span class="pre">msg.sender</span></code> (<code class="docutils literal"><span class="pre">address</span></code>): sender of the message (current call)</li>
<li><code class="docutils literal"><span class="pre">msg.value</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): number of wei sent with the message</li>
<li><code class="docutils literal"><span class="pre">now</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): current block timestamp (alias for <code class="docutils literal"><span class="pre">block.timestamp</span></code>)</li>
<li><code class="docutils literal"><span class="pre">tx.gasprice</span></code> (<code class="docutils literal"><span class="pre">uint</span></code>): gas price of the transaction</li>
<li><code class="docutils literal"><span class="pre">tx.origin</span></code> (<code class="docutils literal"><span class="pre">address</span></code>): sender of the transaction (full call chain)</li>
<li><code class="docutils literal"><span class="pre">assert(bool</span> <span class="pre">condition)</span></code>: abort execution and revert state changes if condition is <code class="docutils literal"><span class="pre">false</span></code> (use for internal error)</li>
<li><code class="docutils literal"><span class="pre">require(bool</span> <span class="pre">condition)</span></code>: abort execution and revert state changes if condition is <code class="docutils literal"><span class="pre">false</span></code> (use for malformed input or error in external component)</li>
<li><code class="docutils literal"><span class="pre">require(bool</span> <span class="pre">condition,</span> <span class="pre">string</span> <span class="pre">message)</span></code>: abort execution and revert state changes if condition is <code class="docutils literal"><span class="pre">false</span></code> (use for malformed input or error in external component). Also provide error message.</li>
<li><code class="docutils literal"><span class="pre">revert()</span></code>: abort execution and revert state changes</li>
<li><code class="docutils literal"><span class="pre">revert(string</span> <span class="pre">message)</span></code>: abort execution and revert state changes providing an explanatory string</li>
<li><code class="docutils literal"><span class="pre">blockhash(uint</span> <span class="pre">blockNumber)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>: hash of the given block - only works for 256 most recent blocks</li>
<li><code class="docutils literal"><span class="pre">keccak256(...)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>: compute the Ethereum-SHA-3 (Keccak-256) hash of the <a class="reference internal" href="index.html#abi-packed-mode"><span class="std std-ref">(tightly packed) arguments</span></a></li>
<li><code class="docutils literal"><span class="pre">sha3(...)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>: an alias to <code class="docutils literal"><span class="pre">keccak256</span></code></li>
<li><code class="docutils literal"><span class="pre">sha256(...)</span> <span class="pre">returns</span> <span class="pre">(bytes32)</span></code>: compute the SHA-256 hash of the <a class="reference internal" href="index.html#abi-packed-mode"><span class="std std-ref">(tightly packed) arguments</span></a></li>
<li><code class="docutils literal"><span class="pre">ripemd160(...)</span> <span class="pre">returns</span> <span class="pre">(bytes20)</span></code>: compute the RIPEMD-160 hash of the <a class="reference internal" href="index.html#abi-packed-mode"><span class="std std-ref">(tightly packed) arguments</span></a></li>
<li><code class="docutils literal"><span class="pre">ecrecover(bytes32</span> <span class="pre">hash,</span> <span class="pre">uint8</span> <span class="pre">v,</span> <span class="pre">bytes32</span> <span class="pre">r,</span> <span class="pre">bytes32</span> <span class="pre">s)</span> <span class="pre">returns</span> <span class="pre">(address)</span></code>: recover address associated with the public key from elliptic curve signature, return zero on error</li>
<li><code class="docutils literal"><span class="pre">addmod(uint</span> <span class="pre">x,</span> <span class="pre">uint</span> <span class="pre">y,</span> <span class="pre">uint</span> <span class="pre">k)</span> <span class="pre">returns</span> <span class="pre">(uint)</span></code>: compute <code class="docutils literal"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">k</span></code> where the addition is performed with arbitrary precision and does not wrap around at <code class="docutils literal"><span class="pre">2**256</span></code>. Assert that <code class="docutils literal"><span class="pre">k</span> <span class="pre">!=</span> <span class="pre">0</span></code> starting from version 0.5.0.</li>
<li><code class="docutils literal"><span class="pre">mulmod(uint</span> <span class="pre">x,</span> <span class="pre">uint</span> <span class="pre">y,</span> <span class="pre">uint</span> <span class="pre">k)</span> <span class="pre">returns</span> <span class="pre">(uint)</span></code>: compute <code class="docutils literal"><span class="pre">(x</span> <span class="pre">*</span> <span class="pre">y)</span> <span class="pre">%</span> <span class="pre">k</span></code> where the multiplication is performed with arbitrary precision and does not wrap around at <code class="docutils literal"><span class="pre">2**256</span></code>. Assert that <code class="docutils literal"><span class="pre">k</span> <span class="pre">!=</span> <span class="pre">0</span></code> starting from version 0.5.0.</li>
<li><code class="docutils literal"><span class="pre">this</span></code> (current contract’s type): the current contract, explicitly convertible to <code class="docutils literal"><span class="pre">address</span></code></li>
<li><code class="docutils literal"><span class="pre">super</span></code>: the contract one level higher in the inheritance hierarchy</li>
<li><code class="docutils literal"><span class="pre">selfdestruct(address</span> <span class="pre">recipient)</span></code>: destroy the current contract, sending its funds to the given address</li>
<li><code class="docutils literal"><span class="pre">suicide(address</span> <span class="pre">recipient)</span></code>: a deprecated alias to <code class="docutils literal"><span class="pre">selfdestruct</span></code></li>
<li><code class="docutils literal"><span class="pre">&lt;address&gt;.balance</span></code> (<code class="docutils literal"><span class="pre">uint256</span></code>): balance of the <a class="reference internal" href="index.html#address"><span class="std std-ref">Address</span></a> in Wei</li>
<li><code class="docutils literal"><span class="pre">&lt;address&gt;.send(uint256</span> <span class="pre">amount)</span> <span class="pre">returns</span> <span class="pre">(bool)</span></code>: send given amount of Wei to <a class="reference internal" href="index.html#address"><span class="std std-ref">Address</span></a>, returns <code class="docutils literal"><span class="pre">false</span></code> on failure</li>
<li><code class="docutils literal"><span class="pre">&lt;address&gt;.transfer(uint256</span> <span class="pre">amount)</span></code>: send given amount of Wei to <a class="reference internal" href="index.html#address"><span class="std std-ref">Address</span></a>, throws on failure</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>不要依赖于块。时间戳，现在和blockhash作为一个随机性的来源，除非你知道你在做什么。<code class="docutils literal"><span class="pre">block.timestamp</span></code><code class="docutils literal"><span class="pre">now</span></code><code class="docutils literal"><span class="pre">blockhash</span></code></p>
<p>时间戳和块散列都可以在一定程度上受到矿商的影响。例如，采矿社区的坏行为者可以在选择的哈希上运行一个赌场支付函数，如果他们没有收到任何钱，就重新尝试不同的哈希。</p>
<p class="last">当前块时间戳必须严格大于最后一个块的时间戳，但唯一的保证是它将位于规范链中两个连续块的时间戳之间。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">由于可伸缩性的原因，所有块都不能使用块哈希。您只能访问最近256个块的散列，所有其他值都为零。</p>
</div>
</div>
<div class="section" id="function-visibility-specifiers">
<span id="index-5"></span><h5>Function Visibility Specifiers<a class="headerlink" href="#function-visibility-specifiers" title="Permalink to this headline">¶</a></h5>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">myFunction</span><span class="p">()</span> <span class="o">&lt;</span><span class="nx">visibility</span> <span class="nx">specifier</span><span class="o">&gt;</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">public</span></code>: visible externally and internally (creates a <a class="reference internal" href="index.html#getter-functions"><span class="std std-ref">getter function</span></a> for storage/state variables)</li>
<li><code class="docutils literal"><span class="pre">private</span></code>: only visible in the current contract</li>
<li><code class="docutils literal"><span class="pre">external</span></code>: only visible externally (only for functions) - i.e. can only be message-called (via <code class="docutils literal"><span class="pre">this.func</span></code>)</li>
<li><code class="docutils literal"><span class="pre">internal</span></code>: only visible internally</li>
</ul>
</div>
<div class="section" id="modifiers">
<span id="index-6"></span><h5>Modifiers<a class="headerlink" href="#modifiers" title="Permalink to this headline">¶</a></h5>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">pure</span></code> for functions: Disallows modification or access of state - this is not enforced yet.</li>
<li><code class="docutils literal"><span class="pre">view</span></code> for functions: Disallows modification of state - this is not enforced yet.</li>
<li><code class="docutils literal"><span class="pre">payable</span></code> for functions: Allows them to receive Ether together with a call.</li>
<li><code class="docutils literal"><span class="pre">constant</span></code> for state variables: Disallows assignment (except initialisation), does not occupy storage slot.</li>
<li><code class="docutils literal"><span class="pre">constant</span></code> for functions: Same as <code class="docutils literal"><span class="pre">view</span></code>.</li>
<li><code class="docutils literal"><span class="pre">anonymous</span></code> for events: Does not store event signature as topic.</li>
<li><code class="docutils literal"><span class="pre">indexed</span></code> for event parameters: Stores the parameter as topic.</li>
</ul>
</div>
<div class="section" id="reserved-keywords">
<h5>Reserved Keywords<a class="headerlink" href="#reserved-keywords" title="Permalink to this headline">¶</a></h5>
<p>这些关键字是保留的。它们将来可能成为语法的一部分:</p>
<p><code class="docutils literal"><span class="pre">abstract</span></code>抽象，后置，捕获，默认，final, in, inline, let, match, null,of, relocatable, static, switch, try, type, typeof。<code class="docutils literal"><span class="pre">after</span></code><code class="docutils literal"><span class="pre">case</span></code><code class="docutils literal"><span class="pre">catch</span></code><code class="docutils literal"><span class="pre">default</span></code><code class="docutils literal"><span class="pre">final</span></code><code class="docutils literal"><span class="pre">in</span></code><code class="docutils literal"><span class="pre">inline</span></code><code class="docutils literal"><span class="pre">let</span></code><code class="docutils literal"><span class="pre">match</span></code><code class="docutils literal"><span class="pre">null</span></code><code class="docutils literal"><span class="pre">of</span></code><code class="docutils literal"><span class="pre">relocatable</span></code><code class="docutils literal"><span class="pre">static</span></code><code class="docutils literal"><span class="pre">switch</span></code><code class="docutils literal"><span class="pre">try</span></code><code class="docutils literal"><span class="pre">type</span></code><code class="docutils literal"><span class="pre">typeof</span></code></p>
</div>
<div class="section" id="language-grammar">
<h5>Language Grammar<a class="headerlink" href="#language-grammar" title="Permalink to this headline">¶</a></h5>
<div class="highlight-none"><div class="highlight"><pre><span></span>SourceUnit = (PragmaDirective | ImportDirective | ContractDefinition)*

// Pragma actually parses anything up to the trailing ';' to be fully forward-compatible.
PragmaDirective = 'pragma' Identifier ([^;]+) ';'

ImportDirective = 'import' StringLiteral ('as' Identifier)? ';'
        | 'import' ('*' | Identifier) ('as' Identifier)? 'from' StringLiteral ';'
        | 'import' '{' Identifier ('as' Identifier)? ( ',' Identifier ('as' Identifier)? )* '}' 'from' StringLiteral ';'

ContractDefinition = ( 'contract' | 'library' | 'interface' ) Identifier
                     ( 'is' InheritanceSpecifier (',' InheritanceSpecifier )* )?
                     '{' ContractPart* '}'

ContractPart = StateVariableDeclaration | UsingForDeclaration
             | StructDefinition | ModifierDefinition | FunctionDefinition | EventDefinition | EnumDefinition

InheritanceSpecifier = UserDefinedTypeName ( '(' Expression ( ',' Expression )* ')' )?

StateVariableDeclaration = TypeName ( 'public' | 'internal' | 'private' | 'constant' )* Identifier ('=' Expression)? ';'
UsingForDeclaration = 'using' Identifier 'for' ('*' | TypeName) ';'
StructDefinition = 'struct' Identifier '{'
                     ( VariableDeclaration ';' (VariableDeclaration ';')* ) '}'

ModifierDefinition = 'modifier' Identifier ParameterList? Block
ModifierInvocation = Identifier ( '(' ExpressionList? ')' )?

FunctionDefinition = 'function' Identifier? ParameterList
                     ( ModifierInvocation | StateMutability | 'external' | 'public' | 'internal' | 'private' )*
                     ( 'returns' ParameterList )? ( ';' | Block )
EventDefinition = 'event' Identifier EventParameterList 'anonymous'? ';'

EnumValue = Identifier
EnumDefinition = 'enum' Identifier '{' EnumValue? (',' EnumValue)* '}'

ParameterList = '(' ( Parameter (',' Parameter)* )? ')'
Parameter = TypeName StorageLocation? Identifier?

EventParameterList = '(' ( EventParameter (',' EventParameter )* )? ')'
EventParameter = TypeName 'indexed'? Identifier?

FunctionTypeParameterList = '(' ( FunctionTypeParameter (',' FunctionTypeParameter )* )? ')'
FunctionTypeParameter = TypeName StorageLocation?

// semantic restriction: mappings and structs (recursively) containing mappings
// are not allowed in argument lists
VariableDeclaration = TypeName StorageLocation? Identifier

TypeName = ElementaryTypeName
         | UserDefinedTypeName
         | Mapping
         | ArrayTypeName
         | FunctionTypeName

UserDefinedTypeName = Identifier ( '.' Identifier )*

Mapping = 'mapping' '(' ElementaryTypeName '=&gt;' TypeName ')'
ArrayTypeName = TypeName '[' Expression? ']'
FunctionTypeName = 'function' FunctionTypeParameterList ( 'internal' | 'external' | StateMutability )*
                   ( 'returns' FunctionTypeParameterList )?
StorageLocation = 'memory' | 'storage'
StateMutability = 'pure' | 'constant' | 'view' | 'payable'

Block = '{' Statement* '}'
Statement = IfStatement | WhileStatement | ForStatement | Block | InlineAssemblyStatement |
            ( DoWhileStatement | PlaceholderStatement | Continue | Break | Return |
              Throw | EmitStatement | SimpleStatement ) ';'

ExpressionStatement = Expression
IfStatement = 'if' '(' Expression ')' Statement ( 'else' Statement )?
WhileStatement = 'while' '(' Expression ')' Statement
PlaceholderStatement = '_'
SimpleStatement = VariableDefinition | ExpressionStatement
ForStatement = 'for' '(' (SimpleStatement)? ';' (Expression)? ';' (ExpressionStatement)? ')' Statement
InlineAssemblyStatement = 'assembly' StringLiteral? InlineAssemblyBlock
DoWhileStatement = 'do' Statement 'while' '(' Expression ')'
Continue = 'continue'
Break = 'break'
Return = 'return' Expression?
Throw = 'throw'
EmitStatement = 'emit' FunctionCall
VariableDefinition = ('var' IdentifierList | VariableDeclaration) ( '=' Expression )?
IdentifierList = '(' ( Identifier? ',' )* Identifier? ')'

// Precedence by order (see github.com/ethereum/solidity/pull/732)
Expression
  = Expression ('++' | '--')
  | NewExpression
  | IndexAccess
  | MemberAccess
  | FunctionCall
  | '(' Expression ')'
  | ('!' | '~' | 'delete' | '++' | '--' | '+' | '-') Expression
  | Expression '**' Expression
  | Expression ('*' | '/' | '%') Expression
  | Expression ('+' | '-') Expression
  | Expression ('&lt;&lt;' | '&gt;&gt;') Expression
  | Expression '&amp;' Expression
  | Expression '^' Expression
  | Expression '|' Expression
  | Expression ('&lt;' | '&gt;' | '&lt;=' | '&gt;=') Expression
  | Expression ('==' | '!=') Expression
  | Expression '&amp;&amp;' Expression
  | Expression '||' Expression
  | Expression '?' Expression ':' Expression
  | Expression ('=' | '|=' | '^=' | '&amp;=' | '&lt;&lt;=' | '&gt;&gt;=' | '+=' | '-=' | '*=' | '/=' | '%=') Expression
  | PrimaryExpression

PrimaryExpression = BooleanLiteral
                  | NumberLiteral
                  | HexLiteral
                  | StringLiteral
                  | TupleExpression
                  | Identifier
                  | ElementaryTypeNameExpression

ExpressionList = Expression ( ',' Expression )*
NameValueList = Identifier ':' Expression ( ',' Identifier ':' Expression )*

FunctionCall = Expression '(' FunctionCallArguments ')'
FunctionCallArguments = '{' NameValueList? '}'
                      | ExpressionList?

NewExpression = 'new' TypeName
MemberAccess = Expression '.' Identifier
IndexAccess = Expression '[' Expression? ']'

BooleanLiteral = 'true' | 'false'
NumberLiteral = ( HexNumber | DecimalNumber ) (' ' NumberUnit)?
NumberUnit = 'wei' | 'szabo' | 'finney' | 'ether'
           | 'seconds' | 'minutes' | 'hours' | 'days' | 'weeks' | 'years'
HexLiteral = 'hex' ('"' ([0-9a-fA-F]{2})* '"' | '\'' ([0-9a-fA-F]{2})* '\'')
StringLiteral = '"' ([^"\r\n\\] | '\\' .)* '"'
Identifier = [a-zA-Z_$] [a-zA-Z_$0-9]*

HexNumber = '0x' [0-9a-fA-F]+
DecimalNumber = [0-9]+ ( '.' [0-9]* )? ( [eE] [0-9]+ )?

TupleExpression = '(' ( Expression? ( ',' Expression? )*  )? ')'
                | '[' ( Expression  ( ',' Expression  )*  )? ']'

ElementaryTypeNameExpression = ElementaryTypeName

ElementaryTypeName = 'address' | 'bool' | 'string' | 'var'
                   | Int | Uint | Byte | Fixed | Ufixed

Int = 'int' | 'int8' | 'int16' | 'int24' | 'int32' | 'int40' | 'int48' | 'int56' | 'int64' | 'int72' | 'int80' | 'int88' | 'int96' | 'int104' | 'int112' | 'int120' | 'int128' | 'int136' | 'int144' | 'int152' | 'int160' | 'int168' | 'int176' | 'int184' | 'int192' | 'int200' | 'int208' | 'int216' | 'int224' | 'int232' | 'int240' | 'int248' | 'int256'

Uint = 'uint' | 'uint8' | 'uint16' | 'uint24' | 'uint32' | 'uint40' | 'uint48' | 'uint56' | 'uint64' | 'uint72' | 'uint80' | 'uint88' | 'uint96' | 'uint104' | 'uint112' | 'uint120' | 'uint128' | 'uint136' | 'uint144' | 'uint152' | 'uint160' | 'uint168' | 'uint176' | 'uint184' | 'uint192' | 'uint200' | 'uint208' | 'uint216' | 'uint224' | 'uint232' | 'uint240' | 'uint248' | 'uint256'

Byte = 'byte' | 'bytes' | 'bytes1' | 'bytes2' | 'bytes3' | 'bytes4' | 'bytes5' | 'bytes6' | 'bytes7' | 'bytes8' | 'bytes9' | 'bytes10' | 'bytes11' | 'bytes12' | 'bytes13' | 'bytes14' | 'bytes15' | 'bytes16' | 'bytes17' | 'bytes18' | 'bytes19' | 'bytes20' | 'bytes21' | 'bytes22' | 'bytes23' | 'bytes24' | 'bytes25' | 'bytes26' | 'bytes27' | 'bytes28' | 'bytes29' | 'bytes30' | 'bytes31' | 'bytes32'

Fixed = 'fixed' | ( 'fixed' [0-9]+ 'x' [0-9]+ )

Ufixed = 'ufixed' | ( 'ufixed' [0-9]+ 'x' [0-9]+ )

InlineAssemblyBlock = '{' AssemblyItem* '}'

AssemblyItem = Identifier | FunctionalAssemblyExpression | InlineAssemblyBlock | AssemblyLocalBinding | AssemblyAssignment | AssemblyLabel | NumberLiteral | StringLiteral | HexLiteral
AssemblyLocalBinding = 'let' Identifier ':=' FunctionalAssemblyExpression
AssemblyAssignment = ( Identifier ':=' FunctionalAssemblyExpression ) | ( '=:' Identifier )
AssemblyLabel = Identifier ':'
FunctionalAssemblyExpression = Identifier '(' AssemblyItem? ( ',' AssemblyItem )* ')'
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<span id="document-security-considerations"></span><div class="section" id="security-considerations">
<span id="id1"></span><h2>Security Considerations<a class="headerlink" href="#security-considerations" title="Permalink to this headline">¶</a></h2>
<p>虽然构建像预期一样工作的软件通常很容易，但是要检查没有人能够以一种没有预料到的方式使用它就更加困难了。<strong>not</strong></p>
<p>在可靠性方面，这一点更为重要，因为您可以使用智能合约来处理令牌，甚至可能是更有价值的东西。此外，智能合约的每个执行都是在公共场合执行的，除此之外，源代码通常也是可用的。</p>
<p>当然，您总是需要考虑有多少是危险的:您可以将一个智能的合约与一个向公众开放的web服务(因此，也向恶意的参与者)，甚至可能是开放源码的web服务进行比较。如果您只在web服务上存储您的购物清单，您可能不需要过多的关注，但是如果您使用该web服务管理您的银行帐户，您应该更加小心。</p>
<p>这一节将列出一些陷阱和一般的安全建议，但是，当然，不能完成。此外，请记住，即使您的智能合约代码是无bug的，编译器或平台本身也可能存在bug。在已知的bug列表中可以找到一些已知的与安全相关的bug，这也是机器可读的。注意到有一个bug bounty程序，它覆盖了这个编译器的代码生成器。<a class="reference internal" href="index.html#known-bugs"><span class="std std-ref">list of known bugs</span></a></p>
<p>和往常一样，使用开放源码文档，请帮助我们扩展这个部分(特别是一些例子不会造成伤害)!</p>
<div class="section" id="pitfalls">
<h3>Pitfalls<a class="headerlink" href="#pitfalls" title="Permalink to this headline">¶</a></h3>
<div class="section" id="private-information-and-randomness">
<h4>Private Information and Randomness<a class="headerlink" href="#private-information-and-randomness" title="Permalink to this headline">¶</a></h4>
<p>在智能合约中使用的所有内容都是公开可见的，甚至是本地变量和标记为私有的状态变量。<code class="docutils literal"><span class="pre">private</span></code></p>
<p>如果你不想让矿工们作弊的话，在智能合约中使用随机数是相当棘手的。</p>
</div>
<div class="section" id="re-entrancy">
<h4>Re-Entrancy<a class="headerlink" href="#re-entrancy" title="Permalink to this headline">¶</a></h4>
<p>合约(a)与另一份合约(B)之间的任何相互作用，以及任何将乙醚控制权移交给该合约(B)的任何相互作用。这使得在这种相互作用完成之前，Bto可以再次调用a。举个例子，下面的代码包含一个bug(它只是一个代码片段，而不是acomplete合约):</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span>
<span class="kd">contract</span> <span class="nx">Fund</span> <span class="p">{</span>
    <span class="cs">/// Mapping of ether shares of the contract.</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="nx">shares</span><span class="p">;</span>
    <span class="cs">/// Withdraw your share.</span>
    <span class="kd">function</span> <span class="nx">withdraw</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">shares</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]))</span>
            <span class="nx">shares</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这里的问题不太严重，因为作为发送的一部分的气体是有限的，但是它仍然暴露了一个缺点:以太传输可以永远的阻止代码的执行，所以接收方可以是一个回退的合约。这将让它获得多个退款，并基本上收回合约中的所有乙醚。具体来说，以下合约将允许攻击者多次退款，因为它在默认情况下使用了所有剩余的气体:<code class="docutils literal"><span class="pre">send</span></code><code class="docutils literal"><span class="pre">withdraw</span></code><code class="docutils literal"><span class="pre">call</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span>
<span class="kd">contract</span> <span class="nx">Fund</span> <span class="p">{</span>
    <span class="cs">/// Mapping of ether shares of the contract.</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="nx">shares</span><span class="p">;</span>
    <span class="cs">/// Withdraw your share.</span>
    <span class="kd">function</span> <span class="nx">withdraw</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">call</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span><span class="nx">shares</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">])())</span>
            <span class="nx">shares</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>为了避免重入，您可以使用checks - effects -交互模式，如下所示:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Fund</span> <span class="p">{</span>
    <span class="cs">/// Mapping of ether shares of the contract.</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="nx">shares</span><span class="p">;</span>
    <span class="cs">/// Withdraw your share.</span>
    <span class="kd">function</span> <span class="nx">withdraw</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">share</span> <span class="o">=</span> <span class="nx">shares</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
        <span class="nx">shares</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">share</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意，重入不仅是以太传输的效果，而且是对另一个合约的任何函数调用的影响。此外，你还必须考虑到合约的情况。一个被称为合约可以修改你所依赖的另一个合约的状态。</p>
</div>
<div class="section" id="gas-limit-and-loops">
<h4>Gas Limit and Loops<a class="headerlink" href="#gas-limit-and-loops" title="Permalink to this headline">¶</a></h4>
<p>没有固定数量迭代的循环，例如依赖于存储值的循环，必须小心使用:由于阻塞的气体限制，事务只能消耗一定量的气体。无论是显式的或仅仅是正常的操作，循环中的迭代次数都可以超出阻塞气体的限制，这可能导致在某个点上停止完全控制。这可能不适用于只执行从区块链读取数据的视图函数。尽管如此，这些功能可能会被其他合约称为连锁经营的一部分，从而拖延这些工作。请在合约文件中明确说明这类情况。<code class="docutils literal"><span class="pre">view</span></code></p>
</div>
<div class="section" id="sending-and-receiving-ether">
<h4>Sending and Receiving Ether<a class="headerlink" href="#sending-and-receiving-ether" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Neither contracts nor “external accounts” are currently able to prevent that someone sends them Ether.
Contracts can react on and reject a regular transfer, but there are ways
to move Ether without creating a message call. One way is to simply “mine to”
the contract address and the second way is using <code class="docutils literal"><span class="pre">selfdestruct(x)</span></code>.</li>
<li>If a contract receives Ether (without a function being called), the fallback function is executed.
If it does not have a fallback function, the Ether will be rejected (by throwing an exception).
During the execution of the fallback function, the contract can only rely
on the “gas stipend” (2300 gas) being available to it at that time. This stipend is not enough to access storage in any way.
To be sure that your contract can receive Ether in that way, check the gas requirements of the fallback function
(for example in the “details” section in Remix).</li>
<li>There is a way to forward more gas to the receiving contract using
<code class="docutils literal"><span class="pre">addr.call.value(x)()</span></code>. This is essentially the same as <code class="docutils literal"><span class="pre">addr.transfer(x)</span></code>,
only that it forwards all remaining gas and opens up the ability for the
recipient to perform more expensive actions (and it only returns a failure code
and does not automatically propagate the error). This might include calling back
into the sending contract or other state changes you might not have thought of.
So it allows for great flexibility for honest users but also for malicious actors.</li>
<li>If you want to send Ether using <code class="docutils literal"><span class="pre">address.transfer</span></code>, there are certain details to be aware of:<ol class="arabic">
<li>If the recipient is a contract, it causes its fallback function to be executed which can, in turn, call back the sending contract.</li>
<li>Sending Ether can fail due to the call depth going above 1024. Since the caller is in total control of the call
depth, they can force the transfer to fail; take this possibility into account or use <code class="docutils literal"><span class="pre">send</span></code> and make sure to always check its return value. Better yet,
write your contract using a pattern where the recipient can withdraw Ether instead.</li>
<li>Sending Ether can also fail because the execution of the recipient contract
requires more than the allotted amount of gas (explicitly by using <code class="docutils literal"><span class="pre">require</span></code>,
<code class="docutils literal"><span class="pre">assert</span></code>, <code class="docutils literal"><span class="pre">revert</span></code>, <code class="docutils literal"><span class="pre">throw</span></code> or
because the operation is just too expensive) - it “runs out of gas” (OOG).
If you use <code class="docutils literal"><span class="pre">transfer</span></code> or <code class="docutils literal"><span class="pre">send</span></code> with a return value check, this might provide a
means for the recipient to block progress in the sending contract. Again, the best practice here is to use
a <a class="reference internal" href="index.html#withdrawal-pattern"><span class="std std-ref">“withdraw” pattern instead of a “send” pattern</span></a>.</li>
</ol>
</li>
</ul>
</div>
<div class="section" id="callstack-depth">
<h4>Callstack Depth<a class="headerlink" href="#callstack-depth" title="Permalink to this headline">¶</a></h4>
<p>外部函数调用在任何时候都可能失败，因为它们超过了1024的最大调用堆栈。在这种情况下，Solidity会抛出一个异常。恶意的行为者可能会在他们与您的合约发生交互之前强制调用堆栈到一个高值。</p>
<p>请注意，如果调用堆栈已耗尽，则.send()不会抛出异常，而是在该情况下返回false。低级函数。call()、.callcode()和.delegate atecall()以相同的方式运行。<code class="docutils literal"><span class="pre">.send()</span></code><strong>not</strong><code class="docutils literal"><span class="pre">false</span></code><code class="docutils literal"><span class="pre">.call()</span></code><code class="docutils literal"><span class="pre">.callcode()</span></code><code class="docutils literal"><span class="pre">.delegatecall()</span></code></p>
</div>
<div class="section" id="tx-origin">
<h4>tx.origin<a class="headerlink" href="#tx-origin" title="Permalink to this headline">¶</a></h4>
<p>永远不要使用tx.origin作为授权。假设你有这样一个钱包合约:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>

<span class="c1">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span>
<span class="kd">contract</span> <span class="nx">TxUserWallet</span> <span class="p">{</span>
    <span class="kt">address</span> <span class="nx">owner</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">TxUserWallet</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">owner</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">transferTo</span><span class="p">(</span><span class="kt">address</span> <span class="nx">dest</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">amount</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span><span class="nb">tx</span><span class="p">.</span><span class="nx">origin</span> <span class="o">==</span> <span class="nx">owner</span><span class="p">);</span>
        <span class="nx">dest</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">amount</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在有人骗你把乙醚送到这个攻击钱包的地址:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>

<span class="kd">interface</span> <span class="nx">TxUserWallet</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">transferTo</span><span class="p">(</span><span class="kt">address</span> <span class="nx">dest</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">amount</span><span class="p">)</span> <span class="k">public</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">TxAttackWallet</span> <span class="p">{</span>
    <span class="kt">address</span> <span class="nx">owner</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">TxAttackWallet</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">owner</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">TxUserWallet</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">).</span><span class="nx">transferTo</span><span class="p">(</span><span class="nx">owner</span><span class="p">,</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">balance</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果你的钱包检查过味精。发送者获得授权，它将得到攻击钱包的地址，而不是所有者地址。但是通过检查tx.origin，它得到了启动事务的原始地址，它仍然是所有者地址。攻击钱包立即耗尽你所有的资金。<code class="docutils literal"><span class="pre">msg.sender</span></code><code class="docutils literal"><span class="pre">tx.origin</span></code></p>
</div>
<div class="section" id="minor-details">
<h4>Minor Details<a class="headerlink" href="#minor-details" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>In <code class="docutils literal"><span class="pre">for</span> <span class="pre">(var</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">arrayName.length;</span> <span class="pre">i++)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>, the type of <code class="docutils literal"><span class="pre">i</span></code> will be <code class="docutils literal"><span class="pre">uint8</span></code>, because this is the smallest type that is required to hold the value <code class="docutils literal"><span class="pre">0</span></code>. If the array has more than 255 elements, the loop will not terminate.</li>
<li>Types that do not occupy the full 32 bytes might contain “dirty higher order bits”.
This is especially important if you access <code class="docutils literal"><span class="pre">msg.data</span></code> - it poses a malleability risk:
You can craft transactions that call a function <code class="docutils literal"><span class="pre">f(uint8</span> <span class="pre">x)</span></code> with a raw byte argument
of <code class="docutils literal"><span class="pre">0xff000001</span></code> and with <code class="docutils literal"><span class="pre">0x00000001</span></code>. Both are fed to the contract and both will
look like the number <code class="docutils literal"><span class="pre">1</span></code> as far as <code class="docutils literal"><span class="pre">x</span></code> is concerned, but <code class="docutils literal"><span class="pre">msg.data</span></code> will
be different, so if you use <code class="docutils literal"><span class="pre">keccak256(msg.data)</span></code> for anything, you will get different results.</li>
</ul>
</div>
</div>
<div class="section" id="recommendations">
<h3>Recommendations<a class="headerlink" href="#recommendations" title="Permalink to this headline">¶</a></h3>
<div class="section" id="take-warnings-seriously">
<h4>Take Warnings Seriously<a class="headerlink" href="#take-warnings-seriously" title="Permalink to this headline">¶</a></h4>
<p>如果编译器警告您一些事情，您应该更好地更改它。即使你不认为这个特别的警告有安全隐患，也可能会有另一个问题埋在地下。任何编译器发出的警告都可以通过对thecode的细微更改来保持沉默。</p>
<p>同时，尝试通过添加pragma实验“v0.5.0”来尽可能早地启用“0.5.0”安全特性。请注意，在这种情况下，“实验性”一词并不意味着安全特性无论如何都是有风险的，它只是一种启用某些特性的方法，而这些特性是由于向后兼容而导致的最新版本的可靠性的一部分。<code class="docutils literal"><span class="pre">pragma</span> <span class="pre">experimental</span> <span class="pre">"v0.5.0";</span></code><code class="docutils literal"><span class="pre">experimental</span></code></p>
</div>
<div class="section" id="restrict-the-amount-of-ether">
<h4>Restrict the Amount of Ether<a class="headerlink" href="#restrict-the-amount-of-ether" title="Permalink to this headline">¶</a></h4>
<p>限制可以存储在smartcontract中的以太(或其他令牌)数量。如果您的源代码、编译器或平台有bug，这些资金可能会丢失。如果你想限制你的损失，限制以太的数量。</p>
</div>
<div class="section" id="keep-it-small-and-modular">
<h4>Keep it Small and Modular<a class="headerlink" href="#keep-it-small-and-modular" title="Permalink to this headline">¶</a></h4>
<p>保持你的合约小且容易理解。在其他合约或库中单独使用不相关的功能。关于源代码质量的一般建议是:限制本地变量的数量、函数的长度等等。记录下你的功能，让别人来看看你的意图是什么，以及它是否与代码的不同。</p>
</div>
<div class="section" id="use-the-checks-effects-interactions-pattern">
<h4>Use the Checks-Effects-Interactions Pattern<a class="headerlink" href="#use-the-checks-effects-interactions-pattern" title="Permalink to this headline">¶</a></h4>
<p>大多数函数首先执行一些检查(谁调用了函数，在范围内是参数，是否发送了足够的以太，是否有personhave标记等)。这些检查应该先做。</p>
<p>作为第二步，如果所有的检查都通过，将对当前合约的状态变量产生影响。与其他合约的交互应该是任何函数的最后一步。</p>
<p>早期的合约延迟了一些效果，等待外部函数调用返回非错误状态。这通常是一个严重的错误，因为上面解释了重入的问题。</p>
<p>请注意，对已知合约的调用可能会导致调用tounknown的合约，因此最好总是应用这种模式。</p>
</div>
<div class="section" id="include-a-fail-safe-mode">
<h4>Include a Fail-Safe Mode<a class="headerlink" href="#include-a-fail-safe-mode" title="Permalink to this headline">¶</a></h4>
<p>在使您的系统完全分散的同时，将删除任何中介，这可能是一个好主意，特别是对于新代码来说，包括一些故障安全机制:</p>
<p>你可以在你的智能合约中添加一个功能，像“有任何乙醚泄漏吗?”“，”令牌的总和等于合约的余额吗?”或类似的事情。记住，你不能使用太多的气体，所以在那里可能需要帮助。</p>
<p>如果自检失败，合约自动转换成某种“故障安全”模式，例如，禁用大部分功能，将控制权交给一个固定的、受信任的第三方，或者只是将合约转换成简单的“归还我的钱”合约。</p>
</div>
</div>
<div class="section" id="formal-verification">
<h3>Formal Verification<a class="headerlink" href="#formal-verification" title="Permalink to this headline">¶</a></h3>
<p>使用正式的验证，您可以执行一个自动化的数学证明，您的源代码可以满足某种形式的规范。规范仍然是正式的(就像源代码一样)，但通常要简单得多。</p>
<p>请注意，正式的验证本身只能帮助您理解您所做的(规范)和您如何做(实际的实现)之间的区别。你仍然需要检查你想要的是什么，并且你没有错过任何意想不到的效果。</p>
</div>
</div>
<span id="document-using-the-compiler"></span><div class="section" id="using-the-compiler">
<h2>Using the compiler<a class="headerlink" href="#using-the-compiler" title="Permalink to this headline">¶</a></h2>
<div class="section" id="using-the-commandline-compiler">
<span id="commandline-compiler"></span><span id="index-0"></span><h3>Using the Commandline Compiler<a class="headerlink" href="#using-the-commandline-compiler" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">本节不适用于solcjs。<a class="reference internal" href="index.html#solcjs"><span class="std std-ref">solcjs</span></a></p>
</div>
<p>Solidity存储库的一个构建目标是solc, Solidity commandline编译器。使用solc——帮助向您提供所有选项的解释。编译器可以产生各种输出，从简单的二进制文件和程序集到抽象语法树(解析树)到对气体使用的估计。如果您只想编译一个文件，那么可以将其运行为solc——bin sourceFile。它会输出二进制。如果您想获得一些更高级的solc输出变体，最好告诉它使用solc -o outputDirectory——ast——asm sourceFile.sol将所有文件输出到单独的文件中。<code class="docutils literal"><span class="pre">solc</span></code><code class="docutils literal"><span class="pre">solc</span> <span class="pre">--help</span></code><code class="docutils literal"><span class="pre">solc</span> <span class="pre">--bin</span> <span class="pre">sourceFile.sol</span></code><code class="docutils literal"><span class="pre">solc</span></code><code class="docutils literal"><span class="pre">solc</span> <span class="pre">-o</span> <span class="pre">outputDirectory</span> <span class="pre">--bin</span> <span class="pre">--ast</span> <span class="pre">--asm</span> <span class="pre">sourceFile.sol</span></code></p>
<p>在部署合约之前，在编译使用solc——优化——bin sourceFile.sol时激活优化器。默认情况下，优化器将优化200次运行的合约。如果您想要优化初始合约部署并获得最小的输出，请将其设置为——运行=1。如果您期望许多事务，并且不关心更高的部署成本和输出大小，那么设置—运行到一个高的数字。<code class="docutils literal"><span class="pre">solc</span> <span class="pre">--optimize</span> <span class="pre">--bin</span> <span class="pre">sourceFile.sol</span></code><code class="docutils literal"><span class="pre">--runs=1</span></code><code class="docutils literal"><span class="pre">--runs</span></code></p>
<p>命令行编译器将自动从文件系统读取导入的文件，但也可以通过以下方式提供路径重定向:<code class="docutils literal"><span class="pre">prefix=path</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">solc</span> <span class="nx">github</span><span class="p">.</span><span class="nx">com</span><span class="o">/</span><span class="nx">ethereum</span><span class="o">/</span><span class="nx">dapp</span><span class="o">-</span><span class="nx">bin</span><span class="o">/=</span><span class="err">/usr/local/lib/dapp-bin/ =/usr/local/lib/fallback file.sol</span>
</pre></div>
</div>
<p>这实际上指示编译器从github.com/ethereum/dapp-bin/在/usr/local/lib/dapp-bin中搜索任何东西，如果它在那里没有找到文件，它将查看/usr/local/lib/fallback(空前缀总是匹配)。solc不会从文件系统中读取文件，这些文件位于重新映射的目标和目录之外，在这些目录中有显式指定的sourcefiles，所以诸如import“/etc/passwd”之类的东西;只有当你添加=/作为重新映射时才可以使用。<code class="docutils literal"><span class="pre">github.com/ethereum/dapp-bin/</span></code><code class="docutils literal"><span class="pre">/usr/local/lib/dapp-bin</span></code><code class="docutils literal"><span class="pre">/usr/local/lib/fallback</span></code><code class="docutils literal"><span class="pre">solc</span></code><code class="docutils literal"><span class="pre">import</span> <span class="pre">"/etc/passwd";</span></code><code class="docutils literal"><span class="pre">=/</span></code></p>
<p>如果有多个匹配项，则选择使用最长公共前缀的匹配项。</p>
<p>出于安全原因，编译器会限制它可以访问的目录。在命令行上指定的源文件的路径(及其子目录)和由重新定义的路径定义的路径可以用于导入语句，但是其他的都被拒绝了。附加路径(及其子目录)可以通过——允许路径/示例/路径，/另一个/示例/路径切换。<code class="docutils literal"><span class="pre">--allow-paths</span> <span class="pre">/sample/path,/another/sample/path</span></code></p>
<p>如果您的合约使用了库，您将会注意到字节码包含表单__LibraryName______的子字符串。您可以使用solc作为链接器，这意味着它将为您插入这些点的库地址:<a class="reference internal" href="index.html#libraries"><span class="std std-ref">libraries</span></a><code class="docutils literal"><span class="pre">__LibraryName______</span></code><code class="docutils literal"><span class="pre">solc</span></code></p>
<p>或者添加——库“Math:0x12345678901234567890堆:0xabcdef0123456”到您的命令，为每个库提供一个地址或将字符串存储在一个文件中(每行一个库)，并使用—库文件名运行solc。<code class="docutils literal"><span class="pre">--libraries</span> <span class="pre">"Math:0x12345678901234567890</span> <span class="pre">Heap:0xabcdef0123456"</span></code><code class="docutils literal"><span class="pre">solc</span></code><code class="docutils literal"><span class="pre">--libraries</span> <span class="pre">fileName</span></code></p>
<p>如果使用选项-link来调用solc，那么所有输入文件都被解释为在__libraryname_ -format中没有链接的二进制文件(hex编码)，并且是链接在一起的(如果输入是从stdin中读取的，那么它将被写入stdout)。所有选项除外——在本例中，忽略了库(包括-o)。<code class="docutils literal"><span class="pre">solc</span></code><code class="docutils literal"><span class="pre">--link</span></code><code class="docutils literal"><span class="pre">__LibraryName____</span></code><code class="docutils literal"><span class="pre">--libraries</span></code><code class="docutils literal"><span class="pre">-o</span></code></p>
<p>如果使用该选项调用solc——标准JSON，它将期望在标准输入上有一个JSON输入(如下所述)，并在标准输出上返回一个JSON输出。<code class="docutils literal"><span class="pre">solc</span></code><code class="docutils literal"><span class="pre">--standard-json</span></code></p>
</div>
<div class="section" id="compiler-input-and-output-json-description">
<span id="compiler-api"></span><h3>Compiler Input and Output JSON Description<a class="headerlink" href="#compiler-input-and-output-json-description" title="Permalink to this headline">¶</a></h3>
<p>这些JSON格式由编译器API使用，也可以通过solc提供。这些都是可以更改的，有些字段是可选的(如前所述)，但是它的目标是只进行向后兼容的更改。<code class="docutils literal"><span class="pre">solc</span></code></p>
<p>编译器API期望一个JSON格式的输入输出，并输出一个JSON格式的输出。</p>
<p>注释当然是不允许的，仅用于解释目的。</p>
<div class="section" id="input-description">
<h4>Input Description<a class="headerlink" href="#input-description" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none"><div class="highlight"><pre><span></span>{
  // Required: Source code language, such as "Solidity", "serpent", "lll", "assembly", etc.
  language: "Solidity",
  // Required
  sources:
  {
    // The keys here are the "global" names of the source files,
    // imports can use other files via remappings (see below).
    "myFile.sol":
    {
      // Optional: keccak256 hash of the source file
      // It is used to verify the retrieved content if imported via URLs.
      "keccak256": "0x123...",
      // Required (unless "content" is used, see below): URL(s) to the source file.
      // URL(s) should be imported in this order and the result checked against the
      // keccak256 hash (if available). If the hash doesn't match or none of the
      // URL(s) result in success, an error should be raised.
      "urls":
      [
        "bzzr://56ab...",
        "ipfs://Qma...",
        "file:///tmp/path/to/file.sol"
      ]
    },
    "mortal":
    {
      // Optional: keccak256 hash of the source file
      "keccak256": "0x234...",
      // Required (unless "urls" is used): literal contents of the source file
      "content": "contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } }"
    }
  },
  // Optional
  settings:
  {
    // Optional: Sorted list of remappings
    remappings: [ ":g/dir" ],
    // Optional: Optimizer settings
    optimizer: {
      // disabled by default
      enabled: true,
      // Optimize for how many times you intend to run the code.
      // Lower values will optimize more for initial deployment cost, higher values will optimize more for high-frequency usage.
      runs: 200
    },
    evmVersion: "byzantium", // Version of the EVM to compile for. Affects type checking and code generation. Can be homestead, tangerineWhistle, spuriousDragon, byzantium or constantinople
    // Metadata settings (optional)
    metadata: {
      // Use only literal content and not URLs (false by default)
      useLiteralContent: true
    },
    // Addresses of the libraries. If not all libraries are given here, it can result in unlinked objects whose output data is different.
    libraries: {
      // The top level key is the the name of the source file where the library is used.
      // If remappings are used, this source file should match the global path after remappings were applied.
      // If this key is an empty string, that refers to a global level.
      "myFile.sol": {
        "MyLib": "0x123123..."
      }
    }
    // The following can be used to select desired outputs.
    // If this field is omitted, then the compiler loads and does type checking, but will not generate any outputs apart from errors.
    // The first level key is the file name and the second is the contract name, where empty contract name refers to the file itself,
    // while the star refers to all of the contracts.
    //
    // The available output types are as follows:
    //   abi - ABI
    //   ast - AST of all source files
    //   legacyAST - legacy AST of all source files
    //   devdoc - Developer documentation (natspec)
    //   userdoc - User documentation (natspec)
    //   metadata - Metadata
    //   ir - New assembly format before desugaring
    //   evm.assembly - New assembly format after desugaring
    //   evm.legacyAssembly - Old-style assembly format in JSON
    //   evm.bytecode.object - Bytecode object
    //   evm.bytecode.opcodes - Opcodes list
    //   evm.bytecode.sourceMap - Source mapping (useful for debugging)
    //   evm.bytecode.linkReferences - Link references (if unlinked object)
    //   evm.deployedBytecode* - Deployed bytecode (has the same options as evm.bytecode)
    //   evm.methodIdentifiers - The list of function hashes
    //   evm.gasEstimates - Function gas estimates
    //   ewasm.wast - eWASM S-expressions format (not supported atm)
    //   ewasm.wasm - eWASM binary format (not supported atm)
    //
    // Note that using a using `evm`, `evm.bytecode`, `ewasm`, etc. will select every
    // target part of that output. Additionally, `*` can be used as a wildcard to request everything.
    //
    outputSelection: {
      // Enable the metadata and bytecode outputs of every single contract.
      "*": {
        "*": [ "metadata", "evm.bytecode" ]
      },
      // Enable the abi and opcodes output of MyContract defined in file def.
      "def": {
        "MyContract": [ "abi", "evm.bytecode.opcodes" ]
      },
      // Enable the source map output of every single contract.
      "*": {
        "*": [ "evm.bytecode.sourceMap" ]
      },
      // Enable the legacy AST output of every single file.
      "*": {
        "": [ "legacyAST" ]
      }
    }
  }
}
</pre></div>
</div>
</div>
<div class="section" id="output-description">
<h4>Output Description<a class="headerlink" href="#output-description" title="Permalink to this headline">¶</a></h4>
<div class="highlight-none"><div class="highlight"><pre><span></span>{
  // Optional: not present if no errors/warnings were encountered
  errors: [
    {
      // Optional: Location within the source file.
      sourceLocation: {
        file: "sourceFile.sol",
        start: 0,
        end: 100
      ],
      // Mandatory: Error type, such as "TypeError", "InternalCompilerError", "Exception", etc.
      // See below for complete list of types.
      type: "TypeError",
      // Mandatory: Component where the error originated, such as "general", "ewasm", etc.
      component: "general",
      // Mandatory ("error" or "warning")
      severity: "error",
      // Mandatory
      message: "Invalid keyword"
      // Optional: the message formatted with source location
      formattedMessage: "sourceFile.sol:100: Invalid keyword"
    }
  ],
  // This contains the file-level outputs. In can be limited/filtered by the outputSelection settings.
  sources: {
    "sourceFile.sol": {
      // Identifier (used in source maps)
      id: 1,
      // The AST object
      ast: {},
      // The legacy AST object
      legacyAST: {}
    }
  },
  // This contains the contract-level outputs. It can be limited/filtered by the outputSelection settings.
  contracts: {
    "sourceFile.sol": {
      // If the language used has no contract names, this field should equal to an empty string.
      "ContractName": {
        // The Ethereum Contract ABI. If empty, it is represented as an empty array.
        // See https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
        abi: [],
        // See the Metadata Output documentation (serialised JSON string)
        metadata: "{...}",
        // User documentation (natspec)
        userdoc: {},
        // Developer documentation (natspec)
        devdoc: {},
        // Intermediate representation (string)
        ir: "",
        // EVM-related outputs
        evm: {
          // Assembly (string)
          assembly: "",
          // Old-style assembly (object)
          legacyAssembly: {},
          // Bytecode and related details.
          bytecode: {
            // The bytecode as a hex string.
            object: "00fe",
            // Opcodes list (string)
            opcodes: "",
            // The source mapping as a string. See the source mapping definition.
            sourceMap: "",
            // If given, this is an unlinked object.
            linkReferences: {
              "libraryFile.sol": {
                // Byte offsets into the bytecode. Linking replaces the 20 bytes located there.
                "Library1": [
                  { start: 0, length: 20 },
                  { start: 200, length: 20 }
                ]
              }
            }
          },
          // The same layout as above.
          deployedBytecode: { },
          // The list of function hashes
          methodIdentifiers: {
            "delegate(address)": "5c19a95c"
          },
          // Function gas estimates
          gasEstimates: {
            creation: {
              codeDepositCost: "420000",
              executionCost: "infinite",
              totalCost: "infinite"
            },
            external: {
              "delegate(address)": "25000"
            },
            internal: {
              "heavyLifting()": "infinite"
            }
          }
        },
        // eWASM related outputs
        ewasm: {
          // S-expressions format
          wast: "",
          // Binary format (hex string)
          wasm: ""
        }
      }
    }
  }
}
</pre></div>
</div>
<div class="section" id="error-types">
<h5>Error types<a class="headerlink" href="#error-types" title="Permalink to this headline">¶</a></h5>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">JSONError</span></code>: JSON input doesn’t conform to the required format, e.g. input is not a JSON object, the language is not supported, etc.</li>
<li><code class="docutils literal"><span class="pre">IOError</span></code>: IO and import processing errors, such as unresolvable URL or hash mismatch in supplied sources.</li>
<li><code class="docutils literal"><span class="pre">ParserError</span></code>: Source code doesn’t conform to the language rules.</li>
<li><code class="docutils literal"><span class="pre">DocstringParsingError</span></code>: The NatSpec tags in the comment block cannot be parsed.</li>
<li><code class="docutils literal"><span class="pre">SyntaxError</span></code>: Syntactical error, such as <code class="docutils literal"><span class="pre">continue</span></code> is used outside of a <code class="docutils literal"><span class="pre">for</span></code> loop.</li>
<li><code class="docutils literal"><span class="pre">DeclarationError</span></code>: Invalid, unresolvable or clashing identifier names. e.g. <code class="docutils literal"><span class="pre">Identifier</span> <span class="pre">not</span> <span class="pre">found</span></code></li>
<li><code class="docutils literal"><span class="pre">TypeError</span></code>: Error within the type system, such as invalid type conversions, invalid assignments, etc.</li>
<li><code class="docutils literal"><span class="pre">UnimplementedFeatureError</span></code>: Feature is not supported by the compiler, but is expected to be supported in future versions.</li>
<li><code class="docutils literal"><span class="pre">InternalCompilerError</span></code>: Internal bug triggered in the compiler - this should be reported as an issue.</li>
<li><code class="docutils literal"><span class="pre">Exception</span></code>: Unknown failure during compilation - this should be reported as an issue.</li>
<li><code class="docutils literal"><span class="pre">CompilerError</span></code>: Invalid use of the compiler stack - this should be reported as an issue.</li>
<li><code class="docutils literal"><span class="pre">FatalError</span></code>: Fatal error not processed correctly - this should be reported as an issue.</li>
<li><code class="docutils literal"><span class="pre">Warning</span></code>: A warning, which didn’t stop the compilation, but should be addressed if possible.</li>
</ol>
</div>
</div>
</div>
</div>
<span id="document-metadata"></span><div class="section" id="contract-metadata">
<h2>Contract Metadata<a class="headerlink" href="#contract-metadata" title="Permalink to this headline">¶</a></h2>
<p id="index-0">Solidity编译器会自动生成一个JSON文件，它包含关于当前合约的信息。它可以用来查询编译器版本、使用的源代码、ABIand NatSpec文档，以便更安全地与合约交互并验证其源代码。</p>
<p>编译器将元数据文件的群集散列追加到字节码的末尾(参见下面的详细信息)，这样您就可以以身份验证的方式检索文件，而不必依赖于集中式数据提供者。</p>
<p>当然，您必须将元数据文件发布到群集(或其他服务)以便其他人可以访问它。该文件可以使用solc—metadataand输出，该文件将被称为ContractName_meta.json。它将包含对源代码的群集引用，所以您必须上传所有源文件和元数据文件。<code class="docutils literal"><span class="pre">solc</span> <span class="pre">--metadata</span></code><code class="docutils literal"><span class="pre">ContractName_meta.json</span></code></p>
<p>元数据文件有以下格式。下面的例子以人类可读的方式呈现。正确格式化的元数据应该正确使用引号，将空格减少到最小值，并对所有对象的键进行排序，以达到唯一的格式。注释当然也不允许，仅用于解释目的。</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>{
  // Required: The version of the metadata format
  version: "1",
  // Required: Source code language, basically selects a "sub-version"
  // of the specification
  language: "Solidity",
  // Required: Details about the compiler, contents are specific
  // to the language.
  compiler: {
    // Required for Solidity: Version of the compiler
    version: "0.4.6+commit.2dabbdf0.Emscripten.clang",
    // Optional: Hash of the compiler binary which produced this output
    keccak256: "0x123..."
  },
  // Required: Compilation source files/source units, keys are file names
  sources:
  {
    "myFile.sol": {
      // Required: keccak256 hash of the source file
      "keccak256": "0x123...",
      // Required (unless "content" is used, see below): Sorted URL(s)
      // to the source file, protocol is more or less arbitrary, but a
      // Swarm URL is recommended
      "urls": [ "bzzr://56ab..." ]
    },
    "mortal": {
      // Required: keccak256 hash of the source file
      "keccak256": "0x234...",
      // Required (unless "url" is used): literal contents of the source file
      "content": "contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } }"
    }
  },
  // Required: Compiler settings
  settings:
  {
    // Required for Solidity: Sorted list of remappings
    remappings: [ ":g/dir" ],
    // Optional: Optimizer settings (enabled defaults to false)
    optimizer: {
      enabled: true,
      runs: 500
    },
    // Required for Solidity: File and name of the contract or library this
    // metadata is created for.
    compilationTarget: {
      "myFile.sol": "MyContract"
    },
    // Required for Solidity: Addresses for libraries used
    libraries: {
      "MyLib": "0x123123..."
    }
  },
  // Required: Generated information about the contract.
  output:
  {
    // Required: ABI definition of the contract
    abi: [ ... ],
    // Required: NatSpec user documentation of the contract
    userdoc: [ ... ],
    // Required: NatSpec developer documentation of the contract
    devdoc: [ ... ],
  }
}
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">注意，上面的ABI定义没有固定的顺序。它可以使用编译器版本进行更改。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">由于生成的合约的字节码包含元数据散列，因此对元数据的任何更改都会导致字节码的更改。此外，由于metadataincludes包含所有使用的源的散列，所以任何一个sourcecodes中的一个空格都会导致不同的元数据，随后会产生一个不同的字节码。</p>
</div>
<div class="section" id="encoding-of-the-metadata-hash-in-the-bytecode">
<h3>Encoding of the Metadata Hash in the Bytecode<a class="headerlink" href="#encoding-of-the-metadata-hash-in-the-bytecode" title="Permalink to this headline">¶</a></h3>
<p>因为我们可能会支持在将来检索元数据文件的其他方法，所以映射{“bzzr0”:&lt; cluster hash&gt;}是storedcborr编码的。由于这种编码的开始并不容易找到，所以它的长度被添加到一个双字节的大端编码中。因此，Solidity编译器的当前版本在部署字节码的末尾添加了以下内容:<code class="docutils literal"><span class="pre">{"bzzr0":</span> <span class="pre">&lt;Swarm</span> <span class="pre">hash&gt;}</span></code><a class="reference external" href="https://tools.ietf.org/html/rfc7049">CBOR</a></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="mh">0xa1</span> <span class="mh">0x65</span> <span class="s1">'b'</span> <span class="s1">'z'</span> <span class="s1">'z'</span> <span class="s1">'r'</span> <span class="s1">'0'</span> <span class="mh">0x58</span> <span class="mh">0x20</span> <span class="o">&lt;</span><span class="mi">32</span> <span class="kt">bytes</span> <span class="nx">swarm</span> <span class="nx">hash</span><span class="o">&gt;</span> <span class="mh">0x00</span> <span class="mh">0x29</span>
</pre></div>
</div>
<p>因此，为了检索数据，部署的字节码的结束可以是checkedto匹配该模式，并使用群集哈希来检索文件。</p>
</div>
<div class="section" id="usage-for-automatic-interface-generation-and-natspec">
<h3>Usage for Automatic Interface Generation and NatSpec<a class="headerlink" href="#usage-for-automatic-interface-generation-and-natspec" title="Permalink to this headline">¶</a></h3>
<p>元数据的使用方式如下:一个想要与合约(例如Mist)进行交互的组件从一个文件的群散列表中检索出该文件的代码。这个文件是json -解码成一个类似上面的结构。</p>
<p>然后，组件可以使用ABI自动生成合约的基本用户界面。</p>
<p>此外，Mist可以使用userdoc在用户与合约交互时向用户显示确认消息。</p>
<p>关于Ethereum自然规范(NatSpec)的附加信息可以在这里找到。<a class="reference external" href="https://github.com/ethereum/wiki/wiki/Ethereum-Natural-Specification-Format">here</a></p>
</div>
<div class="section" id="usage-for-source-code-verification">
<h3>Usage for Source Code Verification<a class="headerlink" href="#usage-for-source-code-verification" title="Permalink to this headline">¶</a></h3>
<p>为了验证编译的正确性，可以通过元数据文件中的链接来检索源文件。正确版本的编译器(被检查为“官方”编译器的一部分)将在该输入上调用指定的设置。结果字节码与创建事务的数据或创建操作码数据进行比较。这将自动验证元数据，因为它的散列是字节码的一部分。多余的数据对应于构造函数的输入数据，该数据应该根据接口进行解码并呈现给用户。<code class="docutils literal"><span class="pre">CREATE</span></code></p>
</div>
</div>
<span id="document-abi-spec"></span><div class="section" id="application-binary-interface-specification">
<span id="abi"></span><span id="index-0"></span><h2>Application Binary Interface Specification<a class="headerlink" href="#application-binary-interface-specification" title="Permalink to this headline">¶</a></h2>
<div class="section" id="basic-design">
<h3>Basic Design<a class="headerlink" href="#basic-design" title="Permalink to this headline">¶</a></h3>
<p>应用程序二进制接口是与Ethereum生态系统中的合约交互的标准方式，bothfrom在区块链之外，并用于合约与合约的交互。数据按其类型进行编码，如本规范所述。编码不是自我描述的，因此需要一个模式来解码。</p>
<p>我们假设合约的接口函数是强类型的，在编译时和静态中都是已知的。不提供内省机制。我们假定所有的合约都将具有在编译时可用的任何合约的接口定义。</p>
<p>该规范不涉及接口是动态的或仅在运行时才知道的合约。如果这些情况变得重要，它们就可以被适当地处理为在以太生态系统内建造的设施。</p>
</div>
<div class="section" id="function-selector">
<span id="abi-function-selector"></span><h3>Function Selector<a class="headerlink" href="#function-selector" title="Permalink to this headline">¶</a></h3>
<p>函数调用的调用数据的前四个字节指定要调用的函数。它是函数签名的第一个(左，高阶)四个字节的Keccak (SHA-3)哈希。签名被定义为基本原型的规范表达式，即。参数类型的括号列表的函数名。参数类型由一个逗号分隔，不使用空格。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">函数的返回类型不是该签名的一部分。在Solidity函数中，重载返回类型是不考虑的。其原因是保持函数调用解析上下文无关。但是，ABI的JSON描述包含了输入和输出。看到JSON(ABI)<a class="reference internal" href="index.html#overload-function"><span class="std std-ref">Solidity’s function overloading</span></a><a class="reference internal" href="#abi-json"><span class="std std-ref">JSON ABI</span></a></p>
</div>
</div>
<div class="section" id="argument-encoding">
<h3>Argument Encoding<a class="headerlink" href="#argument-encoding" title="Permalink to this headline">¶</a></h3>
<p>从第五个字节开始，编码的参数跟随。该编码也在其他地方使用，例如返回值和事件参数以相同的方式编码，没有指定函数的四个字节。</p>
</div>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p>存在以下基本类型:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">uint&lt;M&gt;</span></code>: unsigned integer type of <code class="docutils literal"><span class="pre">M</span></code> bits, <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">M</span> <span class="pre">&lt;=</span> <span class="pre">256</span></code>, <code class="docutils literal"><span class="pre">M</span> <span class="pre">%</span> <span class="pre">8</span> <span class="pre">==</span> <span class="pre">0</span></code>. e.g. <code class="docutils literal"><span class="pre">uint32</span></code>, <code class="docutils literal"><span class="pre">uint8</span></code>, <code class="docutils literal"><span class="pre">uint256</span></code>.</li>
<li><code class="docutils literal"><span class="pre">int&lt;M&gt;</span></code>: two’s complement signed integer type of <code class="docutils literal"><span class="pre">M</span></code> bits, <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">M</span> <span class="pre">&lt;=</span> <span class="pre">256</span></code>, <code class="docutils literal"><span class="pre">M</span> <span class="pre">%</span> <span class="pre">8</span> <span class="pre">==</span> <span class="pre">0</span></code>.</li>
<li><code class="docutils literal"><span class="pre">address</span></code>: equivalent to <code class="docutils literal"><span class="pre">uint160</span></code>, except for the assumed interpretation and language typing. For computing the function selector, <code class="docutils literal"><span class="pre">address</span></code> is used.</li>
<li><code class="docutils literal"><span class="pre">uint</span></code>, <code class="docutils literal"><span class="pre">int</span></code>: synonyms for <code class="docutils literal"><span class="pre">uint256</span></code>, <code class="docutils literal"><span class="pre">int256</span></code> respectively. For computing the function selector, <code class="docutils literal"><span class="pre">uint256</span></code> and <code class="docutils literal"><span class="pre">int256</span></code> have to be used.</li>
<li><code class="docutils literal"><span class="pre">bool</span></code>: equivalent to <code class="docutils literal"><span class="pre">uint8</span></code> restricted to the values 0 and 1. For computing the function selector, <code class="docutils literal"><span class="pre">bool</span></code> is used.</li>
<li><code class="docutils literal"><span class="pre">fixed&lt;M&gt;x&lt;N&gt;</span></code>: signed fixed-point decimal number of <code class="docutils literal"><span class="pre">M</span></code> bits, <code class="docutils literal"><span class="pre">8</span> <span class="pre">&lt;=</span> <span class="pre">M</span> <span class="pre">&lt;=</span> <span class="pre">256</span></code>, <code class="docutils literal"><span class="pre">M</span> <span class="pre">%</span> <span class="pre">8</span> <span class="pre">==0</span></code>, and <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">N</span> <span class="pre">&lt;=</span> <span class="pre">80</span></code>, which denotes the value <code class="docutils literal"><span class="pre">v</span></code> as <code class="docutils literal"><span class="pre">v</span> <span class="pre">/</span> <span class="pre">(10</span> <span class="pre">**</span> <span class="pre">N)</span></code>.</li>
<li><code class="docutils literal"><span class="pre">ufixed&lt;M&gt;x&lt;N&gt;</span></code>: unsigned variant of <code class="docutils literal"><span class="pre">fixed&lt;M&gt;x&lt;N&gt;</span></code>.</li>
<li><code class="docutils literal"><span class="pre">fixed</span></code>, <code class="docutils literal"><span class="pre">ufixed</span></code>: synonyms for <code class="docutils literal"><span class="pre">fixed128x18</span></code>, <code class="docutils literal"><span class="pre">ufixed128x18</span></code> respectively. For computing the function selector, <code class="docutils literal"><span class="pre">fixed128x18</span></code> and <code class="docutils literal"><span class="pre">ufixed128x18</span></code> have to be used.</li>
<li><code class="docutils literal"><span class="pre">bytes&lt;M&gt;</span></code>: binary type of <code class="docutils literal"><span class="pre">M</span></code> bytes, <code class="docutils literal"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">M</span> <span class="pre">&lt;=</span> <span class="pre">32</span></code>.</li>
<li><code class="docutils literal"><span class="pre">function</span></code>: an address (20 bytes) followed by a function selector (4 bytes). Encoded identical to <code class="docutils literal"><span class="pre">bytes24</span></code>.</li>
</ul>
<p>存在以下(固定大小)数组类型:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">&lt;type&gt;[M]</span></code>: a fixed-length array of <code class="docutils literal"><span class="pre">M</span></code> elements, <code class="docutils literal"><span class="pre">M</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code>, of the given type.</li>
</ul>
<p>存在以下非固定大小的类型:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">bytes</span></code>: dynamic sized byte sequence.</li>
<li><code class="docutils literal"><span class="pre">string</span></code>: dynamic sized unicode string assumed to be UTF-8 encoded.</li>
<li><code class="docutils literal"><span class="pre">&lt;type&gt;[]</span></code>: a variable-length array of elements of the given type.</li>
</ul>
<p>可以将类型组合成一个元组，将有限的非负号括在括号内，用逗号分隔:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">(T1,T2,...,Tn)</span></code>: tuple consisting of the types <code class="docutils literal"><span class="pre">T1</span></code>, …, <code class="docutils literal"><span class="pre">Tn</span></code>, <code class="docutils literal"><span class="pre">n</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></li>
</ul>
<p>可以形成元组元组、元组数组等。也可以形成零元组(其中n == 0)。<code class="docutils literal"><span class="pre">n</span> <span class="pre">==</span> <span class="pre">0</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Solidity支持上述类型的所有类型，除了tuple之外，它们都具有相同的名称。使用ABI tuple类型编码Solidity struct。<code class="docutils literal"><span class="pre">structs</span></code></p>
</div>
</div>
<div class="section" id="formal-specification-of-the-encoding">
<h3>Formal Specification of the Encoding<a class="headerlink" href="#formal-specification-of-the-encoding" title="Permalink to this headline">¶</a></h3>
<p>现在我们将正式地指定编码，这样它将具有以下属性，如果某些参数是嵌套的数组，这将特别有用:</p>
<p>属性:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The number of reads necessary to access a value is at most the depth of the value inside the argument array structure, i.e. four reads are needed to retrieve <code class="docutils literal"><span class="pre">a_i[k][l][r]</span></code>. In a previous version of the ABI, the number of reads scaled linearly with the total number of dynamic parameters in the worst case.</li>
<li>The data of a variable or array element is not interleaved with other data and it is relocatable, i.e. it only uses relative “addresses”</li>
</ol>
</div></blockquote>
<p>我们区分静态类型和动态类型。静态类型是编码的，动态类型是在当前块之后在单独分配的位置进行编码的。</p>
<p><strong>Definition:</strong>定义:以下类型被称为“动态”:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">bytes</span></code></li>
<li><code class="docutils literal"><span class="pre">string</span></code></li>
<li><code class="docutils literal"><span class="pre">T[]</span></code> for any <code class="docutils literal"><span class="pre">T</span></code></li>
<li><code class="docutils literal"><span class="pre">T[k]</span></code> for any dynamic <code class="docutils literal"><span class="pre">T</span></code> and any <code class="docutils literal"><span class="pre">k</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code></li>
<li><code class="docutils literal"><span class="pre">(T1,...,Tk)</span></code> if <code class="docutils literal"><span class="pre">Ti</span></code> is dynamic for some <code class="docutils literal"><span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">i</span> <span class="pre">&lt;=</span> <span class="pre">k</span></code></li>
</ul>
<p>所有其他类型都称为“静态”。</p>
<p><strong>Definition:</strong>定义:len(a)是二进制字符串a中的字节数。len(a)的类型假定为uint256。<code class="docutils literal"><span class="pre">len(a)</span></code><code class="docutils literal"><span class="pre">a</span></code><code class="docutils literal"><span class="pre">len(a)</span></code><code class="docutils literal"><span class="pre">uint256</span></code></p>
<p>我们定义了enc，即实际的编码，将ABI类型的值映射为二进制字符串，len(enc(X))依赖于X的值，如果且仅当X的类型是动态的。<code class="docutils literal"><span class="pre">enc</span></code><code class="docutils literal"><span class="pre">len(enc(X))</span></code><code class="docutils literal"><span class="pre">X</span></code><code class="docutils literal"><span class="pre">X</span></code></p>
<p><strong>Definition:</strong>定义:对于任何ABI值X，我们递归地定义enc(X)，依赖于X的类型。<code class="docutils literal"><span class="pre">X</span></code><code class="docutils literal"><span class="pre">enc(X)</span></code><code class="docutils literal"><span class="pre">X</span></code></p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">(T1,...,Tk)</span></code> for <code class="docutils literal"><span class="pre">k</span> <span class="pre">&gt;=</span> <span class="pre">0</span></code> and any types <code class="docutils literal"><span class="pre">T1</span></code>, …, <code class="docutils literal"><span class="pre">Tk</span></code></p>
<p><code class="docutils literal"><span class="pre">enc(X)</span> <span class="pre">=</span> <span class="pre">head(X(1))</span> <span class="pre">...</span> <span class="pre">head(X(k))</span> <span class="pre">tail(X(1))</span> <span class="pre">...</span> <span class="pre">tail(X(k))</span></code></p>
<p>X = (X(1))(X(k))、头和尾的定义为，Ti为静态类型。<code class="docutils literal"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">(X(1),</span> <span class="pre">...,</span> <span class="pre">X(k))</span></code><code class="docutils literal"><span class="pre">head</span></code><code class="docutils literal"><span class="pre">tail</span></code><code class="docutils literal"><span class="pre">Ti</span></code></p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">head(X(i))</span> <span class="pre">=</span> <span class="pre">enc(X(i))</span></code>head(X(i)) = enc(X(i))和tail(X(i)) = ""(空字符串)<code class="docutils literal"><span class="pre">tail(X(i))</span> <span class="pre">=</span> <span class="pre">""</span></code></p>
</div></blockquote>
<p>当</p>
<blockquote>
<div><p><code class="docutils literal"><span class="pre">head(X(i))</span> <span class="pre">=</span> <span class="pre">enc(len(head(X(1))</span> <span class="pre">...</span> <span class="pre">head(X(k))</span> <span class="pre">tail(X(1))</span> <span class="pre">...</span> <span class="pre">tail(X(i-1))</span> <span class="pre">))</span></code>头(X(i))= enc(len(头(X(1))…头(X(k))尾(X(1))…尾(X(张))))的尾巴(X(i))= enc(X(i))<code class="docutils literal"><span class="pre">tail(X(i))</span> <span class="pre">=</span> <span class="pre">enc(X(i))</span></code></p>
</div></blockquote>
<p>否则，即如果Ti是动态类型。<code class="docutils literal"><span class="pre">Ti</span></code></p>
<p>注意，在动态情况下，head(X(i))是定义良好的，因为头部分的长度只取决于类型而不是值。它的值是尾端(X(i))相对于enc(X)的起始值。<code class="docutils literal"><span class="pre">head(X(i))</span></code><code class="docutils literal"><span class="pre">tail(X(i))</span></code><code class="docutils literal"><span class="pre">enc(X)</span></code></p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">T[k]</span></code> for any <code class="docutils literal"><span class="pre">T</span></code> and <code class="docutils literal"><span class="pre">k</span></code>:</p>
<p><code class="docutils literal"><span class="pre">enc(X)</span> <span class="pre">=</span> <span class="pre">enc((X[0],</span> <span class="pre">...,</span> <span class="pre">X[k-1]))</span></code></p>
<p>也就是说，它被编码成与同一类型的k元素的元组。<code class="docutils literal"><span class="pre">k</span></code></p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">T[]</span></code> where <code class="docutils literal"><span class="pre">X</span></code> has <code class="docutils literal"><span class="pre">k</span></code> elements (<code class="docutils literal"><span class="pre">k</span></code> is assumed to be of type <code class="docutils literal"><span class="pre">uint256</span></code>):</p>
<p><code class="docutils literal"><span class="pre">enc(X)</span> <span class="pre">=</span> <span class="pre">enc(k)</span> <span class="pre">enc([X[0],</span> <span class="pre">...,</span> <span class="pre">X[k-1]])</span></code></p>
<p>也就是说，它被编码成一个静态大小k的数组，前缀为元素的数量。<code class="docutils literal"><span class="pre">k</span></code></p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">bytes</span></code>, of length <code class="docutils literal"><span class="pre">k</span></code> (which is assumed to be of type <code class="docutils literal"><span class="pre">uint256</span></code>):</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">enc(X)</span> <span class="pre">=</span> <span class="pre">enc(k)</span> <span class="pre">pad_right(X)</span></code>, i.e. the number of bytes is encoded as a</dt>
<dd><p class="first last"><code class="docutils literal"><span class="pre">uint256</span></code>uint256紧随其后的是X作为字节序列的实际值，其次是最小的零字节数，len(enc(X))是32的倍数。<code class="docutils literal"><span class="pre">X</span></code><code class="docutils literal"><span class="pre">len(enc(X))</span></code></p>
</dd>
</dl>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">string</span></code>:</p>
<p><code class="docutils literal"><span class="pre">enc(X)</span> <span class="pre">=</span> <span class="pre">enc(enc_utf8(X))</span></code>enc(X) = enc(enc_utf8(X))，即X是utf-8编码的，这个值被解释为字节类型，并进行了进一步编码。注意，在随后的编码中使用的长度是utf-8编码字符串的字节数，而不是它的字符数。<code class="docutils literal"><span class="pre">X</span></code><code class="docutils literal"><span class="pre">bytes</span></code></p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">uint&lt;M&gt;</span></code>: <code class="docutils literal"><span class="pre">enc(X)</span></code> is the big-endian encoding of <code class="docutils literal"><span class="pre">X</span></code>, padded on the higher-order (left) side with zero-bytes such that the length is 32 bytes.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">address</span></code>: as in the <code class="docutils literal"><span class="pre">uint160</span></code> case</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">int&lt;M&gt;</span></code>: <code class="docutils literal"><span class="pre">enc(X)</span></code> is the big-endian two’s complement encoding of <code class="docutils literal"><span class="pre">X</span></code>, padded on the higher-order (left) side with <code class="docutils literal"><span class="pre">0xff</span></code> for negative <code class="docutils literal"><span class="pre">X</span></code> and with zero bytes for positive <code class="docutils literal"><span class="pre">X</span></code> such that the length is 32 bytes.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">bool</span></code>: as in the <code class="docutils literal"><span class="pre">uint8</span></code> case, where <code class="docutils literal"><span class="pre">1</span></code> is used for <code class="docutils literal"><span class="pre">true</span></code> and <code class="docutils literal"><span class="pre">0</span></code> for <code class="docutils literal"><span class="pre">false</span></code></p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">fixed&lt;M&gt;x&lt;N&gt;</span></code>: <code class="docutils literal"><span class="pre">enc(X)</span></code> is <code class="docutils literal"><span class="pre">enc(X</span> <span class="pre">*</span> <span class="pre">10**N)</span></code> where <code class="docutils literal"><span class="pre">X</span> <span class="pre">*</span> <span class="pre">10**N</span></code> is interpreted as a <code class="docutils literal"><span class="pre">int256</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">fixed</span></code>: as in the <code class="docutils literal"><span class="pre">fixed128x18</span></code> case</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ufixed&lt;M&gt;x&lt;N&gt;</span></code>: <code class="docutils literal"><span class="pre">enc(X)</span></code> is <code class="docutils literal"><span class="pre">enc(X</span> <span class="pre">*</span> <span class="pre">10**N)</span></code> where <code class="docutils literal"><span class="pre">X</span> <span class="pre">*</span> <span class="pre">10**N</span></code> is interpreted as a <code class="docutils literal"><span class="pre">uint256</span></code>.</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">ufixed</span></code>: as in the <code class="docutils literal"><span class="pre">ufixed128x18</span></code> case</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">bytes&lt;M&gt;</span></code>: <code class="docutils literal"><span class="pre">enc(X)</span></code> is the sequence of bytes in <code class="docutils literal"><span class="pre">X</span></code> padded with trailing zero-bytes to a length of 32 bytes.</p>
</li>
</ul>
<p>注意，对于任何X, len(enc(X))是32的倍数。<code class="docutils literal"><span class="pre">X</span></code><code class="docutils literal"><span class="pre">len(enc(X))</span></code></p>
</div>
<div class="section" id="function-selector-and-argument-encoding">
<h3>Function Selector and Argument Encoding<a class="headerlink" href="#function-selector-and-argument-encoding" title="Permalink to this headline">¶</a></h3>
<p>总之，调用函数f和参数a_1，…，a_n被编码为。<code class="docutils literal"><span class="pre">f</span></code><code class="docutils literal"><span class="pre">a_1,</span> <span class="pre">...,</span> <span class="pre">a_n</span></code></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">function_selector(f)</span> <span class="pre">enc((a_1,</span> <span class="pre">...,</span> <span class="pre">a_n))</span></code></div></blockquote>
<p>返回值v_1，…，v_k (f)编码为。<code class="docutils literal"><span class="pre">v_1,</span> <span class="pre">...,</span> <span class="pre">v_k</span></code><code class="docutils literal"><span class="pre">f</span></code></p>
<blockquote>
<div><code class="docutils literal"><span class="pre">enc((v_1,</span> <span class="pre">...,</span> <span class="pre">v_k))</span></code></div></blockquote>
<p>即将这些值组合成一个元组并进行编码。</p>
</div>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<p>鉴于合约:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Foo</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">bar</span><span class="p">(</span><span class="kt">bytes3</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="k">public</span> <span class="k">pure</span> <span class="p">{}</span>
  <span class="kd">function</span> <span class="nx">baz</span><span class="p">(</span><span class="kt">uint32</span> <span class="nx">x</span><span class="p">,</span> <span class="kt">bool</span> <span class="nx">y</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span> <span class="nx">r</span><span class="p">)</span> <span class="p">{</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">32</span> <span class="o">||</span> <span class="nx">y</span><span class="p">;</span> <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">sam</span><span class="p">(</span><span class="kt">bytes</span><span class="p">,</span> <span class="kt">bool</span><span class="p">,</span> <span class="kt">uint</span><span class="p">[])</span> <span class="k">public</span> <span class="k">pure</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>因此，对于我们的Foo示例，如果我们想要调用baz，参数为69和true，我们将传递68字节的总数，可以分解为:<code class="docutils literal"><span class="pre">Foo</span></code><code class="docutils literal"><span class="pre">baz</span></code><code class="docutils literal"><span class="pre">69</span></code><code class="docutils literal"><span class="pre">true</span></code></p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">0xcdcd77c0</span></code>: the Method ID. This is derived as the first 4 bytes of the Keccak hash of the ASCII form of the signature <code class="docutils literal"><span class="pre">baz(uint32,bool)</span></code>.</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000045</span></code>: the first parameter, a uint32 value <code class="docutils literal"><span class="pre">69</span></code> padded to 32 bytes</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000001</span></code>: the second parameter - boolean <code class="docutils literal"><span class="pre">true</span></code>, padded to 32 bytes</li>
</ul>
<p>总计:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="mh">0xcdcd77c000000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001</span>
</pre></div>
</div>
<p>它返回一个单一的bool。例如，如果它返回false，其输出将是单个字节数组0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000，一个bool。<code class="docutils literal"><span class="pre">bool</span></code><code class="docutils literal"><span class="pre">false</span></code><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000000</span></code></p>
<p>如果我们想用这个参数来调用bar ["abc"， "def"]，我们总共会超过68个字节，分解成:<code class="docutils literal"><span class="pre">bar</span></code><code class="docutils literal"><span class="pre">["abc",</span> <span class="pre">"def"]</span></code></p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">0xfce353f6</span></code>: the Method ID. This is derived from the signature <code class="docutils literal"><span class="pre">bar(bytes3[2])</span></code>.</li>
<li><code class="docutils literal"><span class="pre">0x6162630000000000000000000000000000000000000000000000000000000000</span></code>: the first part of the first parameter, a <code class="docutils literal"><span class="pre">bytes3</span></code> value <code class="docutils literal"><span class="pre">"abc"</span></code> (left-aligned).</li>
<li><code class="docutils literal"><span class="pre">0x6465660000000000000000000000000000000000000000000000000000000000</span></code>: the second part of the first parameter, a <code class="docutils literal"><span class="pre">bytes3</span></code> value <code class="docutils literal"><span class="pre">"def"</span></code> (left-aligned).</li>
</ul>
<p>总计:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="mh">0xfce353f661626300000000000000000000000000000000000000000000000000000000006465660000000000000000000000000000000000000000000000000000000000</span>
</pre></div>
</div>
<p>如果我们想用“dave”，true和[1,2,3]来给sam打电话，我们总共会传递292字节，分解为:<code class="docutils literal"><span class="pre">sam</span></code><code class="docutils literal"><span class="pre">"dave"</span></code><code class="docutils literal"><span class="pre">true</span></code><code class="docutils literal"><span class="pre">[1,2,3]</span></code></p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">0xa5643bf2</span></code>: the Method ID. This is derived from the signature <code class="docutils literal"><span class="pre">sam(bytes,bool,uint256[])</span></code>. Note that <code class="docutils literal"><span class="pre">uint</span></code> is replaced with its canonical representation <code class="docutils literal"><span class="pre">uint256</span></code>.</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000060</span></code>: the location of the data part of the first parameter (dynamic type), measured in bytes from the start of the arguments block. In this case, <code class="docutils literal"><span class="pre">0x60</span></code>.</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000001</span></code>: the second parameter: boolean true.</li>
<li><code class="docutils literal"><span class="pre">0x00000000000000000000000000000000000000000000000000000000000000a0</span></code>: the location of the data part of the third parameter (dynamic type), measured in bytes. In this case, <code class="docutils literal"><span class="pre">0xa0</span></code>.</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000004</span></code>: the data part of the first argument, it starts with the length of the byte array in elements, in this case, 4.</li>
<li><code class="docutils literal"><span class="pre">0x6461766500000000000000000000000000000000000000000000000000000000</span></code>: the contents of the first argument: the UTF-8 (equal to ASCII in this case) encoding of <code class="docutils literal"><span class="pre">"dave"</span></code>, padded on the right to 32 bytes.</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000003</span></code>: the data part of the third argument, it starts with the length of the array in elements, in this case, 3.</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000001</span></code>: the first entry of the third parameter.</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000002</span></code>: the second entry of the third parameter.</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000003</span></code>: the third entry of the third parameter.</li>
</ul>
<p>总计:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="mh">0xa5643bf20000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003</span>
</pre></div>
</div>
</div>
<div class="section" id="use-of-dynamic-types">
<h3>Use of Dynamic Types<a class="headerlink" href="#use-of-dynamic-types" title="Permalink to this headline">¶</a></h3>
<p>使用值(0x123， [0x456, 0x789]， "1234567890"， "Hello, world!")的一个函数调用，以如下方式编码:<code class="docutils literal"><span class="pre">f(uint,uint32[],bytes10,bytes)</span></code><code class="docutils literal"><span class="pre">(0x123,</span> <span class="pre">[0x456,</span> <span class="pre">0x789],</span> <span class="pre">"1234567890",</span> <span class="pre">"Hello,</span> <span class="pre">world!")</span></code></p>
<p>我们使用sha3的前四个字节(“f(uint256,uint32[]，bytes10,bytes)”)，即0x8be65246。然后我们对四个参数的头部进行编码。静态类型uint256 bytes10,这些是我们想通过直接的价值,而对于动态类型uint32[]和字节,我们使用开始的偏移字节的数据区域,从一开始测量值的编码(即不包括前四个字节包含函数的散列签名)。这些都是:<code class="docutils literal"><span class="pre">sha3("f(uint256,uint32[],bytes10,bytes)")</span></code><code class="docutils literal"><span class="pre">0x8be65246</span></code><code class="docutils literal"><span class="pre">uint256</span></code><code class="docutils literal"><span class="pre">bytes10</span></code><code class="docutils literal"><span class="pre">uint32[]</span></code><code class="docutils literal"><span class="pre">bytes</span></code></p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000123</span></code> (<code class="docutils literal"><span class="pre">0x123</span></code> padded to 32 bytes)</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000080</span></code> (offset to start of data part of second parameter, 4*32 bytes, exactly the size of the head part)</li>
<li><code class="docutils literal"><span class="pre">0x3132333435363738393000000000000000000000000000000000000000000000</span></code> (<code class="docutils literal"><span class="pre">"1234567890"</span></code> padded to 32 bytes on the right)</li>
<li><code class="docutils literal"><span class="pre">0x00000000000000000000000000000000000000000000000000000000000000e0</span></code> (offset to start of data part of fourth parameter = offset to start of data part of first dynamic parameter + size of data part of first dynamic parameter = 4*32 + 3*32 (see below))</li>
</ul>
</div></blockquote>
<p>在此之后，第一个动态参数的数据部分[0x456, 0x789]如下:<code class="docutils literal"><span class="pre">[0x456,</span> <span class="pre">0x789]</span></code></p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000002</span></code> (number of elements of the array, 2)</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000456</span></code> (first element)</li>
<li><code class="docutils literal"><span class="pre">0x0000000000000000000000000000000000000000000000000000000000000789</span></code> (second element)</li>
</ul>
</div></blockquote>
<p>最后，我们对第二个动态参数的数据部分进行编码:“Hello, world!”<code class="docutils literal"><span class="pre">"Hello,</span> <span class="pre">world!"</span></code></p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">0x000000000000000000000000000000000000000000000000000000000000000d</span></code> (number of elements (bytes in this case): 13)</li>
<li><code class="docutils literal"><span class="pre">0x48656c6c6f2c20776f726c642100000000000000000000000000000000000000</span></code> (<code class="docutils literal"><span class="pre">"Hello,</span> <span class="pre">world!"</span></code> padded to 32 bytes on the right)</li>
</ul>
</div></blockquote>
<p>总之，编码是(在函数选择器和每个32字节后的新行):</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="mh">0x8be65246</span>
  <span class="mi">0000000000000000000000000000000000000000000000000000000000000123</span>
  <span class="mi">0000000000000000000000000000000000000000000000000000000000000080</span>
  <span class="mi">3132333435363738393000000000000000000000000000000000000000000000</span>
  <span class="mi">00000000000000000000000000000000000000000000000000000000000000e0</span>
  <span class="mi">0000000000000000000000000000000000000000000000000000000000000002</span>
  <span class="mi">0000000000000000000000000000000000000000000000000000000000000456</span>
  <span class="mi">0000000000000000000000000000000000000000000000000000000000000789</span>
  <span class="mi">000000000000000000000000000000000000000000000000000000000000000</span><span class="nx">d</span>
  <span class="mi">48656</span><span class="nx">c6c6f2c20776f726c642100000000000000000000000000000000000000</span>
</pre></div>
</div>
</div>
<div class="section" id="events">
<h3>Events<a class="headerlink" href="#events" title="Permalink to this headline">¶</a></h3>
<p>事件是Ethereum日志/事件观察协议的抽象。日志条目提供了合约的地址，包含四个主题和一些任意长度的二进制数据。事件利用现有的函数ABI来解释这个(连同接口规范)作为一个适当的类型结构。</p>
<p>给定一个事件名称和一系列事件参数，我们将它们划分为两个子系列:那些被索引的和不被索引的。那些被索引的(可能是3)和事件签名的Keccak散列一起使用，以形成日志条目的主题。那些没有被索引的，形成事件的字节数组。</p>
<p>实际上，使用这个ABI的日志条目被描述为:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">address</span></code>: the address of the contract (intrinsically provided by Ethereum);</li>
<li><code class="docutils literal"><span class="pre">topics[0]</span></code>: <code class="docutils literal"><span class="pre">keccak(EVENT_NAME+"("+EVENT_ARGS.map(canonical_type_of).join(",")+")")</span></code> (<code class="docutils literal"><span class="pre">canonical_type_of</span></code> is a function that simply returns the canonical type of a given argument, e.g. for <code class="docutils literal"><span class="pre">uint</span> <span class="pre">indexed</span> <span class="pre">foo</span></code>, it would return <code class="docutils literal"><span class="pre">uint256</span></code>). If the event is declared as <code class="docutils literal"><span class="pre">anonymous</span></code> the <code class="docutils literal"><span class="pre">topics[0]</span></code> is not generated;</li>
<li><code class="docutils literal"><span class="pre">topics[n]</span></code>: <code class="docutils literal"><span class="pre">EVENT_INDEXED_ARGS[n</span> <span class="pre">-</span> <span class="pre">1]</span></code> (<code class="docutils literal"><span class="pre">EVENT_INDEXED_ARGS</span></code> is the series of <code class="docutils literal"><span class="pre">EVENT_ARGS</span></code> that are indexed);</li>
<li><code class="docutils literal"><span class="pre">data</span></code>: <code class="docutils literal"><span class="pre">abi_serialise(EVENT_NON_INDEXED_ARGS)</span></code> (<code class="docutils literal"><span class="pre">EVENT_NON_INDEXED_ARGS</span></code> is the series of <code class="docutils literal"><span class="pre">EVENT_ARGS</span></code> that are not indexed, <code class="docutils literal"><span class="pre">abi_serialise</span></code> is the ABI serialisation function used for returning a series of typed values from a function, as described above).</li>
</ul>
<p>对于所有固定长度的Solidity类型，EVENT_INDEXED_ARGS数组直接包含32字节的编码值。然而，对于类型的动态长度，包括字符串、字节和数组，EVENT_INDEXED_ARGS将包含编码值的Keccak散列，而不是直接编码的值。这允许应用程序有效地查询动态长度类型的值(通过将编码值的散列设置为主题)，但是使应用程序无法解码它们没有查询的索引值。对于动态长度类型，应用程序开发人员在快速搜索预先确定的值(如果参数被索引)和任意值的易读性(要求不被索引的参数)之间进行权衡。开发人员可以通过定义带有两个参数的事件(一个是索引的，一个不是用来保存相同的值)来克服这个权衡，并实现高效的搜索和任意的易读性。<code class="docutils literal"><span class="pre">EVENT_INDEXED_ARGS</span></code><em>types of dynamic length</em><code class="docutils literal"><span class="pre">string</span></code><code class="docutils literal"><span class="pre">bytes</span></code><code class="docutils literal"><span class="pre">EVENT_INDEXED_ARGS</span></code><em>Keccak hash</em></p>
</div>
<div class="section" id="json">
<span id="abi-json"></span><h3>JSON<a class="headerlink" href="#json" title="Permalink to this headline">¶</a></h3>
<p>合约接口的JSON格式由一系列函数和/或事件描述提供。函数描述是一个带有字段的JSON对象:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">type</span></code>: <code class="docutils literal"><span class="pre">"function"</span></code>, <code class="docutils literal"><span class="pre">"constructor"</span></code>, or <code class="docutils literal"><span class="pre">"fallback"</span></code> (the <a class="reference internal" href="index.html#fallback-function"><span class="std std-ref">unnamed “default” function</span></a>);</li>
<li><code class="docutils literal"><span class="pre">name</span></code>: the name of the function;</li>
<li><code class="docutils literal"><span class="pre">inputs</span></code>: an array of objects, each of which contains:<ul>
<li><code class="docutils literal"><span class="pre">name</span></code>: the name of the parameter;</li>
<li><code class="docutils literal"><span class="pre">type</span></code>: the canonical type of the parameter (more below).</li>
<li><code class="docutils literal"><span class="pre">components</span></code>: used for tuple types (more below).</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">outputs</span></code>: an array of objects similar to <code class="docutils literal"><span class="pre">inputs</span></code>, can be omitted if function doesn’t return anything;</li>
<li><code class="docutils literal"><span class="pre">payable</span></code>: <code class="docutils literal"><span class="pre">true</span></code> if function accepts ether, defaults to <code class="docutils literal"><span class="pre">false</span></code>;</li>
<li><code class="docutils literal"><span class="pre">stateMutability</span></code>: a string with one of the following values: <code class="docutils literal"><span class="pre">pure</span></code> (<a class="reference internal" href="index.html#pure-functions"><span class="std std-ref">specified to not read blockchain state</span></a>), <code class="docutils literal"><span class="pre">view</span></code> (<a class="reference internal" href="index.html#view-functions"><span class="std std-ref">specified to not modify the blockchain state</span></a>), <code class="docutils literal"><span class="pre">nonpayable</span></code> and <code class="docutils literal"><span class="pre">payable</span></code> (same as <code class="docutils literal"><span class="pre">payable</span></code> above).</li>
<li><code class="docutils literal"><span class="pre">constant</span></code>: <code class="docutils literal"><span class="pre">true</span></code> if function is either <code class="docutils literal"><span class="pre">pure</span></code> or <code class="docutils literal"><span class="pre">view</span></code></li>
</ul>
<p><code class="docutils literal"><span class="pre">type</span></code>类型可以省略，默认为“函数”。<code class="docutils literal"><span class="pre">"function"</span></code></p>
<p>构造函数和回退函数没有名称或输出。回退函数也没有输入。<code class="docutils literal"><span class="pre">name</span></code><code class="docutils literal"><span class="pre">outputs</span></code><code class="docutils literal"><span class="pre">inputs</span></code></p>
<p>将非零的乙醚发送到不可支付的函数将会被抛出。不要这样做。</p>
<p>事件描述是一个具有相当相似字段的JSON对象:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">type</span></code>: always <code class="docutils literal"><span class="pre">"event"</span></code></li>
<li><code class="docutils literal"><span class="pre">name</span></code>: the name of the event;</li>
<li><code class="docutils literal"><span class="pre">inputs</span></code>: an array of objects, each of which contains:<ul>
<li><code class="docutils literal"><span class="pre">name</span></code>: the name of the parameter;</li>
<li><code class="docutils literal"><span class="pre">type</span></code>: the canonical type of the parameter (more below).</li>
<li><code class="docutils literal"><span class="pre">components</span></code>: used for tuple types (more below).</li>
<li><code class="docutils literal"><span class="pre">indexed</span></code>: <code class="docutils literal"><span class="pre">true</span></code> if the field is part of the log’s topics, <code class="docutils literal"><span class="pre">false</span></code> if it one of the log’s data segment.</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">anonymous</span></code>: <code class="docutils literal"><span class="pre">true</span></code> if the event was declared as <code class="docutils literal"><span class="pre">anonymous</span></code>.</li>
</ul>
<p>例如,</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Test</span> <span class="p">{</span>
  <span class="kd">function</span> <span class="nx">Test</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">b</span> <span class="o">=</span> <span class="mh">0x12345678901234567890123456789012</span><span class="p">;</span> <span class="p">}</span>
  <span class="kd">event</span> <span class="nx">Event</span><span class="p">(</span><span class="kt">uint</span> <span class="k">indexed</span> <span class="nx">a</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="nx">b</span><span class="p">);</span>
  <span class="kd">event</span> <span class="nx">Event2</span><span class="p">(</span><span class="kt">uint</span> <span class="k">indexed</span> <span class="nx">a</span><span class="p">,</span> <span class="kt">bytes32</span> <span class="nx">b</span><span class="p">);</span>
  <span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">a</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">Event</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="p">}</span>
  <span class="kt">bytes32</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>会导致JSON:</p>
<div class="code json highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">[{</span>
<span class="s2">"type"</span><span class="o">:</span><span class="s2">"event"</span><span class="p">,</span>
<span class="s2">"inputs"</span><span class="o">:</span> <span class="p">[{</span><span class="s2">"name"</span><span class="o">:</span><span class="s2">"a"</span><span class="p">,</span><span class="s2">"type"</span><span class="o">:</span><span class="s2">"uint256"</span><span class="p">,</span><span class="s2">"indexed"</span><span class="o">:</span><span class="kc">true</span><span class="p">},{</span><span class="s2">"name"</span><span class="o">:</span><span class="s2">"b"</span><span class="p">,</span><span class="s2">"type"</span><span class="o">:</span><span class="s2">"bytes32"</span><span class="p">,</span><span class="s2">"indexed"</span><span class="o">:</span><span class="kc">false</span><span class="p">}],</span>
<span class="s2">"name"</span><span class="o">:</span><span class="s2">"Event"</span>
<span class="p">},</span> <span class="p">{</span>
<span class="s2">"type"</span><span class="o">:</span><span class="s2">"event"</span><span class="p">,</span>
<span class="s2">"inputs"</span><span class="o">:</span> <span class="p">[{</span><span class="s2">"name"</span><span class="o">:</span><span class="s2">"a"</span><span class="p">,</span><span class="s2">"type"</span><span class="o">:</span><span class="s2">"uint256"</span><span class="p">,</span><span class="s2">"indexed"</span><span class="o">:</span><span class="kc">true</span><span class="p">},{</span><span class="s2">"name"</span><span class="o">:</span><span class="s2">"b"</span><span class="p">,</span><span class="s2">"type"</span><span class="o">:</span><span class="s2">"bytes32"</span><span class="p">,</span><span class="s2">"indexed"</span><span class="o">:</span><span class="kc">false</span><span class="p">}],</span>
<span class="s2">"name"</span><span class="o">:</span><span class="s2">"Event2"</span>
<span class="p">},</span> <span class="p">{</span>
<span class="s2">"type"</span><span class="o">:</span><span class="s2">"function"</span><span class="p">,</span>
<span class="s2">"inputs"</span><span class="o">:</span> <span class="p">[{</span><span class="s2">"name"</span><span class="o">:</span><span class="s2">"a"</span><span class="p">,</span><span class="s2">"type"</span><span class="o">:</span><span class="s2">"uint256"</span><span class="p">}],</span>
<span class="s2">"name"</span><span class="o">:</span><span class="s2">"foo"</span><span class="p">,</span>
<span class="s2">"outputs"</span><span class="o">:</span> <span class="p">[]</span>
<span class="p">}]</span>
</pre></div>
</div>
<div class="section" id="handling-tuple-types">
<h4>Handling tuple types<a class="headerlink" href="#handling-tuple-types" title="Permalink to this headline">¶</a></h4>
<p>尽管这些名称并不是ABI编码的一部分，但它们确实很有意义，可以包含在JSON中，以便将其显示给最终用户。该结构的嵌套方式如下:</p>
<p>具有成员名称、类型和潜在组件的对象描述类型变量。规范化类型决定,直到达到一个tuple类型和字符串描述到这一点是存储在类型前缀词元组,即它将元组之后面试官的序列[]和[k]withintegers k。元组的组件组件,然后存储在成员的数组类型和有相同的结构为顶级对象除了thatindexed是不允许的。<code class="docutils literal"><span class="pre">name</span></code><code class="docutils literal"><span class="pre">type</span></code><code class="docutils literal"><span class="pre">components</span></code><code class="docutils literal"><span class="pre">type</span></code><code class="docutils literal"><span class="pre">tuple</span></code><code class="docutils literal"><span class="pre">tuple</span></code><code class="docutils literal"><span class="pre">[]</span></code><code class="docutils literal"><span class="pre">[k]</span></code><code class="docutils literal"><span class="pre">k</span></code><code class="docutils literal"><span class="pre">components</span></code><code class="docutils literal"><span class="pre">indexed</span></code></p>
<p>作为一个例子，代码。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">19</span><span class="p">;</span>
<span class="k">pragma</span> <span class="nx">experimental</span> <span class="nx">ABIEncoderV2</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">Test</span> <span class="p">{</span>
  <span class="kd">struct</span> <span class="nx">S</span> <span class="p">{</span> <span class="kt">uint</span> <span class="nx">a</span><span class="p">;</span> <span class="kt">uint</span><span class="p">[]</span> <span class="nx">b</span><span class="p">;</span> <span class="nx">T</span><span class="p">[]</span> <span class="nx">c</span><span class="p">;</span> <span class="p">}</span>
  <span class="kd">struct</span> <span class="nx">T</span> <span class="p">{</span> <span class="kt">uint</span> <span class="nx">x</span><span class="p">;</span> <span class="kt">uint</span> <span class="nx">y</span><span class="p">;</span> <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="nx">S</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">t</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">a</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span> <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">g</span><span class="p">()</span> <span class="k">public</span> <span class="k">returns</span> <span class="p">(</span><span class="nx">S</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">T</span> <span class="nx">t</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>会导致JSON:</p>
<div class="code json highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">[</span>
  <span class="p">{</span>
    <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"f"</span><span class="p">,</span>
    <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"function"</span><span class="p">,</span>
    <span class="s2">"inputs"</span><span class="o">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"s"</span><span class="p">,</span>
        <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"tuple"</span><span class="p">,</span>
        <span class="s2">"components"</span><span class="o">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"a"</span><span class="p">,</span>
            <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"uint256"</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"b"</span><span class="p">,</span>
            <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"uint256[]"</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"c"</span><span class="p">,</span>
            <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"tuple[]"</span><span class="p">,</span>
            <span class="s2">"components"</span><span class="o">:</span> <span class="p">[</span>
              <span class="p">{</span>
                <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"x"</span><span class="p">,</span>
                <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"uint256"</span>
              <span class="p">},</span>
              <span class="p">{</span>
                <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"y"</span><span class="p">,</span>
                <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"uint256"</span>
              <span class="p">}</span>
            <span class="p">]</span>
          <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"t"</span><span class="p">,</span>
        <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"tuple"</span><span class="p">,</span>
        <span class="s2">"components"</span><span class="o">:</span> <span class="p">[</span>
          <span class="p">{</span>
            <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"x"</span><span class="p">,</span>
            <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"uint256"</span>
          <span class="p">},</span>
          <span class="p">{</span>
            <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"y"</span><span class="p">,</span>
            <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"uint256"</span>
          <span class="p">}</span>
        <span class="p">]</span>
      <span class="p">},</span>
      <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"a"</span><span class="p">,</span>
        <span class="s2">"type"</span><span class="o">:</span> <span class="s2">"uint256"</span>
      <span class="p">}</span>
    <span class="p">],</span>
    <span class="s2">"outputs"</span><span class="o">:</span> <span class="p">[]</span>
  <span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="non-standard-packed-mode">
<span id="abi-packed-mode"></span><h3>Non-standard Packed Mode<a class="headerlink" href="#non-standard-packed-mode" title="Permalink to this headline">¶</a></h3>
<p>Solidity支持非标准包装模式:</p>
<ul class="simple">
<li>no <a class="reference internal" href="#abi-function-selector"><span class="std std-ref">function selector</span></a> is encoded,</li>
<li>types shorter than 32 bytes are neither zero padded nor sign extended and</li>
<li>dynamic types are encoded in-place and without the length.</li>
</ul>
<p>作为一个编码int1、bytes1、uint16的示例，字符串的值为-1,0x42, 0x2424，“Hello, world!”<code class="docutils literal"><span class="pre">int1,</span> <span class="pre">bytes1,</span> <span class="pre">uint16,</span> <span class="pre">string</span></code><code class="docutils literal"><span class="pre">-1,</span> <span class="pre">0x42,</span> <span class="pre">0x2424,</span> <span class="pre">"Hello,</span> <span class="pre">world!"</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="mh">0xff42242448656c6c6f2c20776f726c6421</span>
  <span class="o">^^</span>                                 <span class="nx">int1</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="o">^^</span>                               <span class="kt">bytes1</span><span class="p">(</span><span class="mh">0x42</span><span class="p">)</span>
      <span class="o">^^^^</span>                           <span class="kt">uint16</span><span class="p">(</span><span class="mh">0x2424</span><span class="p">)</span>
          <span class="o">^^^^^^^^^^^^^^^^^^^^^^^^^^</span> <span class="kt">string</span><span class="p">(</span><span class="s2">"Hello, world!"</span><span class="p">)</span> <span class="nx">without</span> <span class="nx">a</span> <span class="nx">length</span> <span class="nx">field</span>
</pre></div>
</div>
<p>更具体地说，每个静态大小的类型占用的字节数都与它的范围和动态大小的类型相同，比如字符串、字节或uint[]都被编码到它们的长度字段中。这意味着，一旦有两种动态大小的元素，编码就会变得模糊。<code class="docutils literal"><span class="pre">string</span></code><code class="docutils literal"><span class="pre">bytes</span></code><code class="docutils literal"><span class="pre">uint[]</span></code></p>
</div>
</div>
<span id="document-julia"></span><div class="section" id="joyfully-universal-language-for-inline-assembly">
<h2>Joyfully Universal Language for (Inline) Assembly<a class="headerlink" href="#joyfully-universal-language-for-inline-assembly" title="Permalink to this headline">¶</a></h2>
<span class="target" id="julia"></span><p id="index-0">朱莉娅是一种中间语言，可以编译到各种不同的后端(EVM 1.0、EVM 1.5和eWASM)。正因为如此，它被设计成所有三个平台的可用公分母。它已经可以被用于“内联汇编”，在Solidity和未来版本的Solidity编译器甚至会使用JULIA作为中间语言。为JULIA构建高级优化器阶段也应该很容易。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">注意，用于“内联汇编”的味道没有类型(所有的东西都是u256)，内置函数都是EVM操作码的identicalto。请使用内联汇编文档获取详细信息。<code class="docutils literal"><span class="pre">u256</span></code></p>
</div>
<p>JULIA的核心组件是函数、块、变量、文字、for-loop、if-statement、switch-statement、表达式和赋值。</p>
<p>JULIA是类型化的，变量和文字都必须用后缀表示法来指定类型。支持的类型有bool、u8、s8、u32、s32、u64、s64、u128、s128、u256和s256。<code class="docutils literal"><span class="pre">bool</span></code><code class="docutils literal"><span class="pre">u8</span></code><code class="docutils literal"><span class="pre">s8</span></code><code class="docutils literal"><span class="pre">u32</span></code><code class="docutils literal"><span class="pre">s32</span></code><code class="docutils literal"><span class="pre">u64</span></code><code class="docutils literal"><span class="pre">s64</span></code><code class="docutils literal"><span class="pre">u128</span></code><code class="docutils literal"><span class="pre">s128</span></code><code class="docutils literal"><span class="pre">u256</span></code><code class="docutils literal"><span class="pre">s256</span></code></p>
<p>朱莉娅本身甚至没有提供操作人员。如果将EVM作为目标，那么操作码将作为内置函数可用，但它们可以重新实现后端更改。有关强制内置函数的列表，请参见下面的部分。</p>
<p>下面的示例程序假设EVM操作码mul、divand mod可以使用本机或作为函数，并计算取幂。<code class="docutils literal"><span class="pre">mul</span></code><code class="docutils literal"><span class="pre">div</span></code><code class="docutils literal"><span class="pre">mod</span></code></p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kd">function</span> <span class="nx">power</span><span class="p">(</span><span class="nx">base</span><span class="o">:</span><span class="nx">u256</span><span class="p">,</span> <span class="nx">exponent</span><span class="o">:</span><span class="nx">u256</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">result</span><span class="o">:</span><span class="nx">u256</span>
    <span class="p">{</span>
        <span class="kr">switch</span> <span class="nx">exponent</span>
        <span class="kr">case</span> <span class="mi">0</span><span class="o">:</span><span class="nx">u256</span> <span class="p">{</span> <span class="nx">result</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">:</span><span class="nx">u256</span> <span class="p">}</span>
        <span class="kr">case</span> <span class="mi">1</span><span class="o">:</span><span class="nx">u256</span> <span class="p">{</span> <span class="nx">result</span> <span class="o">:=</span> <span class="nx">base</span> <span class="p">}</span>
        <span class="kr">default</span><span class="o">:</span>
        <span class="p">{</span>
            <span class="nx">result</span> <span class="o">:=</span> <span class="nx">power</span><span class="p">(</span><span class="nx">mul</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">base</span><span class="p">),</span> <span class="nx">div</span><span class="p">(</span><span class="nx">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="nx">u256</span><span class="p">))</span>
            <span class="kr">switch</span> <span class="nx">mod</span><span class="p">(</span><span class="nx">exponent</span><span class="p">,</span> <span class="mi">2</span><span class="o">:</span><span class="nx">u256</span><span class="p">)</span>
                <span class="kr">case</span> <span class="mi">1</span><span class="o">:</span><span class="nx">u256</span> <span class="p">{</span> <span class="nx">result</span> <span class="o">:=</span> <span class="nx">mul</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">result</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>也可以使用for循环来实现相同的函数，而不是使用递归。在这里，我们需要EVM操作码lt(小于)并添加可用。<code class="docutils literal"><span class="pre">lt</span></code><code class="docutils literal"><span class="pre">add</span></code></p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kd">function</span> <span class="nx">power</span><span class="p">(</span><span class="nx">base</span><span class="o">:</span><span class="nx">u256</span><span class="p">,</span> <span class="nx">exponent</span><span class="o">:</span><span class="nx">u256</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">result</span><span class="o">:</span><span class="nx">u256</span>
    <span class="p">{</span>
        <span class="nx">result</span> <span class="o">:=</span> <span class="mi">1</span><span class="o">:</span><span class="nx">u256</span>
        <span class="k">for</span> <span class="p">{</span> <span class="kr">let</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="o">:</span><span class="nx">u256</span> <span class="p">}</span> <span class="nx">lt</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">exponent</span><span class="p">)</span> <span class="p">{</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">add</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="mi">1</span><span class="o">:</span><span class="nx">u256</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">{</span>
            <span class="nx">result</span> <span class="o">:=</span> <span class="nx">mul</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span> <span class="nx">base</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="specification-of-julia">
<h3>Specification of JULIA<a class="headerlink" href="#specification-of-julia" title="Permalink to this headline">¶</a></h3>
<p>JULIA代码在本章中描述。朱莉娅的代码通常被放置在朱莉娅的对象中，在下一章中描述。</p>
<p>语法:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">Block</span> <span class="o">=</span> <span class="s1">'{'</span> <span class="nx">Statement</span><span class="o">*</span> <span class="s1">'}'</span>
<span class="nx">Statement</span> <span class="o">=</span>
    <span class="nx">Block</span> <span class="o">|</span>
    <span class="nx">FunctionDefinition</span> <span class="o">|</span>
    <span class="nx">VariableDeclaration</span> <span class="o">|</span>
    <span class="nx">Assignment</span> <span class="o">|</span>
    <span class="nx">Expression</span> <span class="o">|</span>
    <span class="nx">Switch</span> <span class="o">|</span>
    <span class="nx">ForLoop</span> <span class="o">|</span>
    <span class="nx">BreakContinue</span>
<span class="nx">FunctionDefinition</span> <span class="o">=</span>
    <span class="s1">'function'</span> <span class="nx">Identifier</span> <span class="s1">'('</span> <span class="nx">TypedIdentifierList</span><span class="o">?</span> <span class="s1">')'</span>
    <span class="p">(</span> <span class="s1">'-&gt;'</span> <span class="nx">TypedIdentifierList</span> <span class="p">)</span><span class="o">?</span> <span class="nx">Block</span>
<span class="nx">VariableDeclaration</span> <span class="o">=</span>
    <span class="s1">'let'</span> <span class="nx">TypedIdentifierList</span> <span class="p">(</span> <span class="s1">':='</span> <span class="nx">Expression</span> <span class="p">)</span><span class="o">?</span>
<span class="nx">Assignment</span> <span class="o">=</span>
    <span class="nx">IdentifierList</span> <span class="s1">':='</span> <span class="nx">Expression</span>
<span class="nx">Expression</span> <span class="o">=</span>
    <span class="nx">FunctionCall</span> <span class="o">|</span> <span class="nx">Identifier</span> <span class="o">|</span> <span class="nx">Literal</span>
<span class="nx">If</span> <span class="o">=</span>
    <span class="s1">'if'</span> <span class="nx">Expression</span> <span class="nx">Block</span>
<span class="nx">Switch</span> <span class="o">=</span>
    <span class="s1">'switch'</span> <span class="nx">Expression</span> <span class="nx">Case</span><span class="o">*</span> <span class="p">(</span> <span class="s1">'default'</span> <span class="nx">Block</span> <span class="p">)</span><span class="o">?</span>
<span class="nx">Case</span> <span class="o">=</span>
    <span class="s1">'case'</span> <span class="nx">Literal</span> <span class="nx">Block</span>
<span class="nx">ForLoop</span> <span class="o">=</span>
    <span class="s1">'for'</span> <span class="nx">Block</span> <span class="nx">Expression</span> <span class="nx">Block</span> <span class="nx">Block</span>
<span class="nx">BreakContinue</span> <span class="o">=</span>
    <span class="s1">'break'</span> <span class="o">|</span> <span class="s1">'continue'</span>
<span class="nx">FunctionCall</span> <span class="o">=</span>
    <span class="nx">Identifier</span> <span class="s1">'('</span> <span class="p">(</span> <span class="nx">Expression</span> <span class="p">(</span> <span class="s1">','</span> <span class="nx">Expression</span> <span class="p">)</span><span class="o">*</span> <span class="p">)</span><span class="o">?</span> <span class="s1">')'</span>
<span class="nx">Identifier</span> <span class="o">=</span> <span class="p">[</span><span class="nx">a</span><span class="o">-</span><span class="nx">zA</span><span class="o">-</span><span class="nx">Z_$</span><span class="p">]</span> <span class="p">[</span><span class="nx">a</span><span class="o">-</span><span class="nx">zA</span><span class="o">-</span><span class="nx">Z_0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">*</span>
<span class="nx">IdentifierList</span> <span class="o">=</span> <span class="nx">Identifier</span> <span class="p">(</span> <span class="s1">','</span> <span class="nx">Identifier</span><span class="p">)</span><span class="o">*</span>
<span class="nx">TypeName</span> <span class="o">=</span> <span class="nx">Identifier</span> <span class="o">|</span> <span class="nx">BuiltinTypeName</span>
<span class="nx">BuiltinTypeName</span> <span class="o">=</span> <span class="s1">'bool'</span> <span class="o">|</span> <span class="p">[</span><span class="nx">us</span><span class="p">]</span> <span class="p">(</span> <span class="s1">'8'</span> <span class="o">|</span> <span class="s1">'32'</span> <span class="o">|</span> <span class="s1">'64'</span> <span class="o">|</span> <span class="s1">'128'</span> <span class="o">|</span> <span class="s1">'256'</span> <span class="p">)</span>
<span class="nx">TypedIdentifierList</span> <span class="o">=</span> <span class="nx">Identifier</span> <span class="s1">':'</span> <span class="nx">TypeName</span> <span class="p">(</span> <span class="s1">','</span> <span class="nx">Identifier</span> <span class="s1">':'</span> <span class="nx">TypeName</span> <span class="p">)</span><span class="o">*</span>
<span class="nx">Literal</span> <span class="o">=</span>
    <span class="p">(</span><span class="nx">NumberLiteral</span> <span class="o">|</span> <span class="nx">StringLiteral</span> <span class="o">|</span> <span class="nx">HexLiteral</span> <span class="o">|</span> <span class="nx">TrueLiteral</span> <span class="o">|</span> <span class="nx">FalseLiteral</span><span class="p">)</span> <span class="s1">':'</span> <span class="nx">TypeName</span>
<span class="nx">NumberLiteral</span> <span class="o">=</span> <span class="nx">HexNumber</span> <span class="o">|</span> <span class="nx">DecimalNumber</span>
<span class="nx">HexLiteral</span> <span class="o">=</span> <span class="s1">'hex'</span> <span class="p">(</span><span class="s1">'"'</span> <span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="nx">a</span><span class="o">-</span><span class="nx">fA</span><span class="o">-</span><span class="nx">F</span><span class="p">]{</span><span class="mi">2</span><span class="p">})</span><span class="o">*</span> <span class="s1">'"'</span> <span class="o">|</span> <span class="s1">'\''</span> <span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="nx">a</span><span class="o">-</span><span class="nx">fA</span><span class="o">-</span><span class="nx">F</span><span class="p">]{</span><span class="mi">2</span><span class="p">})</span><span class="o">*</span> <span class="s1">'\''</span><span class="p">)</span>
<span class="nx">StringLiteral</span> <span class="o">=</span> <span class="s1">'"'</span> <span class="p">([</span><span class="o">^</span><span class="s2">"\r\n\\] | '\\' .)* '"</span><span class="s1">'</span>
<span class="s1">TrueLiteral = '</span><span class="kc">true</span><span class="s1">'</span>
<span class="s1">FalseLiteral = '</span><span class="kc">false</span><span class="s1">'</span>
<span class="s1">HexNumber = '</span><span class="mi">0</span><span class="nx">x</span><span class="err">'</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="nx">a</span><span class="o">-</span><span class="nx">fA</span><span class="o">-</span><span class="nx">F</span><span class="p">]</span><span class="o">+</span>
<span class="nx">DecimalNumber</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span><span class="o">+</span>
</pre></div>
</div>
<div class="section" id="restrictions-on-the-grammar">
<h4>Restrictions on the Grammar<a class="headerlink" href="#restrictions-on-the-grammar" title="Permalink to this headline">¶</a></h4>
<p>交换机必须至少有一个案例(包括默认情况)。如果该表达式的所有可能值都被覆盖，则不应该允许默认情况(即使用bool表达式的开关，同时有atrue和false case不允许出现默认情况)。<code class="docutils literal"><span class="pre">bool</span></code></p>
<p>每个表达式的值都为0或更多。对一个值和函数调用的标识符和常量值的值与调用函数的返回值的数量相等。</p>
<p>在变量声明和赋值中，右撇子表达式(如果存在)必须对多个值进行计算，这些值等于左侧的变量数。这是唯一一个可以对多个值进行评估的情况。</p>
<p>表达式，也就是语句(在块级别上)必须计算为零值。</p>
<p>在所有其他情况下，表达式必须精确地计算一个值。</p>
<p>continue和break语句只能在循环内使用，并且必须与循环相同(或者两者都必须在顶层)。for循环的条件部分必须精确地计算一个值。<code class="docutils literal"><span class="pre">continue</span></code><code class="docutils literal"><span class="pre">break</span></code></p>
<p>文字不能大于它们的类型。定义的最大类型是256位宽。</p>
</div>
<div class="section" id="scoping-rules">
<h4>Scoping Rules<a class="headerlink" href="#scoping-rules" title="Permalink to this headline">¶</a></h4>
<p>在JULIA中，作用域与块(异常是函数，for loopas)绑定在一起，所有的声明(FunctionDefinition, VariableDeclaration)都将新的标识符引入到这些范围中。<code class="docutils literal"><span class="pre">FunctionDefinition</span></code><code class="docutils literal"><span class="pre">VariableDeclaration</span></code></p>
<p>标识符在其定义的块中可见(包括所有子节点和子块)。作为一个例外，在for循环(第一个块)的“init”部分中定义的标识符在for循环的所有其他部分(但不是在循环之外)都可以看到。在for循环的其他部分中声明的标识符会遵守正则化的范围规则。函数的参数和返回参数在函数体中是可见的，它们的名称不能重叠。</p>
<p>变量只能在声明之后引用。特别是，变量不能在他们自己的变量声明的右边引用。函数可以在声明之前引用(如果它们是可见的)。</p>
<p>阴影是不允许的，也就是说，您不能在另一个具有相同名称的标识符的点上声明标识符，即使它是不可访问的。</p>
<p>在函数内部，不可能访问在该函数之外声明的变量。</p>
</div>
<div class="section" id="formal-specification">
<h4>Formal Specification<a class="headerlink" href="#formal-specification" title="Permalink to this headline">¶</a></h4>
<p>我们正式指定了JULIA，提供了一个评估函数E重载了AST的各个节点，任何函数都可以有副作用，soE接收了两个状态对象和AST节点，并返回两个newstate对象和一个变量的其他值。两个状态对象是全局状态对象(在EVM的上下文中是区块链的内存、存储和状态)和本地状态对象(局部变量的状态，即在EVM中的堆栈)。如果AST节点是一个语句，则返回两个状态对象和一个“模式”，该模式用于中断和继续语句。如果AST节点是一个表达式，那么E将返回两个状态对象，以及表达式求值的多个值。<code class="docutils literal"><span class="pre">break</span></code><code class="docutils literal"><span class="pre">continue</span></code></p>
<p>对于这个高水平的描述，全局状态的确切性质是不确定的。局部状态L是标识符i到v的映射，表示为L[i] = v。<code class="docutils literal"><span class="pre">L</span></code><code class="docutils literal"><span class="pre">i</span></code><code class="docutils literal"><span class="pre">v</span></code><code class="docutils literal"><span class="pre">L[i]</span> <span class="pre">=</span> <span class="pre">v</span></code></p>
<p>对于一个标识符v，让$v为标识符的名称。<code class="docutils literal"><span class="pre">v</span></code><code class="docutils literal"><span class="pre">$v</span></code></p>
<p>我们将使用对AST节点的析构符号。</p>
<div class="code highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="o">&lt;</span><span class="p">{</span><span class="nx">St1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">Stn</span><span class="p">}</span><span class="o">&gt;:</span> <span class="nx">Block</span><span class="p">)</span> <span class="o">=</span>
    <span class="kr">let</span> <span class="nx">G1</span><span class="p">,</span> <span class="nx">L1</span><span class="p">,</span> <span class="nx">mode</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">St1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">Stn</span><span class="p">)</span>
    <span class="kr">let</span> <span class="nx">L2</span> <span class="nx">be</span> <span class="nx">a</span> <span class="nx">restriction</span> <span class="kr">of</span> <span class="nx">L1</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">identifiers</span> <span class="kr">of</span> <span class="nx">L</span>
    <span class="nx">G1</span><span class="p">,</span> <span class="nx">L2</span><span class="p">,</span> <span class="nx">mode</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">St1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">Stn</span><span class="o">:</span> <span class="nx">Statement</span><span class="p">)</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="k">is</span> <span class="nx">zero</span><span class="o">:</span>
        <span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">regular</span>
    <span class="k">else</span><span class="o">:</span>
        <span class="kr">let</span> <span class="nx">G1</span><span class="p">,</span> <span class="nx">L1</span><span class="p">,</span> <span class="nx">mode</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">St1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">mode</span> <span class="k">is</span> <span class="nx">regular</span> <span class="nx">then</span>
            <span class="nx">E</span><span class="p">(</span><span class="nx">G1</span><span class="p">,</span> <span class="nx">L1</span><span class="p">,</span> <span class="nx">St2</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">Stn</span><span class="p">)</span>
        <span class="nx">otherwise</span>
            <span class="nx">G1</span><span class="p">,</span> <span class="nx">L1</span><span class="p">,</span> <span class="nx">mode</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">FunctionDefinition</span><span class="p">)</span> <span class="o">=</span>
    <span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">regular</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="o">&lt;</span><span class="kr">let</span> <span class="nx">var1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">varn</span> <span class="o">:=</span> <span class="nx">rhs</span><span class="o">&gt;:</span> <span class="nx">VariableDeclaration</span><span class="p">)</span> <span class="o">=</span>
    <span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="o">&lt;</span><span class="nx">var1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">varn</span> <span class="o">:=</span> <span class="nx">rhs</span><span class="o">&gt;:</span> <span class="nx">Assignment</span><span class="p">)</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="o">&lt;</span><span class="kr">let</span> <span class="nx">var1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">varn</span><span class="o">&gt;:</span> <span class="nx">VariableDeclaration</span><span class="p">)</span> <span class="o">=</span>
    <span class="kr">let</span> <span class="nx">L1</span> <span class="nx">be</span> <span class="nx">a</span> <span class="nx">copy</span> <span class="kr">of</span> <span class="nx">L</span> <span class="nx">where</span> <span class="nx">L1</span><span class="p">[</span><span class="nx">$vari</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">for</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">n</span>
    <span class="nx">G</span><span class="p">,</span> <span class="nx">L1</span><span class="p">,</span> <span class="nx">regular</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="o">&lt;</span><span class="nx">var1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">varn</span> <span class="o">:=</span> <span class="nx">rhs</span><span class="o">&gt;:</span> <span class="nx">Assignment</span><span class="p">)</span> <span class="o">=</span>
    <span class="kr">let</span> <span class="nx">G1</span><span class="p">,</span> <span class="nx">L1</span><span class="p">,</span> <span class="nx">v1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">vn</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">rhs</span><span class="p">)</span>
    <span class="kr">let</span> <span class="nx">L2</span> <span class="nx">be</span> <span class="nx">a</span> <span class="nx">copy</span> <span class="kr">of</span> <span class="nx">L1</span> <span class="nx">where</span> <span class="nx">L2</span><span class="p">[</span><span class="nx">$vari</span><span class="p">]</span> <span class="o">=</span> <span class="nx">vi</span> <span class="k">for</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">...,</span> <span class="nx">n</span>
    <span class="nx">G</span><span class="p">,</span> <span class="nx">L2</span><span class="p">,</span> <span class="nx">regular</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="o">&lt;</span><span class="k">for</span> <span class="p">{</span> <span class="nx">i1</span><span class="p">,</span> <span class="p">...,</span> <span class="kr">in</span> <span class="p">}</span> <span class="nx">condition</span> <span class="nx">post</span> <span class="nx">body</span><span class="o">&gt;:</span> <span class="nx">ForLoop</span><span class="p">)</span> <span class="o">=</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">:</span>
        <span class="kr">let</span> <span class="nx">G1</span><span class="p">,</span> <span class="nx">L1</span><span class="p">,</span> <span class="nx">mode</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">i1</span><span class="p">,</span> <span class="p">...,</span> <span class="kr">in</span><span class="p">)</span>
        <span class="c1">// mode has to be regular due to the syntactic restrictions</span>
        <span class="kr">let</span> <span class="nx">G2</span><span class="p">,</span> <span class="nx">L2</span><span class="p">,</span> <span class="nx">mode</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">G1</span><span class="p">,</span> <span class="nx">L1</span><span class="p">,</span> <span class="k">for</span> <span class="p">{}</span> <span class="nx">condition</span> <span class="nx">post</span> <span class="nx">body</span><span class="p">)</span>
        <span class="c1">// mode has to be regular due to the syntactic restrictions</span>
        <span class="kr">let</span> <span class="nx">L3</span> <span class="nx">be</span> <span class="nx">the</span> <span class="nx">restriction</span> <span class="kr">of</span> <span class="nx">L2</span> <span class="nx">to</span> <span class="nx">only</span> <span class="nx">variables</span> <span class="kr">of</span> <span class="nx">L</span>
        <span class="nx">G2</span><span class="p">,</span> <span class="nx">L3</span><span class="p">,</span> <span class="nx">regular</span>
    <span class="k">else</span><span class="o">:</span>
        <span class="kr">let</span> <span class="nx">G1</span><span class="p">,</span> <span class="nx">L1</span><span class="p">,</span> <span class="nx">v</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">condition</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">v</span> <span class="k">is</span> <span class="kc">false</span><span class="o">:</span>
            <span class="nx">G1</span><span class="p">,</span> <span class="nx">L1</span><span class="p">,</span> <span class="nx">regular</span>
        <span class="k">else</span><span class="o">:</span>
            <span class="kr">let</span> <span class="nx">G2</span><span class="p">,</span> <span class="nx">L2</span><span class="p">,</span> <span class="nx">mode</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">G1</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">body</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">mode</span> <span class="k">is</span> <span class="k">break</span><span class="o">:</span>
                <span class="nx">G2</span><span class="p">,</span> <span class="nx">L2</span><span class="p">,</span> <span class="nx">regular</span>
            <span class="k">else</span><span class="o">:</span>
                <span class="nx">G3</span><span class="p">,</span> <span class="nx">L3</span><span class="p">,</span> <span class="nx">mode</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">G2</span><span class="p">,</span> <span class="nx">L2</span><span class="p">,</span> <span class="nx">post</span><span class="p">)</span>
                <span class="nx">E</span><span class="p">(</span><span class="nx">G3</span><span class="p">,</span> <span class="nx">L3</span><span class="p">,</span> <span class="k">for</span> <span class="p">{}</span> <span class="nx">condition</span> <span class="nx">post</span> <span class="nx">body</span><span class="p">)</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="k">break</span><span class="o">:</span> <span class="nx">BreakContinue</span><span class="p">)</span> <span class="o">=</span>
    <span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="k">break</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="k">continue</span><span class="o">:</span> <span class="nx">BreakContinue</span><span class="p">)</span> <span class="o">=</span>
    <span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="k">continue</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="o">&lt;</span><span class="k">if</span> <span class="nx">condition</span> <span class="nx">body</span><span class="o">&gt;:</span> <span class="nx">If</span><span class="p">)</span> <span class="o">=</span>
    <span class="kr">let</span> <span class="nx">G0</span><span class="p">,</span> <span class="nx">L0</span><span class="p">,</span> <span class="nx">v</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">condition</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">v</span> <span class="k">is</span> <span class="kc">true</span><span class="o">:</span>
        <span class="nx">E</span><span class="p">(</span><span class="nx">G0</span><span class="p">,</span> <span class="nx">L0</span><span class="p">,</span> <span class="nx">body</span><span class="p">)</span>
    <span class="k">else</span><span class="o">:</span>
        <span class="nx">G0</span><span class="p">,</span> <span class="nx">L0</span><span class="p">,</span> <span class="nx">regular</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="o">&lt;</span><span class="kr">switch</span> <span class="nx">condition</span> <span class="kr">case</span> <span class="nx">l1</span><span class="o">:</span><span class="nx">t1</span> <span class="nx">st1</span> <span class="p">...</span> <span class="kr">case</span> <span class="nx">ln</span><span class="o">:</span><span class="nx">tn</span> <span class="nx">stn</span><span class="o">&gt;:</span> <span class="nx">Switch</span><span class="p">)</span> <span class="o">=</span>
    <span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="kr">switch</span> <span class="nx">condition</span> <span class="kr">case</span> <span class="nx">l1</span><span class="o">:</span><span class="nx">t1</span> <span class="nx">st1</span> <span class="p">...</span> <span class="kr">case</span> <span class="nx">ln</span><span class="o">:</span><span class="nx">tn</span> <span class="nx">stn</span> <span class="kr">default</span> <span class="p">{})</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="o">&lt;</span><span class="kr">switch</span> <span class="nx">condition</span> <span class="kr">case</span> <span class="nx">l1</span><span class="o">:</span><span class="nx">t1</span> <span class="nx">st1</span> <span class="p">...</span> <span class="kr">case</span> <span class="nx">ln</span><span class="o">:</span><span class="nx">tn</span> <span class="nx">stn</span> <span class="kr">default</span> <span class="nx">st</span><span class="s1">'&gt;: Switch) =</span>
<span class="s1">    let G0, L0, v = E(G, L, condition)</span>
<span class="s1">    // i = 1 .. n</span>
<span class="s1">    // Evaluate literals, context doesn'</span><span class="nx">t</span> <span class="nx">matter</span>
    <span class="kr">let</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v1</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">G0</span><span class="p">,</span> <span class="nx">L0</span><span class="p">,</span> <span class="nx">l1</span><span class="p">)</span>
    <span class="p">...</span>
    <span class="kr">let</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">vn</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">G0</span><span class="p">,</span> <span class="nx">L0</span><span class="p">,</span> <span class="nx">ln</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">there</span> <span class="nx">exists</span> <span class="nx">smallest</span> <span class="nx">i</span> <span class="nx">such</span> <span class="nx">that</span> <span class="nx">vi</span> <span class="o">=</span> <span class="nx">v</span><span class="o">:</span>
        <span class="nx">E</span><span class="p">(</span><span class="nx">G0</span><span class="p">,</span> <span class="nx">L0</span><span class="p">,</span> <span class="nx">sti</span><span class="p">)</span>
    <span class="k">else</span><span class="o">:</span>
        <span class="nx">E</span><span class="p">(</span><span class="nx">G0</span><span class="p">,</span> <span class="nx">L0</span><span class="p">,</span> <span class="nx">st</span><span class="s1">')</span>

<span class="s1">E(G, L, &lt;name&gt;: Identifier) =</span>
<span class="s1">    G, L, L[$name]</span>
<span class="s1">E(G, L, &lt;fname(arg1, ..., argn)&gt;: FunctionCall) =</span>
<span class="s1">    G1, L1, vn = E(G, L, argn)</span>
<span class="s1">    ...</span>
<span class="s1">    G(n-1), L(n-1), v2 = E(G(n-2), L(n-2), arg2)</span>
<span class="s1">    Gn, Ln, v1 = E(G(n-1), L(n-1), arg1)</span>
<span class="s1">    Let &lt;function fname (param1, ..., paramn) -&gt; ret1, ..., retm block&gt;</span>
<span class="s1">    be the function of name $fname visible at the point of the call.</span>
<span class="s1">    Let L'</span> <span class="nx">be</span> <span class="nx">a</span> <span class="k">new</span> <span class="nx">local</span> <span class="nx">state</span> <span class="nx">such</span> <span class="nx">that</span>
    <span class="nx">L</span><span class="s1">'[$parami] = vi and L'</span><span class="p">[</span><span class="nx">$reti</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">for</span> <span class="nx">all</span> <span class="nx">i</span><span class="p">.</span>
    <span class="nx">Let</span> <span class="nx">G</span><span class="s1">''</span><span class="p">,</span> <span class="nx">L</span><span class="s1">''</span><span class="p">,</span> <span class="nx">mode</span> <span class="o">=</span> <span class="nx">E</span><span class="p">(</span><span class="nx">Gn</span><span class="p">,</span> <span class="nx">L</span><span class="s1">', block)</span>
<span class="s1">    G'', Ln, L''[$ret1], ..., L'</span><span class="err">'</span><span class="p">[</span><span class="nx">$retm</span><span class="p">]</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">l</span><span class="o">:</span> <span class="nx">HexLiteral</span><span class="p">)</span> <span class="o">=</span> <span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">hexString</span><span class="p">(</span><span class="nx">l</span><span class="p">),</span>
    <span class="nx">where</span> <span class="nx">hexString</span> <span class="nx">decodes</span> <span class="nx">l</span> <span class="nx">from</span> <span class="k">hex</span> <span class="nx">and</span> <span class="nx">left</span><span class="o">-</span><span class="nx">aligns</span> <span class="nx">it</span> <span class="nx">into</span> <span class="mi">32</span> <span class="kt">bytes</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">l</span><span class="o">:</span> <span class="nx">StringLiteral</span><span class="p">)</span> <span class="o">=</span> <span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">utf8EncodeLeftAligned</span><span class="p">(</span><span class="nx">l</span><span class="p">),</span>
    <span class="nx">where</span> <span class="nx">utf8EncodeLeftAligned</span> <span class="nx">performs</span> <span class="nx">a</span> <span class="nx">utf8</span> <span class="nx">encoding</span> <span class="kr">of</span> <span class="nx">l</span>
    <span class="nx">and</span> <span class="nx">aligns</span> <span class="nx">it</span> <span class="nx">left</span> <span class="nx">into</span> <span class="mi">32</span> <span class="kt">bytes</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">n</span><span class="o">:</span> <span class="nx">HexNumber</span><span class="p">)</span> <span class="o">=</span> <span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="k">hex</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
    <span class="nx">where</span> <span class="k">hex</span> <span class="k">is</span> <span class="nx">the</span> <span class="nx">hexadecimal</span> <span class="nx">decoding</span> <span class="kd">function</span>
<span class="nx">E</span><span class="p">(</span><span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">n</span><span class="o">:</span> <span class="nx">DecimalNumber</span><span class="p">)</span> <span class="o">=</span> <span class="nx">G</span><span class="p">,</span> <span class="nx">L</span><span class="p">,</span> <span class="nx">dec</span><span class="p">(</span><span class="nx">n</span><span class="p">),</span>
    <span class="nx">where</span> <span class="nx">dec</span> <span class="k">is</span> <span class="nx">the</span> <span class="nx">decimal</span> <span class="nx">decoding</span> <span class="kd">function</span>
</pre></div>
</div>
</div>
<div class="section" id="type-conversion-functions">
<h4>Type Conversion Functions<a class="headerlink" href="#type-conversion-functions" title="Permalink to this headline">¶</a></h4>
<p>JULIA不支持隐式类型转换，因此函数存在提供显式转换。当将较大的类型转换为较短的类型时，在发生溢出时可以发生运行时异常。</p>
<dl class="docutils">
<dt>Truncating conversions are supported between the following types:</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">bool</span></code></li>
<li><code class="docutils literal"><span class="pre">u32</span></code></li>
<li><code class="docutils literal"><span class="pre">u64</span></code></li>
<li><code class="docutils literal"><span class="pre">u256</span></code></li>
<li><code class="docutils literal"><span class="pre">s256</span></code></li>
</ul>
</dd>
</dl>
<p>对于每一个类型转换函数，都有一个原型以&lt;input_type&gt;到&lt;output_type&gt;(x:&lt;input_type&gt;) -&gt; y:&lt;output_type&gt;，如u32tobool(x:u32) -&gt; y:bool, u256tou32(x:u256) - &gt;y:u32或s256tou256(x:s256) -&gt; y:u256。<code class="docutils literal"><span class="pre">&lt;input_type&gt;to&lt;output_type&gt;(x:&lt;input_type&gt;)</span> <span class="pre">-&gt;</span> <span class="pre">y:&lt;output_type&gt;</span></code><code class="docutils literal"><span class="pre">u32tobool(x:u32)</span> <span class="pre">-&gt;</span> <span class="pre">y:bool</span></code><code class="docutils literal"><span class="pre">u256tou32(x:u256)</span> <span class="pre">-&gt;</span> <span class="pre">y:u32</span></code><code class="docutils literal"><span class="pre">s256tou256(x:s256)</span> <span class="pre">-&gt;</span> <span class="pre">y:u256</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">u32tobool(x:u32)</span> <span class="pre">-&gt;</span> <span class="pre">y:bool</span></code>u32tobool(x:u32) -&gt; y:bool可实现为y: = not(iszerou256(x))和booltou32(x:bool) -&gt; y:u32可实现为switch x case true:bool {y: = 1:u32} case false:bool {y: = 0:u32}<code class="docutils literal"><span class="pre">y</span> <span class="pre">:=</span> <span class="pre">not(iszerou256(x))</span></code><code class="docutils literal"><span class="pre">booltou32(x:bool)</span> <span class="pre">-&gt;</span> <span class="pre">y:u32</span></code><code class="docutils literal"><span class="pre">switch</span> <span class="pre">x</span> <span class="pre">case</span> <span class="pre">true:bool</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">1:u32</span> <span class="pre">}</span> <span class="pre">case</span> <span class="pre">false:bool</span> <span class="pre">{</span> <span class="pre">y</span> <span class="pre">:=</span> <span class="pre">0:u32</span> <span class="pre">}</span></code></p>
</div>
</div>
<div class="section" id="low-level-functions">
<h4>Low-level Functions<a class="headerlink" href="#low-level-functions" title="Permalink to this headline">¶</a></h4>
<p>必须具备以下功能:</p>
<table border="1" class="docutils">
<colgroup>
<col width="41%"/>
<col width="59%"/>
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td colspan="2"><em>Logic</em></td>
</tr>
<tr class="row-even"><td>not(x:bool) -&gt; z:bool</td>
<td>logical not</td>
</tr>
<tr class="row-odd"><td>and(x:bool, y:bool) -&gt; z:bool</td>
<td>logical and</td>
</tr>
<tr class="row-even"><td>or(x:bool, y:bool) -&gt; z:bool</td>
<td>logical or</td>
</tr>
<tr class="row-odd"><td>xor(x:bool, y:bool) -&gt; z:bool</td>
<td>xor</td>
</tr>
<tr class="row-even"><td colspan="2"><em>Arithmetics</em></td>
</tr>
<tr class="row-odd"><td>addu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x + y</td>
</tr>
<tr class="row-even"><td>subu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x - y</td>
</tr>
<tr class="row-odd"><td>mulu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x * y</td>
</tr>
<tr class="row-even"><td>divu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x / y</td>
</tr>
<tr class="row-odd"><td>divs256(x:s256, y:s256) -&gt; z:s256</td>
<td>x / y, for signed numbers in two’s complement</td>
</tr>
<tr class="row-even"><td>modu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x % y</td>
</tr>
<tr class="row-odd"><td>mods256(x:s256, y:s256) -&gt; z:s256</td>
<td>x % y, for signed numbers in two’s complement</td>
</tr>
<tr class="row-even"><td>signextendu256(i:u256, x:u256) -&gt; z:u256</td>
<td>sign extend from (i*8+7)th bit counting from least significant</td>
</tr>
<tr class="row-odd"><td>expu256(x:u256, y:u256) -&gt; z:u256</td>
<td>x to the power of y</td>
</tr>
<tr class="row-even"><td>addmodu256(x:u256, y:u256, m:u256) -&gt; z:u256</td>
<td>(x + y) % m with arbitrary precision arithmetics</td>
</tr>
<tr class="row-odd"><td>mulmodu256(x:u256, y:u256, m:u256) -&gt; z:u256</td>
<td>(x * y) % m with arbitrary precision arithmetics</td>
</tr>
<tr class="row-even"><td>ltu256(x:u256, y:u256) -&gt; z:bool</td>
<td>true if x &lt; y, false otherwise</td>
</tr>
<tr class="row-odd"><td>gtu256(x:u256, y:u256) -&gt; z:bool</td>
<td>true if x &gt; y, false otherwise</td>
</tr>
<tr class="row-even"><td>sltu256(x:s256, y:s256) -&gt; z:bool</td>
<td>true if x &lt; y, false otherwise
(for signed numbers in two’s complement)</td>
</tr>
<tr class="row-odd"><td>sgtu256(x:s256, y:s256) -&gt; z:bool</td>
<td>true if x &gt; y, false otherwise
(for signed numbers in two’s complement)</td>
</tr>
<tr class="row-even"><td>equ256(x:u256, y:u256) -&gt; z:bool</td>
<td>true if x == y, false otherwise</td>
</tr>
<tr class="row-odd"><td>iszerou256(x:u256) -&gt; z:bool</td>
<td>true if x == 0, false otherwise</td>
</tr>
<tr class="row-even"><td>notu256(x:u256) -&gt; z:u256</td>
<td>~x, every bit of x is negated</td>
</tr>
<tr class="row-odd"><td>andu256(x:u256, y:u256) -&gt; z:u256</td>
<td>bitwise and of x and y</td>
</tr>
<tr class="row-even"><td>oru256(x:u256, y:u256) -&gt; z:u256</td>
<td>bitwise or of x and y</td>
</tr>
<tr class="row-odd"><td>xoru256(x:u256, y:u256) -&gt; z:u256</td>
<td>bitwise xor of x and y</td>
</tr>
<tr class="row-even"><td>shlu256(x:u256, y:u256) -&gt; z:u256</td>
<td>logical left shift of x by y</td>
</tr>
<tr class="row-odd"><td>shru256(x:u256, y:u256) -&gt; z:u256</td>
<td>logical right shift of x by y</td>
</tr>
<tr class="row-even"><td>saru256(x:u256, y:u256) -&gt; z:u256</td>
<td>arithmetic right shift of x by y</td>
</tr>
<tr class="row-odd"><td>byte(n:u256, x:u256) -&gt; v:u256</td>
<td>nth byte of x, where the most significant byte is the 0th byte
Cannot this be just replaced by and256(shr256(n, x), 0xff) and
let it be optimised out by the EVM backend?</td>
</tr>
<tr class="row-even"><td colspan="2"><em>Memory and storage</em></td>
</tr>
<tr class="row-odd"><td>mload(p:u256) -&gt; v:u256</td>
<td>mem[p..(p+32))</td>
</tr>
<tr class="row-even"><td>mstore(p:u256, v:u256)</td>
<td>mem[p..(p+32)) := v</td>
</tr>
<tr class="row-odd"><td>mstore8(p:u256, v:u256)</td>
<td>mem[p] := v &amp; 0xff    - only modifies a single byte</td>
</tr>
<tr class="row-even"><td>sload(p:u256) -&gt; v:u256</td>
<td>storage[p]</td>
</tr>
<tr class="row-odd"><td>sstore(p:u256, v:u256)</td>
<td>storage[p] := v</td>
</tr>
<tr class="row-even"><td>msize() -&gt; size:u256</td>
<td>size of memory, i.e. largest accessed memory index, albeit due
due to the memory extension function, which extends by words,
this will always be a multiple of 32 bytes</td>
</tr>
<tr class="row-odd"><td colspan="2"><em>Execution control</em></td>
</tr>
<tr class="row-even"><td>create(v:u256, p:u256, s:u256)</td>
<td>create new contract with code mem[p..(p+s)) and send v wei
and return the new address</td>
</tr>
<tr class="row-odd"><td>call(g:u256, a:u256, v:u256, in:u256,
insize:u256, out:u256,
outsize:u256)
-&gt; r:u256</td>
<td>call contract at address a with input mem[in..(in+insize))
providing g gas and v wei and output area
mem[out..(out+outsize)) returning 0 on error (eg. out of gas)
and 1 on success</td>
</tr>
<tr class="row-even"><td>callcode(g:u256, a:u256, v:u256, in:u256,
insize:u256, out:u256,
outsize:u256) -&gt; r:u256</td>
<td>identical to <code class="docutils literal"><span class="pre">call</span></code> but only use the code from a
and stay in the context of the
current contract otherwise</td>
</tr>
<tr class="row-odd"><td>delegatecall(g:u256, a:u256, in:u256,
insize:u256, out:u256,
outsize:u256) -&gt; r:u256</td>
<td>identical to <code class="docutils literal"><span class="pre">callcode</span></code>,
but also keep <code class="docutils literal"><span class="pre">caller</span></code>
and <code class="docutils literal"><span class="pre">callvalue</span></code></td>
</tr>
<tr class="row-even"><td>abort()</td>
<td>abort (equals to invalid instruction on EVM)</td>
</tr>
<tr class="row-odd"><td>return(p:u256, s:u256)</td>
<td>end execution, return data mem[p..(p+s))</td>
</tr>
<tr class="row-even"><td>revert(p:u256, s:u256)</td>
<td>end execution, revert state changes, return data mem[p..(p+s))</td>
</tr>
<tr class="row-odd"><td>selfdestruct(a:u256)</td>
<td>end execution, destroy current contract and send funds to a</td>
</tr>
<tr class="row-even"><td>log0(p:u256, s:u256)</td>
<td>log without topics and data mem[p..(p+s))</td>
</tr>
<tr class="row-odd"><td>log1(p:u256, s:u256, t1:u256)</td>
<td>log with topic t1 and data mem[p..(p+s))</td>
</tr>
<tr class="row-even"><td>log2(p:u256, s:u256, t1:u256, t2:u256)</td>
<td>log with topics t1, t2 and data mem[p..(p+s))</td>
</tr>
<tr class="row-odd"><td>log3(p:u256, s:u256, t1:u256, t2:u256,
t3:u256)</td>
<td>log with topics t, t2, t3 and data mem[p..(p+s))</td>
</tr>
<tr class="row-even"><td>log4(p:u256, s:u256, t1:u256, t2:u256,
t3:u256, t4:u256)</td>
<td>log with topics t1, t2, t3, t4 and data mem[p..(p+s))</td>
</tr>
<tr class="row-odd"><td colspan="2"><em>State queries</em></td>
</tr>
<tr class="row-even"><td>blockcoinbase() -&gt; address:u256</td>
<td>current mining beneficiary</td>
</tr>
<tr class="row-odd"><td>blockdifficulty() -&gt; difficulty:u256</td>
<td>difficulty of the current block</td>
</tr>
<tr class="row-even"><td>blockgaslimit() -&gt; limit:u256</td>
<td>block gas limit of the current block</td>
</tr>
<tr class="row-odd"><td>blockhash(b:u256) -&gt; hash:u256</td>
<td>hash of block nr b - only for last 256 blocks excluding current</td>
</tr>
<tr class="row-even"><td>blocknumber() -&gt; block:u256</td>
<td>current block number</td>
</tr>
<tr class="row-odd"><td>blocktimestamp() -&gt; timestamp:u256</td>
<td>timestamp of the current block in seconds since the epoch</td>
</tr>
<tr class="row-even"><td>txorigin() -&gt; address:u256</td>
<td>transaction sender</td>
</tr>
<tr class="row-odd"><td>txgasprice() -&gt; price:u256</td>
<td>gas price of the transaction</td>
</tr>
<tr class="row-even"><td>gasleft() -&gt; gas:u256</td>
<td>gas still available to execution</td>
</tr>
<tr class="row-odd"><td>balance(a:u256) -&gt; v:u256</td>
<td>wei balance at address a</td>
</tr>
<tr class="row-even"><td>this() -&gt; address:u256</td>
<td>address of the current contract / execution context</td>
</tr>
<tr class="row-odd"><td>caller() -&gt; address:u256</td>
<td>call sender (excluding delegatecall)</td>
</tr>
<tr class="row-even"><td>callvalue() -&gt; v:u256</td>
<td>wei sent together with the current call</td>
</tr>
<tr class="row-odd"><td>calldataload(p:u256) -&gt; v:u256</td>
<td>call data starting from position p (32 bytes)</td>
</tr>
<tr class="row-even"><td>calldatasize() -&gt; v:u256</td>
<td>size of call data in bytes</td>
</tr>
<tr class="row-odd"><td>calldatacopy(t:u256, f:u256, s:u256)</td>
<td>copy s bytes from calldata at position f to mem at position t</td>
</tr>
<tr class="row-even"><td>codesize() -&gt; size:u256</td>
<td>size of the code of the current contract / execution context</td>
</tr>
<tr class="row-odd"><td>codecopy(t:u256, f:u256, s:u256)</td>
<td>copy s bytes from code at position f to mem at position t</td>
</tr>
<tr class="row-even"><td>extcodesize(a:u256) -&gt; size:u256</td>
<td>size of the code at address a</td>
</tr>
<tr class="row-odd"><td>extcodecopy(a:u256, t:u256, f:u256, s:u256)</td>
<td>like codecopy(t, f, s) but take code at address a</td>
</tr>
<tr class="row-even"><td colspan="2"><em>Others</em></td>
</tr>
<tr class="row-odd"><td>discard(unused:bool)</td>
<td>discard value</td>
</tr>
<tr class="row-even"><td>discardu256(unused:u256)</td>
<td>discard value</td>
</tr>
<tr class="row-odd"><td><dl class="first last docutils">
<dt>splitu256tou64(x:u256) -&gt; (x1:u64, x2:u64,</dt>
<dd>x3:u64, x4:u64)</dd>
</dl>
</td>
<td>split u256 to four u64’s</td>
</tr>
<tr class="row-even"><td><dl class="first last docutils">
<dt>combineu64tou256(x1:u64, x2:u64, x3:u64,</dt>
<dd>x4:u64) -&gt; (x:u256)</dd>
</dl>
</td>
<td>combine four u64’s into a single u256</td>
</tr>
<tr class="row-odd"><td>keccak256(p:u256, s:u256) -&gt; v:u256</td>
<td>keccak(mem[p…(p+s)))</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="backends">
<h4>Backends<a class="headerlink" href="#backends" title="Permalink to this headline">¶</a></h4>
<p>后端或目标是从朱莉娅到特定字节码的翻译。每个后端都可以使用后端的名称公开函数。我们保留evm_和ewasm_前缀用于两个提议的后端。<code class="docutils literal"><span class="pre">evm_</span></code><code class="docutils literal"><span class="pre">ewasm_</span></code></p>
</div>
<div class="section" id="backend-evm">
<h4>Backend: EVM<a class="headerlink" href="#backend-evm" title="Permalink to this headline">¶</a></h4>
<p>EVM目标将具有与evm_前缀公开的所有底层EVM操作码。<cite>evm_</cite></p>
</div>
<div class="section" id="backend-evm-1-5">
<h4>Backend: “EVM 1.5”<a class="headerlink" href="#backend-evm-1-5" title="Permalink to this headline">¶</a></h4>
<p>tbd</p>
</div>
<div class="section" id="backend-ewasm">
<h4>Backend: eWASM<a class="headerlink" href="#backend-ewasm" title="Permalink to this headline">¶</a></h4>
<p>tbd</p>
</div>
</div>
<div class="section" id="specification-of-julia-object">
<h3>Specification of JULIA Object<a class="headerlink" href="#specification-of-julia-object" title="Permalink to this headline">¶</a></h3>
<p>语法:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">TopLevelObject</span> <span class="o">=</span> <span class="s1">'object'</span> <span class="s1">'{'</span> <span class="nx">Code</span><span class="o">?</span> <span class="p">(</span> <span class="nx">Object</span> <span class="o">|</span> <span class="nx">Data</span> <span class="p">)</span><span class="o">*</span> <span class="s1">'}'</span>
<span class="nx">Object</span> <span class="o">=</span> <span class="s1">'object'</span> <span class="nx">StringLiteral</span> <span class="s1">'{'</span> <span class="nx">Code</span><span class="o">?</span> <span class="p">(</span> <span class="nx">Object</span> <span class="o">|</span> <span class="nx">Data</span> <span class="p">)</span><span class="o">*</span> <span class="s1">'}'</span>
<span class="nx">Code</span> <span class="o">=</span> <span class="s1">'code'</span> <span class="nx">Block</span>
<span class="nx">Data</span> <span class="o">=</span> <span class="s1">'data'</span> <span class="nx">StringLiteral</span> <span class="nx">HexLiteral</span>
<span class="nx">HexLiteral</span> <span class="o">=</span> <span class="s1">'hex'</span> <span class="p">(</span><span class="s1">'"'</span> <span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="nx">a</span><span class="o">-</span><span class="nx">fA</span><span class="o">-</span><span class="nx">F</span><span class="p">]{</span><span class="mi">2</span><span class="p">})</span><span class="o">*</span> <span class="s1">'"'</span> <span class="o">|</span> <span class="s1">'\''</span> <span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="nx">a</span><span class="o">-</span><span class="nx">fA</span><span class="o">-</span><span class="nx">F</span><span class="p">]{</span><span class="mi">2</span><span class="p">})</span><span class="o">*</span> <span class="s1">'\''</span><span class="p">)</span>
<span class="nx">StringLiteral</span> <span class="o">=</span> <span class="s1">'"'</span> <span class="p">([</span><span class="o">^</span><span class="s2">"\r\n\\] | '\\' .)* '"</span><span class="err">'</span>
</pre></div>
</div>
<p>上面，Block是指在前面章节中解释的JULIA代码语法中的块。<code class="docutils literal"><span class="pre">Block</span></code><code class="docutils literal"><span class="pre">Block</span></code></p>
<p>朱莉娅的一个例子如下所示:</p>
<p>. .代码:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="c1">// Code consists of a single object. A single "code" node is the code of the object.</span>
<span class="c1">// Every (other) named object or data section is serialized and</span>
<span class="c1">// made accessible to the special built-in functions datacopy / dataoffset / datasize</span>
<span class="nx">object</span> <span class="p">{</span>
    <span class="nx">code</span> <span class="p">{</span>
        <span class="kr">let</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">datasize</span><span class="p">(</span><span class="s2">"runtime"</span><span class="p">)</span>
        <span class="kr">let</span> <span class="nx">offset</span> <span class="o">=</span> <span class="nx">allocate</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
        <span class="c1">// This will turn into a memory-&gt;memory copy for eWASM and</span>
        <span class="c1">// a codecopy for EVM</span>
        <span class="nx">datacopy</span><span class="p">(</span><span class="nx">dataoffset</span><span class="p">(</span><span class="s2">"runtime"</span><span class="p">),</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
        <span class="c1">// this is a constructor and the runtime code is returned</span>
        <span class="k">return</span><span class="p">(</span><span class="nx">offset</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">data</span> <span class="s2">"Table2"</span> <span class="k">hex</span><span class="s2">"4123"</span>

    <span class="nx">object</span> <span class="s2">"runtime"</span> <span class="p">{</span>
        <span class="nx">code</span> <span class="p">{</span>
            <span class="c1">// runtime code</span>

            <span class="kr">let</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">datasize</span><span class="p">(</span><span class="s2">"Contract2"</span><span class="p">)</span>
            <span class="kr">let</span> <span class="nx">offset</span> <span class="o">=</span> <span class="nx">allocate</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
            <span class="c1">// This will turn into a memory-&gt;memory copy for eWASM and</span>
            <span class="c1">// a codecopy for EVM</span>
            <span class="nx">datacopy</span><span class="p">(</span><span class="nx">dataoffset</span><span class="p">(</span><span class="s2">"Contract2"</span><span class="p">),</span> <span class="nx">offset</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
            <span class="c1">// constructor parameter is a single number 0x1234</span>
            <span class="nx">mstore</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="nx">offset</span><span class="p">,</span> <span class="nx">size</span><span class="p">),</span> <span class="mh">0x1234</span><span class="p">)</span>
            <span class="nx">create</span><span class="p">(</span><span class="nx">offset</span><span class="p">,</span> <span class="nx">add</span><span class="p">(</span><span class="nx">size</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span>
        <span class="p">}</span>

        <span class="c1">// Embedded object. Use case is that the outside is a factory contract,</span>
        <span class="c1">// and Contract2 is the code to be created by the factory</span>
        <span class="nx">object</span> <span class="s2">"Contract2"</span> <span class="p">{</span>
            <span class="nx">code</span> <span class="p">{</span>
                <span class="c1">// code here ...</span>
            <span class="p">}</span>

            <span class="nx">object</span> <span class="s2">"runtime"</span> <span class="p">{</span>
                <span class="nx">code</span> <span class="p">{</span>
                    <span class="c1">// code here ...</span>
                <span class="p">}</span>
             <span class="p">}</span>

             <span class="nx">data</span> <span class="s2">"Table1"</span> <span class="k">hex</span><span class="s2">"4123"</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-style-guide"></span><div class="section" id="style-guide">
<span id="index-0"></span><h2>Style Guide<a class="headerlink" href="#style-guide" title="Permalink to this headline">¶</a></h2>
<div class="section" id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h3>
<p>本指南旨在为编写solidity代码提供编码规范。这个指南应该被认为是一个不断变化的文档，随着有用的惯例被发现，旧的惯例被淘汰，它将会改变加班时间。</p>
<p>许多项目将实现他们自己的风格指南。在发生冲突时，项目特定的样式指南优先。</p>
<p>该风格指南中的结构和许多建议都取自python的spep8风格指南。<a class="reference external" href="https://www.python.org/dev/peps/pep-0008/">pep8 style guide</a></p>
<p>这个指南的目标不是正确的方法，也不是写代码的最好方法。本指南的目标是一致性。python ' spep8的报价很好地抓住了这个概念。<em>not</em><em>consistency</em><a class="reference external" href="https://www.python.org/dev/peps/pep-0008/#a-foolish-consistency-is-the-hobgoblin-of-little-minds">pep8</a></p>
<blockquote>
<div>A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is most important.
But most importantly: know when to be inconsistent – sometimes the style guide just doesn’t apply. When in doubt, use your best judgement. Look at other examples and decide what looks best. And don’t hesitate to ask!</div></blockquote>
</div>
<div class="section" id="code-layout">
<h3>Code Layout<a class="headerlink" href="#code-layout" title="Permalink to this headline">¶</a></h3>
<div class="section" id="indentation">
<h4>Indentation<a class="headerlink" href="#indentation" title="Permalink to this headline">¶</a></h4>
<p>每个缩进级别使用4个空格。</p>
</div>
<div class="section" id="tabs-or-spaces">
<h4>Tabs or Spaces<a class="headerlink" href="#tabs-or-spaces" title="Permalink to this headline">¶</a></h4>
<p>空格是首选的缩进方法。</p>
<p>应该避免混合标签和空格。</p>
</div>
<div class="section" id="blank-lines">
<h4>Blank Lines<a class="headerlink" href="#blank-lines" title="Permalink to this headline">¶</a></h4>
<p>用两个空行包围在solidity源中的顶级声明。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>


<span class="kd">contract</span> <span class="nx">B</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>


<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="kd">contract</span> <span class="nx">B</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在一个合约中，用一个空行包围函数声明。</p>
<p>相关的一行程序(如抽象合约的存根函数)之间可以省略空白行。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">spam</span><span class="p">()</span> <span class="k">public</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">ham</span><span class="p">()</span> <span class="k">public</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">contract</span> <span class="nx">B</span> <span class="k">is</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">spam</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">ham</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">spam</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">ham</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="maximum-line-length">
<span id="id1"></span><h4>Maximum Line Length<a class="headerlink" href="#maximum-line-length" title="Permalink to this headline">¶</a></h4>
<p>将PEP 8建议中的行保留到最多79(或99)字符，可以帮助读者轻松解析代码。<a class="reference external" href="https://www.python.org/dev/peps/pep-0008/#maximum-line-length">PEP 8 recommendation</a></p>
<p>包装线应符合下列准则。</p>
<ol class="arabic simple">
<li>The first argument should not be attached to the opening parenthesis.</li>
<li>One, and only one, indent should be used.</li>
<li>Each argument should fall on its own line.</li>
<li>The terminating element, <code class="code docutils literal"><span class="pre">);</span></code>, should be placed on the final line by itself.</li>
</ol>
<p>函数调用</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">thisFunctionCallIsReallyLong</span><span class="p">(</span>
    <span class="nx">longArgument1</span><span class="p">,</span>
    <span class="nx">longArgument2</span><span class="p">,</span>
    <span class="nx">longArgument3</span>
<span class="p">);</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">thisFunctionCallIsReallyLong</span><span class="p">(</span><span class="nx">longArgument1</span><span class="p">,</span>
                              <span class="nx">longArgument2</span><span class="p">,</span>
                              <span class="nx">longArgument3</span>
<span class="p">);</span>

<span class="nx">thisFunctionCallIsReallyLong</span><span class="p">(</span><span class="nx">longArgument1</span><span class="p">,</span>
    <span class="nx">longArgument2</span><span class="p">,</span>
    <span class="nx">longArgument3</span>
<span class="p">);</span>

<span class="nx">thisFunctionCallIsReallyLong</span><span class="p">(</span>
    <span class="nx">longArgument1</span><span class="p">,</span> <span class="nx">longArgument2</span><span class="p">,</span>
    <span class="nx">longArgument3</span>
<span class="p">);</span>

<span class="nx">thisFunctionCallIsReallyLong</span><span class="p">(</span>
<span class="nx">longArgument1</span><span class="p">,</span>
<span class="nx">longArgument2</span><span class="p">,</span>
<span class="nx">longArgument3</span>
<span class="p">);</span>

<span class="nx">thisFunctionCallIsReallyLong</span><span class="p">(</span>
    <span class="nx">longArgument1</span><span class="p">,</span>
    <span class="nx">longArgument2</span><span class="p">,</span>
    <span class="nx">longArgument3</span><span class="p">);</span>
</pre></div>
</div>
<p>赋值语句</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">thisIsALongNestedMapping</span><span class="p">[</span><span class="nx">being</span><span class="p">][</span><span class="nx">set</span><span class="p">][</span><span class="nx">to_some_value</span><span class="p">]</span> <span class="o">=</span> <span class="nx">someFunction</span><span class="p">(</span>
    <span class="nx">argument1</span><span class="p">,</span>
    <span class="nx">argument2</span><span class="p">,</span>
    <span class="nx">argument3</span><span class="p">,</span>
    <span class="nx">argument4</span>
<span class="p">);</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">thisIsALongNestedMapping</span><span class="p">[</span><span class="nx">being</span><span class="p">][</span><span class="nx">set</span><span class="p">][</span><span class="nx">to_some_value</span><span class="p">]</span> <span class="o">=</span> <span class="nx">someFunction</span><span class="p">(</span><span class="nx">argument1</span><span class="p">,</span>
                                                                   <span class="nx">argument2</span><span class="p">,</span>
                                                                   <span class="nx">argument3</span><span class="p">,</span>
                                                                   <span class="nx">argument4</span><span class="p">);</span>
</pre></div>
</div>
<p>事件定义和事件发射器。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">event</span> <span class="nx">LongAndLotsOfArgs</span><span class="p">(</span>
    <span class="nx">adress</span> <span class="nx">sender</span><span class="p">,</span>
    <span class="nx">adress</span> <span class="nx">recipient</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="nx">publicKey</span><span class="p">,</span>
    <span class="kt">uint256</span> <span class="nx">amount</span><span class="p">,</span>
    <span class="kt">bytes32</span><span class="p">[]</span> <span class="nx">options</span>
<span class="p">);</span>

<span class="nx">LongAndLotsOfArgs</span><span class="p">(</span>
    <span class="nx">sender</span><span class="p">,</span>
    <span class="nx">recipient</span><span class="p">,</span>
    <span class="nx">publicKey</span><span class="p">,</span>
    <span class="nx">amount</span><span class="p">,</span>
    <span class="nx">options</span>
<span class="p">);</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">event</span> <span class="nx">LongAndLotsOfArgs</span><span class="p">(</span><span class="nx">adress</span> <span class="nx">sender</span><span class="p">,</span>
                        <span class="nx">adress</span> <span class="nx">recipient</span><span class="p">,</span>
                        <span class="kt">uint256</span> <span class="nx">publicKey</span><span class="p">,</span>
                        <span class="kt">uint256</span> <span class="nx">amount</span><span class="p">,</span>
                        <span class="kt">bytes32</span><span class="p">[]</span> <span class="nx">options</span><span class="p">);</span>

<span class="nx">LongAndLotsOfArgs</span><span class="p">(</span><span class="nx">sender</span><span class="p">,</span>
                  <span class="nx">recipient</span><span class="p">,</span>
                  <span class="nx">publicKey</span><span class="p">,</span>
                  <span class="nx">amount</span><span class="p">,</span>
                  <span class="nx">options</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="source-file-encoding">
<h4>Source File Encoding<a class="headerlink" href="#source-file-encoding" title="Permalink to this headline">¶</a></h4>
<p>UTF-8或ASCII编码是首选。</p>
</div>
<div class="section" id="imports">
<h4>Imports<a class="headerlink" href="#imports" title="Permalink to this headline">¶</a></h4>
<p>导入语句应该始终放在文件的顶部。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="s2">"owned"</span><span class="p">;</span>


<span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>


<span class="kd">contract</span> <span class="nx">B</span> <span class="k">is</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>


<span class="k">import</span> <span class="s2">"owned"</span><span class="p">;</span>


<span class="kd">contract</span> <span class="nx">B</span> <span class="k">is</span> <span class="nx">owned</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="order-of-functions">
<h4>Order of Functions<a class="headerlink" href="#order-of-functions" title="Permalink to this headline">¶</a></h4>
<p>排序帮助读者确定他们可以调用哪些函数，并更容易地找到构造函数和回退定义。</p>
<p>功能应根据其可见性和顺序进行分组:</p>
<ul class="simple">
<li>constructor</li>
<li>fallback function (if exists)</li>
<li>external</li>
<li>public</li>
<li>internal</li>
<li>private</li>
</ul>
<p>在分组中，将视图和纯函数放在最后。<code class="docutils literal"><span class="pre">view</span></code><code class="docutils literal"><span class="pre">pure</span></code></p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="kd">function</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="c1">// External functions</span>
    <span class="c1">// ...</span>

    <span class="c1">// External functions that are view</span>
    <span class="c1">// ...</span>

    <span class="c1">// External functions that are pure</span>
    <span class="c1">// ...</span>

    <span class="c1">// Public functions</span>
    <span class="c1">// ...</span>

    <span class="c1">// Internal functions</span>
    <span class="c1">// ...</span>

    <span class="c1">// Private functions</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>

    <span class="c1">// External functions</span>
    <span class="c1">// ...</span>

    <span class="c1">// Private functions</span>
    <span class="c1">// ...</span>

    <span class="c1">// Public functions</span>
    <span class="c1">// ...</span>

    <span class="kd">function</span> <span class="nx">A</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="kd">function</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="c1">// Internal functions</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="whitespace-in-expressions">
<h4>Whitespace in Expressions<a class="headerlink" href="#whitespace-in-expressions" title="Permalink to this headline">¶</a></h4>
<p>在下列情况下避免无关空格:</p>
<p>在括号内，括号或括号内，除了单行函数声明之外。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">spam</span><span class="p">(</span><span class="nx">ham</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">Coin</span><span class="p">({</span><span class="nx">name</span><span class="o">:</span> <span class="s2">"ham"</span><span class="p">}));</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">spam</span><span class="p">(</span> <span class="nx">ham</span><span class="p">[</span> <span class="mi">1</span> <span class="p">],</span> <span class="nx">Coin</span><span class="p">(</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">"ham"</span> <span class="p">}</span> <span class="p">)</span> <span class="p">);</span>
</pre></div>
</div>
<p>例外:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">singleLine</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">spam</span><span class="p">();</span> <span class="p">}</span>
</pre></div>
</div>
<p>在逗号之前，分号:</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">spam</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">Coin</span> <span class="nx">coin</span><span class="p">)</span> <span class="k">public</span><span class="p">;</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">spam</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span> <span class="p">,</span> <span class="nx">Coin</span> <span class="nx">coin</span><span class="p">)</span> <span class="k">public</span> <span class="p">;</span>
</pre></div>
</div>
<dl class="docutils">
<dt>More than one space around an assignment or other operator to align with</dt>
<dd>another:</dd>
</dl>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">long_variable</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">x</span>             <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">y</span>             <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">long_variable</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</pre></div>
</div>
<p>不要在回退函数中包含空格:</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="control-structures">
<h4>Control Structures<a class="headerlink" href="#control-structures" title="Permalink to this headline">¶</a></h4>
<p>括号表示合约、库、函数和结构的主体:</p>
<ul class="simple">
<li>open on the same line as the declaration</li>
<li>close on their own line at the same indentation level as the beginning of the
declaration.</li>
<li>The opening brace should be proceeded by a single space.</li>
</ul>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">Coin</span> <span class="p">{</span>
    <span class="kd">struct</span> <span class="nx">Bank</span> <span class="p">{</span>
        <span class="kt">address</span> <span class="nx">owner</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="nx">balance</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">Coin</span>
<span class="p">{</span>
    <span class="kd">struct</span> <span class="nx">Bank</span> <span class="p">{</span>
        <span class="kt">address</span> <span class="nx">owner</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="nx">balance</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>同样的建议适用于控制结构，如果，其他，以及。<code class="docutils literal"><span class="pre">if</span></code><code class="docutils literal"><span class="pre">else</span></code><code class="docutils literal"><span class="pre">while</span></code><code class="docutils literal"><span class="pre">for</span></code></p>
<p>此外，在控制结构体之间还应该有一个单独的空间，而对于表示这两个条件的插入块，以及条件圆括号和打开括号之间的一个空格。<code class="docutils literal"><span class="pre">if</span></code><code class="docutils literal"><span class="pre">while</span></code><code class="docutils literal"><span class="pre">for</span></code></p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(...)</span>
<span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">while</span><span class="p">(...){</span>
<span class="p">}</span>

<span class="k">for</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="p">...;}</span>
</pre></div>
</div>
<p>对于包含单个语句的控制结构，如果语句包含在单个行中，则省略括号是可以的。<em>if</em></p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nx">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nx">someArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">Coin</span><span class="p">({</span>
        <span class="nx">name</span><span class="o">:</span> <span class="s1">'spam'</span><span class="p">,</span>
        <span class="nx">value</span><span class="o">:</span> <span class="mi">42</span>
    <span class="p">}));</span>
</pre></div>
</div>
<p>如果有其他或其他if子句的块，else应该放在与if的闭括号相同的行上。这是一个与其他块状结构的规则比较的异常。<code class="docutils literal"><span class="pre">if</span></code><code class="docutils literal"><span class="pre">else</span></code><code class="docutils literal"><span class="pre">else</span> <span class="pre">if</span></code><code class="docutils literal"><span class="pre">else</span></code><code class="docutils literal"><span class="pre">if</span></code></p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>
    <span class="nx">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">else</span>
    <span class="nx">x</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="nx">x</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="function-declaration">
<h4>Function Declaration<a class="headerlink" href="#function-declaration" title="Permalink to this headline">¶</a></h4>
<p>对于简短的函数声明，建议将函数体的打开括号保持在与函数声明相同的行上。</p>
<p>关闭括号应该与functiondeclaration在相同的缩进级别。</p>
<p>打开的支架应该在一个单独的空间之前。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">increment</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">increment</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="nx">onlyowner</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">increment</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">increment</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">increment</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

<span class="kd">function</span> <span class="nx">increment</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;}</span>
</pre></div>
</div>
<p>您应该显式地标记所有函数的可见性，包括构造函数。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">explicitlyPublic</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">val</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">implicitlyPublic</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数的可见性修饰符应该在任何custommodifier之前出现。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">kill</span><span class="p">()</span> <span class="k">public</span> <span class="nx">onlyowner</span> <span class="p">{</span>
    <span class="nb">selfdestruct</span><span class="p">(</span><span class="nx">owner</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">kill</span><span class="p">()</span> <span class="nx">onlyowner</span> <span class="k">public</span> <span class="p">{</span>
    <span class="nb">selfdestruct</span><span class="p">(</span><span class="nx">owner</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于长函数声明，建议将每个参数都放到与函数体相同的缩进级别上。应该将closing括号和打开括号放在它们自己的行上，与函数声明相同的缩进级别。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">thisFunctionHasLotsOfArguments</span><span class="p">(</span>
    <span class="kt">address</span> <span class="nx">a</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">b</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">c</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">d</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">e</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">f</span>
<span class="p">)</span>
    <span class="k">public</span>
<span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">thisFunctionHasLotsOfArguments</span><span class="p">(</span><span class="kt">address</span> <span class="nx">a</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">b</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">c</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">d</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">e</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">f</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">thisFunctionHasLotsOfArguments</span><span class="p">(</span><span class="kt">address</span> <span class="nx">a</span><span class="p">,</span>
                                        <span class="kt">address</span> <span class="nx">b</span><span class="p">,</span>
                                        <span class="kt">address</span> <span class="nx">c</span><span class="p">,</span>
                                        <span class="kt">address</span> <span class="nx">d</span><span class="p">,</span>
                                        <span class="kt">address</span> <span class="nx">e</span><span class="p">,</span>
                                        <span class="kt">address</span> <span class="nx">f</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">thisFunctionHasLotsOfArguments</span><span class="p">(</span>
    <span class="kt">address</span> <span class="nx">a</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">b</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">c</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">d</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">e</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">f</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果一个长函数声明有修饰符，那么每个修饰符都应该被删除到自己的行中。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">thisFunctionNameIsReallyLong</span><span class="p">(</span><span class="kt">address</span> <span class="nx">x</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">y</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">z</span><span class="p">)</span>
    <span class="k">public</span>
    <span class="nx">onlyowner</span>
    <span class="nx">priced</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">thisFunctionNameIsReallyLong</span><span class="p">(</span>
    <span class="kt">address</span> <span class="nx">x</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">y</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">z</span><span class="p">,</span>
<span class="p">)</span>
    <span class="k">public</span>
    <span class="nx">onlyowner</span>
    <span class="nx">priced</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">thisFunctionNameIsReallyLong</span><span class="p">(</span><span class="kt">address</span> <span class="nx">x</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">y</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">z</span><span class="p">)</span>
                                      <span class="k">public</span>
                                      <span class="nx">onlyowner</span>
                                      <span class="nx">priced</span>
                                      <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">thisFunctionNameIsReallyLong</span><span class="p">(</span><span class="kt">address</span> <span class="nx">x</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">y</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">z</span><span class="p">)</span>
    <span class="k">public</span> <span class="nx">onlyowner</span> <span class="nx">priced</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">thisFunctionNameIsReallyLong</span><span class="p">(</span><span class="kt">address</span> <span class="nx">x</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">y</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">z</span><span class="p">)</span>
    <span class="k">public</span>
    <span class="nx">onlyowner</span>
    <span class="nx">priced</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>多行输出参数和返回语句应该遵循相同的样式，建议在最大行长度部分中发现长行。<a class="reference internal" href="#maximum-line-length"><span class="std std-ref">Maximum Line Length</span></a></p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">thisFunctionNameIsReallyLong</span><span class="p">(</span>
    <span class="kt">address</span> <span class="nx">a</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">b</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">c</span>
<span class="p">)</span>
    <span class="k">public</span>
    <span class="k">returns</span> <span class="p">(</span>
        <span class="kt">address</span> <span class="nx">someAddressName</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="nx">LongArgument</span><span class="p">,</span>
        <span class="kt">uint256</span> <span class="nx">Argument</span>
    <span class="p">)</span>
<span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">()</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="nx">veryLongReturnArg1</span><span class="p">,</span>
        <span class="nx">veryLongReturnArg2</span><span class="p">,</span>
        <span class="nx">veryLongReturnArg3</span>
    <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">thisFunctionNameIsReallyLong</span><span class="p">(</span>
    <span class="kt">address</span> <span class="nx">a</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">b</span><span class="p">,</span>
    <span class="kt">address</span> <span class="nx">c</span>
<span class="p">)</span>
    <span class="k">public</span>
    <span class="k">returns</span> <span class="p">(</span><span class="kt">address</span> <span class="nx">someAddressName</span><span class="p">,</span>
             <span class="kt">uint256</span> <span class="nx">LongArgument</span><span class="p">,</span>
             <span class="kt">uint256</span> <span class="nx">Argument</span><span class="p">)</span>
<span class="p">{</span>
    <span class="nx">doSomething</span><span class="p">()</span>

    <span class="k">return</span> <span class="p">(</span><span class="nx">veryLongReturnArg1</span><span class="p">,</span>
            <span class="nx">veryLongReturnArg1</span><span class="p">,</span>
            <span class="nx">veryLongReturnArg1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对于继承合约的构造函数，其基础需要参数，建议将基本构造函数在samemanner中的新行中删除为修饰符，如果函数声明是长或难读的。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">A</span> <span class="k">is</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">C</span><span class="p">,</span> <span class="nx">D</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">param1</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param2</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param3</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param4</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param5</span><span class="p">)</span>
        <span class="nx">B</span><span class="p">(</span><span class="nx">param1</span><span class="p">)</span>
        <span class="nx">C</span><span class="p">(</span><span class="nx">param2</span><span class="p">,</span> <span class="nx">param3</span><span class="p">)</span>
        <span class="nx">D</span><span class="p">(</span><span class="nx">param4</span><span class="p">)</span>
        <span class="k">public</span>
    <span class="p">{</span>
        <span class="c1">// do something with param5</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">A</span> <span class="k">is</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">C</span><span class="p">,</span> <span class="nx">D</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">param1</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param2</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param3</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param4</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param5</span><span class="p">)</span>
    <span class="nx">B</span><span class="p">(</span><span class="nx">param1</span><span class="p">)</span>
    <span class="nx">C</span><span class="p">(</span><span class="nx">param2</span><span class="p">,</span> <span class="nx">param3</span><span class="p">)</span>
    <span class="nx">D</span><span class="p">(</span><span class="nx">param4</span><span class="p">)</span>
    <span class="k">public</span>
    <span class="p">{</span>
        <span class="c1">// do something with param5</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">A</span> <span class="k">is</span> <span class="nx">B</span><span class="p">,</span> <span class="nx">C</span><span class="p">,</span> <span class="nx">D</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">A</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">param1</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param2</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param3</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param4</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">param5</span><span class="p">)</span>
        <span class="nx">B</span><span class="p">(</span><span class="nx">param1</span><span class="p">)</span>
        <span class="nx">C</span><span class="p">(</span><span class="nx">param2</span><span class="p">,</span> <span class="nx">param3</span><span class="p">)</span>
        <span class="nx">D</span><span class="p">(</span><span class="nx">param4</span><span class="p">)</span>
        <span class="k">public</span> <span class="p">{</span>
        <span class="c1">// do something with param5</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在使用单个语句声明短函数时，允许在一行上执行。</p>
<p>允许:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">shortFunction</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span> <span class="nx">doSomething</span><span class="p">();</span> <span class="p">}</span>
</pre></div>
</div>
<p>函数声明的这些指导方针旨在提高可读性。作者应该使用他们最好的判断，因为这个指南并没有试图覆盖所有可能排列的函数声明。</p>
</div>
<div class="section" id="mappings">
<h4>Mappings<a class="headerlink" href="#mappings" title="Permalink to this headline">¶</a></h4>
<p>待办事项</p>
</div>
<div class="section" id="variable-declarations">
<h4>Variable Declarations<a class="headerlink" href="#variable-declarations" title="Permalink to this headline">¶</a></h4>
<p>数组变量的声明不应该在类型和括号之间有空格。</p>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kt">uint</span><span class="p">[]</span> <span class="nx">x</span><span class="p">;</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kt">uint</span> <span class="p">[]</span> <span class="nx">x</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="other-recommendations">
<h4>Other Recommendations<a class="headerlink" href="#other-recommendations" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Strings should be quoted with double-quotes instead of single-quotes.</li>
</ul>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">str</span> <span class="o">=</span> <span class="s2">"foo"</span><span class="p">;</span>
<span class="nx">str</span> <span class="o">=</span> <span class="s2">"Hamlet says, 'To be or not to be...'"</span><span class="p">;</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">str</span> <span class="o">=</span> <span class="s1">'bar'</span><span class="p">;</span>
<span class="nx">str</span> <span class="o">=</span> <span class="s1">'"Be yourself; everyone else is already taken." -Oscar Wilde'</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>Surround operators with a single space on either side.</li>
</ul>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">+=</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">|=</span> <span class="nx">y</span> <span class="o">&amp;&amp;</span> <span class="nx">z</span><span class="p">;</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">x</span><span class="o">=</span><span class="mi">3</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">=</span> <span class="mi">100</span><span class="o">/</span><span class="mi">10</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">+=</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">|=</span> <span class="nx">y</span><span class="o">&amp;&amp;</span><span class="nx">z</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>Operators with a higher priority than others can exclude surrounding
whitespace in order to denote precedence.  This is meant to allow for
improved readability for complex statement. You should always use the same
amount of whitespace on either side of an operator:</li>
</ul>
<p>是的:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nx">y</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="nx">z</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nx">a</span><span class="o">-</span><span class="nx">b</span><span class="p">);</span>
</pre></div>
</div>
<p>没有:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">=</span> <span class="nx">y</span><span class="o">+</span><span class="nx">z</span><span class="p">;</span>
<span class="nx">x</span> <span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="naming-conventions">
<h3>Naming Conventions<a class="headerlink" href="#naming-conventions" title="Permalink to this headline">¶</a></h3>
<p>命名约定在广泛使用和使用时是很强大的。使用不同的约定可以传递重要的元信息，而这些信息不会立即得到。<em>meta</em></p>
<p>这里给出的命名建议是为了提高可读性，因此它们不是规则，而是试图通过事物的名称来帮助传递主题信息的指南。</p>
<p>最后，代码库中的一致性应该总是超越本文中概述的任何常规。</p>
<div class="section" id="naming-styles">
<h4>Naming Styles<a class="headerlink" href="#naming-styles" title="Permalink to this headline">¶</a></h4>
<p>为了避免混淆，下面的名称将用于引用不同的命名风格。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">b</span></code> (single lowercase letter)</li>
<li><code class="docutils literal"><span class="pre">B</span></code> (single uppercase letter)</li>
<li><code class="docutils literal"><span class="pre">lowercase</span></code></li>
<li><code class="docutils literal"><span class="pre">lower_case_with_underscores</span></code></li>
<li><code class="docutils literal"><span class="pre">UPPERCASE</span></code></li>
<li><code class="docutils literal"><span class="pre">UPPER_CASE_WITH_UNDERSCORES</span></code></li>
<li><code class="docutils literal"><span class="pre">CapitalizedWords</span></code> (or CapWords)</li>
<li><code class="docutils literal"><span class="pre">mixedCase</span></code> (differs from CapitalizedWords by initial lowercase character!)</li>
<li><code class="docutils literal"><span class="pre">Capitalized_Words_With_Underscores</span></code></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">当在CapWords中使用initialisms时，要大写所有initialisms的字母。因此，HTTPServerError比HTTPServerError好。当使用initialisms是mixedCase时，将初始化的所有字母大写，除了保留第一个小写字母，如果它是名字的开头。因此xmlHTTPRequest比xmlHTTPRequest更好。</p>
</div>
</div>
<div class="section" id="names-to-avoid">
<h4>Names to Avoid<a class="headerlink" href="#names-to-avoid" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">l</span></code> - Lowercase letter el</li>
<li><code class="docutils literal"><span class="pre">O</span></code> - Uppercase letter oh</li>
<li><code class="docutils literal"><span class="pre">I</span></code> - Uppercase letter eye</li>
</ul>
<p>不要使用任何一个字母的变量名。它们通常与数字1和0难以区分。</p>
</div>
<div class="section" id="contract-and-library-names">
<h4>Contract and Library Names<a class="headerlink" href="#contract-and-library-names" title="Permalink to this headline">¶</a></h4>
<p>合约和库应该以CapWords的风格命名。示例:SimpleToken、SmartBank、证书hashrepository、Player。<code class="docutils literal"><span class="pre">SimpleToken</span></code><code class="docutils literal"><span class="pre">SmartBank</span></code><code class="docutils literal"><span class="pre">CertificateHashRepository</span></code><code class="docutils literal"><span class="pre">Player</span></code></p>
</div>
<div class="section" id="struct-names">
<h4>Struct Names<a class="headerlink" href="#struct-names" title="Permalink to this headline">¶</a></h4>
<p>结构应该使用CapWords样式命名。例子:MyCoin,位置,PositionXY。<code class="docutils literal"><span class="pre">MyCoin</span></code><code class="docutils literal"><span class="pre">Position</span></code><code class="docutils literal"><span class="pre">PositionXY</span></code></p>
</div>
<div class="section" id="event-names">
<h4>Event Names<a class="headerlink" href="#event-names" title="Permalink to this headline">¶</a></h4>
<p>事件应该使用CapWords样式命名。例子:存款，转让，批准，转帐，转让。<code class="docutils literal"><span class="pre">Deposit</span></code><code class="docutils literal"><span class="pre">Transfer</span></code><code class="docutils literal"><span class="pre">Approval</span></code><code class="docutils literal"><span class="pre">BeforeTransfer</span></code><code class="docutils literal"><span class="pre">AfterTransfer</span></code></p>
</div>
<div class="section" id="function-names">
<h4>Function Names<a class="headerlink" href="#function-names" title="Permalink to this headline">¶</a></h4>
<p>除了构造函数之外的函数应该使用mixedCase。例子:getBalance, transfer, verifyOwner, addMember, changeOwner。<code class="docutils literal"><span class="pre">getBalance</span></code><code class="docutils literal"><span class="pre">transfer</span></code><code class="docutils literal"><span class="pre">verifyOwner</span></code><code class="docutils literal"><span class="pre">addMember</span></code><code class="docutils literal"><span class="pre">changeOwner</span></code></p>
</div>
<div class="section" id="function-argument-names">
<h4>Function Argument Names<a class="headerlink" href="#function-argument-names" title="Permalink to this headline">¶</a></h4>
<p>函数参数应该使用mixedCase。示例:initialSupply, account, receive address, senderAddress, newOwner。<code class="docutils literal"><span class="pre">initialSupply</span></code><code class="docutils literal"><span class="pre">account</span></code><code class="docutils literal"><span class="pre">recipientAddress</span></code><code class="docutils literal"><span class="pre">senderAddress</span></code><code class="docutils literal"><span class="pre">newOwner</span></code></p>
<p>在编写对自定义结构进行操作的库函数时，结构应该是第一个参数，并且应该始终被命名为self。<code class="docutils literal"><span class="pre">self</span></code></p>
</div>
<div class="section" id="local-and-state-variable-names">
<h4>Local and State Variable Names<a class="headerlink" href="#local-and-state-variable-names" title="Permalink to this headline">¶</a></h4>
<p>使用mixedCase。例如:totalSupply, ingsupply, balancesOf, creatorAddress, isPreSale, tokenExchangeRate。<code class="docutils literal"><span class="pre">totalSupply</span></code><code class="docutils literal"><span class="pre">remainingSupply</span></code><code class="docutils literal"><span class="pre">balancesOf</span></code><code class="docutils literal"><span class="pre">creatorAddress</span></code><code class="docutils literal"><span class="pre">isPreSale</span></code><code class="docutils literal"><span class="pre">tokenExchangeRate</span></code></p>
</div>
<div class="section" id="constants">
<h4>Constants<a class="headerlink" href="#constants" title="Permalink to this headline">¶</a></h4>
<p>常数应该用大写字母来命名，用下划线隔开。示例:MAX_BLOCKS、TOKEN_NAME、TOKEN_TICKER、CONTRACT_VERSION。<code class="docutils literal"><span class="pre">MAX_BLOCKS</span></code><code class="docutils literal"><span class="pre">TOKEN_NAME</span></code><code class="docutils literal"><span class="pre">TOKEN_TICKER</span></code><code class="docutils literal"><span class="pre">CONTRACT_VERSION</span></code></p>
</div>
<div class="section" id="modifier-names">
<h4>Modifier Names<a class="headerlink" href="#modifier-names" title="Permalink to this headline">¶</a></h4>
<p>使用mixedCase。例子:仅仅是,onlyAfter onlyDuringThePreSale。<code class="docutils literal"><span class="pre">onlyBy</span></code><code class="docutils literal"><span class="pre">onlyAfter</span></code><code class="docutils literal"><span class="pre">onlyDuringThePreSale</span></code></p>
</div>
<div class="section" id="enums">
<h4>Enums<a class="headerlink" href="#enums" title="Permalink to this headline">¶</a></h4>
<p>枚举类型，以简单类型声明的样式，应该使用CapWords样式命名。例子:TokenGroup, Frame, HashStyle，字符位置。<code class="docutils literal"><span class="pre">TokenGroup</span></code><code class="docutils literal"><span class="pre">Frame</span></code><code class="docutils literal"><span class="pre">HashStyle</span></code><code class="docutils literal"><span class="pre">CharacterLocation</span></code></p>
</div>
<div class="section" id="avoiding-naming-collisions">
<h4>Avoiding Naming Collisions<a class="headerlink" href="#avoiding-naming-collisions" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">single_trailing_underscore_</span></code></li>
</ul>
<p>当期望的名称与abuilin或其他保留的名称发生冲突时，建议使用该约定。</p>
</div>
<div class="section" id="general-recommendations">
<h4>General Recommendations<a class="headerlink" href="#general-recommendations" title="Permalink to this headline">¶</a></h4>
<p>待办事项</p>
</div>
</div>
</div>
<span id="document-common-patterns"></span><div class="section" id="common-patterns">
<h2>Common Patterns<a class="headerlink" href="#common-patterns" title="Permalink to this headline">¶</a></h2>
<div class="section" id="withdrawal-from-contracts">
<span id="withdrawal-pattern"></span><span id="index-0"></span><h3>Withdrawal from Contracts<a class="headerlink" href="#withdrawal-from-contracts" title="Permalink to this headline">¶</a></h3>
<p>使用提款模式有效地发送资金的推荐方法。虽然发送以太的最直观的结果是直接发送调用，但不推荐这样做，因为它引入了潜在的安全风险。您可以在安全考虑页面中对此进行阅读。<code class="docutils literal"><span class="pre">send</span></code><a class="reference internal" href="index.html#security-considerations"><span class="std std-ref">Security Considerations</span></a></p>
<p>这是在实践中退出模式的一个例子，在合约中，目标是将最多的钱发送到合约，以成为“最富有的”，受到以太的启发。<a class="reference external" href="https://www.kingoftheether.com/">King of the Ether</a></p>
<p>在下面的合约中，如果你被取代成为最富有的人，你将会得到一个人的资金，他已经成为新的最富有的人。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">WithdrawalContract</span> <span class="p">{</span>
    <span class="kt">address</span> <span class="k">public</span> <span class="nx">richest</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">mostSent</span><span class="p">;</span>

    <span class="k">mapping</span> <span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="nx">pendingWithdrawals</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">WithdrawalContract</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="nx">richest</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
        <span class="nx">mostSent</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">becomeRichest</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="nx">mostSent</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">pendingWithdrawals</span><span class="p">[</span><span class="nx">richest</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="nx">richest</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
            <span class="nx">mostSent</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">withdraw</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">amount</span> <span class="o">=</span> <span class="nx">pendingWithdrawals</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
        <span class="c1">// Remember to zero the pending refund before</span>
        <span class="c1">// sending to prevent re-entrancy attacks</span>
        <span class="nx">pendingWithdrawals</span><span class="p">[</span><span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nx">amount</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这与更直观的发送模式相反:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">11</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">SendContract</span> <span class="p">{</span>
    <span class="kt">address</span> <span class="k">public</span> <span class="nx">richest</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">mostSent</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">SendContract</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{</span>
        <span class="nx">richest</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
        <span class="nx">mostSent</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">becomeRichest</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="nx">mostSent</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// This line can cause problems (explained below).</span>
            <span class="nx">richest</span><span class="p">.</span><span class="nx">transfer</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
            <span class="nx">richest</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
            <span class="nx">mostSent</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意，在本例中，攻击者可能会通过导致最富的一种合约的地址，使其成为无法使用的状态(例如，通过使用还原()或仅消耗超过2300的气体津贴)。这样一来，当被要求将资金转移到“有毒”合约时，它就会失败，因此也会失败，因为合约将永远被卡住。<code class="docutils literal"><span class="pre">richest</span></code><code class="docutils literal"><span class="pre">revert()</span></code><code class="docutils literal"><span class="pre">transfer</span></code><code class="docutils literal"><span class="pre">becomeRichest</span></code></p>
<p>相反，如果你从第一个例子中使用“撤退”模式，攻击者只能导致他或她自己的撤退失败，而不是合约的工作。</p>
</div>
<div class="section" id="restricting-access">
<span id="index-1"></span><h3>Restricting Access<a class="headerlink" href="#restricting-access" title="Permalink to this headline">¶</a></h3>
<p>限制访问是合约的常见模式。请注意，您不能限制任何人或计算机读取您的事务或合约的状态的内容。使用加密可以使它变得有点硬，但是如果您的合约是用来读取数据的，那么其他人也是如此。</p>
<p>您可以通过其他合约限制对您的合约状态的读访问。这实际上是你声明的defaultunless让你的状态变量被公开。<strong>other contracts</strong><code class="docutils literal"><span class="pre">public</span></code></p>
<p>此外，你可以限制谁可以修改你的合约的状态或者调用你的合约的功能，这就是这部分的内容。</p>
<p id="index-2">函数修饰符的使用使得这些内容非常具有可读性。<strong>function modifiers</strong></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">AccessRestriction</span> <span class="p">{</span>
    <span class="c1">// These will be assigned at the construction</span>
    <span class="c1">// phase, where `msg.sender` is the account</span>
    <span class="c1">// creating this contract.</span>
    <span class="kt">address</span> <span class="k">public</span> <span class="nx">owner</span> <span class="o">=</span> <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">creationTime</span> <span class="o">=</span> <span class="nb">now</span><span class="p">;</span>

    <span class="c1">// Modifiers can be used to change</span>
    <span class="c1">// the body of a function.</span>
    <span class="c1">// If this modifier is used, it will</span>
    <span class="c1">// prepend a check that only passes</span>
    <span class="c1">// if the function is called from</span>
    <span class="c1">// a certain address.</span>
    <span class="kd">modifier</span> <span class="nx">onlyBy</span><span class="p">(</span><span class="kt">address</span> <span class="nx">_account</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">_account</span><span class="p">,</span>
            <span class="s2">"Sender not authorized."</span>
        <span class="p">);</span>
        <span class="c1">// Do not forget the "_;"! It will</span>
        <span class="c1">// be replaced by the actual function</span>
        <span class="c1">// body when the modifier is used.</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// Make `_newOwner` the new owner of this</span>
    <span class="cs">/// contract.</span>
    <span class="kd">function</span> <span class="nx">changeOwner</span><span class="p">(</span><span class="kt">address</span> <span class="nx">_newOwner</span><span class="p">)</span>
        <span class="k">public</span>
        <span class="nx">onlyBy</span><span class="p">(</span><span class="nx">owner</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">owner</span> <span class="o">=</span> <span class="nx">_newOwner</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">modifier</span> <span class="nx">onlyAfter</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_time</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nb">now</span> <span class="o">&gt;=</span> <span class="nx">_time</span><span class="p">,</span>
            <span class="s2">"Function called too early."</span>
        <span class="p">);</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cs">/// Erase ownership information.</span>
    <span class="cs">/// May only be called 6 weeks after</span>
    <span class="cs">/// the contract has been created.</span>
    <span class="kd">function</span> <span class="nx">disown</span><span class="p">()</span>
        <span class="k">public</span>
        <span class="nx">onlyBy</span><span class="p">(</span><span class="nx">owner</span><span class="p">)</span>
        <span class="nx">onlyAfter</span><span class="p">(</span><span class="nx">creationTime</span> <span class="o">+</span> <span class="mi">6</span> <span class="kt">weeks</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="nx">owner</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// This modifier requires a certain</span>
    <span class="c1">// fee being associated with a function call.</span>
    <span class="c1">// If the caller sent too much, he or she is</span>
    <span class="c1">// refunded, but only after the function body.</span>
    <span class="c1">// This was dangerous before Solidity version 0.4.0,</span>
    <span class="c1">// where it was possible to skip the part after `_;`.</span>
    <span class="kd">modifier</span> <span class="nx">costs</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">_amount</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;=</span> <span class="nx">_amount</span><span class="p">,</span>
            <span class="s2">"Not enough Ether provided."</span>
        <span class="p">);</span>
        <span class="nx">_</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">&gt;</span> <span class="nx">_amount</span><span class="p">)</span>
            <span class="nb">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nb">msg</span><span class="p">.</span><span class="nx">value</span> <span class="o">-</span> <span class="nx">_amount</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">forceOwnerChange</span><span class="p">(</span><span class="kt">address</span> <span class="nx">_newOwner</span><span class="p">)</span>
        <span class="k">public</span>
        <span class="k">payable</span>
        <span class="nx">costs</span><span class="p">(</span><span class="mi">200</span> <span class="kt">ether</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">owner</span> <span class="o">=</span> <span class="nx">_newOwner</span><span class="p">;</span>
        <span class="c1">// just some example condition</span>
        <span class="k">if</span> <span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="nx">owner</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">0</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1">// This did not refund for Solidity</span>
            <span class="c1">// before version 0.4.0.</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="c1">// refund overpaid fees</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下一个示例将讨论如何限制访问函数调用的更专门化方法。</p>
</div>
<div class="section" id="state-machine">
<span id="index-3"></span><h3>State Machine<a class="headerlink" href="#state-machine" title="Permalink to this headline">¶</a></h3>
<p>合约通常扮演着状态机的角色，这意味着它们在不同的阶段有不同的行为，或者可以调用不同的函数。函数调用通常结束一个stage并将合约转换到下一个阶段(特别是在合约模型交互的情况下)。在某一时刻，某些阶段是自动到达的，这也是很常见的。<strong>stages</strong><strong>interaction</strong><strong>time</strong></p>
<p>这是一个盲目的拍卖合约，它开始于舞台上“接受盲目的出价”，然后转向“公开竞价”，最终以“确定拍卖结果”结束。</p>
<p id="index-4">在这种情况下，函数修饰符可以用来建模状态，并防止合约的正确使用。</p>
<div class="section" id="example">
<h4>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h4>
<p>在下面的示例中，修饰符atStage确保函数只能在某个阶段调用。<code class="docutils literal"><span class="pre">atStage</span></code></p>
<p>自动定时过渡由修改器的时间转换来处理，它应该用于所有的函数。<code class="docutils literal"><span class="pre">timeTransitions</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Modifier Order Matters</strong>修饰符顺序很重要。如果atStage与timed转换结合在一起，请确保您在后面提到它，以便将新阶段istaken考虑进去。</p>
</div>
<p>最后，当函数完成时，修改器将会自动切换到下一个阶段。<code class="docutils literal"><span class="pre">transitionNext</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>Modifier May be Skipped</strong>修饰符可以跳过。这只适用于版本0.4.0之前的稳定性:由于修饰符是通过简单的替换代码来应用的，而不是通过使用函数调用来应用的，因此，如果该函数本身返回，那么在transitionNext修改器中的代码就会被跳过。如果您想这样做，确保从这些函数手动调用nextStage。从0。4.0开始，即使函数显式返回，修改器代码也会运行。</p>
</div>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">StateMachine</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="nx">Stages</span> <span class="p">{</span>
        <span class="nx">AcceptingBlindedBids</span><span class="p">,</span>
        <span class="nx">RevealBids</span><span class="p">,</span>
        <span class="nx">AnotherStage</span><span class="p">,</span>
        <span class="nx">AreWeDoneYet</span><span class="p">,</span>
        <span class="nx">Finished</span>
    <span class="p">}</span>

    <span class="c1">// This is the current stage.</span>
    <span class="nx">Stages</span> <span class="k">public</span> <span class="nx">stage</span> <span class="o">=</span> <span class="nx">Stages</span><span class="p">.</span><span class="nx">AcceptingBlindedBids</span><span class="p">;</span>

    <span class="kt">uint</span> <span class="k">public</span> <span class="nx">creationTime</span> <span class="o">=</span> <span class="nb">now</span><span class="p">;</span>

    <span class="kd">modifier</span> <span class="nx">atStage</span><span class="p">(</span><span class="nx">Stages</span> <span class="nx">_stage</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">require</span><span class="p">(</span>
            <span class="nx">stage</span> <span class="o">==</span> <span class="nx">_stage</span><span class="p">,</span>
            <span class="s2">"Function cannot be called at this time."</span>
        <span class="p">);</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">nextStage</span><span class="p">()</span> <span class="k">internal</span> <span class="p">{</span>
        <span class="nx">stage</span> <span class="o">=</span> <span class="nx">Stages</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="nx">stage</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Perform timed transitions. Be sure to mention</span>
    <span class="c1">// this modifier first, otherwise the guards</span>
    <span class="c1">// will not take the new stage into account.</span>
    <span class="kd">modifier</span> <span class="nx">timedTransitions</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">stage</span> <span class="o">==</span> <span class="nx">Stages</span><span class="p">.</span><span class="nx">AcceptingBlindedBids</span> <span class="o">&amp;&amp;</span>
                    <span class="nb">now</span> <span class="o">&gt;=</span> <span class="nx">creationTime</span> <span class="o">+</span> <span class="mi">10</span> <span class="kt">days</span><span class="p">)</span>
            <span class="nx">nextStage</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">stage</span> <span class="o">==</span> <span class="nx">Stages</span><span class="p">.</span><span class="nx">RevealBids</span> <span class="o">&amp;&amp;</span>
                <span class="nb">now</span> <span class="o">&gt;=</span> <span class="nx">creationTime</span> <span class="o">+</span> <span class="mi">12</span> <span class="kt">days</span><span class="p">)</span>
            <span class="nx">nextStage</span><span class="p">();</span>
        <span class="c1">// The other stages transition by transaction</span>
        <span class="nx">_</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Order of the modifiers matters here!</span>
    <span class="kd">function</span> <span class="nx">bid</span><span class="p">()</span>
        <span class="k">public</span>
        <span class="k">payable</span>
        <span class="nx">timedTransitions</span>
        <span class="nx">atStage</span><span class="p">(</span><span class="nx">Stages</span><span class="p">.</span><span class="nx">AcceptingBlindedBids</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// We will not implement that here</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">reveal</span><span class="p">()</span>
        <span class="k">public</span>
        <span class="nx">timedTransitions</span>
        <span class="nx">atStage</span><span class="p">(</span><span class="nx">Stages</span><span class="p">.</span><span class="nx">RevealBids</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="c1">// This modifier goes to the next stage</span>
    <span class="c1">// after the function is done.</span>
    <span class="kd">modifier</span> <span class="nx">transitionNext</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nx">_</span><span class="p">;</span>
        <span class="nx">nextStage</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">g</span><span class="p">()</span>
        <span class="k">public</span>
        <span class="nx">timedTransitions</span>
        <span class="nx">atStage</span><span class="p">(</span><span class="nx">Stages</span><span class="p">.</span><span class="nx">AnotherStage</span><span class="p">)</span>
        <span class="nx">transitionNext</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">h</span><span class="p">()</span>
        <span class="k">public</span>
        <span class="nx">timedTransitions</span>
        <span class="nx">atStage</span><span class="p">(</span><span class="nx">Stages</span><span class="p">.</span><span class="nx">AreWeDoneYet</span><span class="p">)</span>
        <span class="nx">transitionNext</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">i</span><span class="p">()</span>
        <span class="k">public</span>
        <span class="nx">timedTransitions</span>
        <span class="nx">atStage</span><span class="p">(</span><span class="nx">Stages</span><span class="p">.</span><span class="nx">Finished</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-bugs"></span><div class="section" id="list-of-known-bugs">
<span id="known-bugs"></span><span id="index-0"></span><h2>List of Known Bugs<a class="headerlink" href="#list-of-known-bugs" title="Permalink to this headline">¶</a></h2>
<p>下面，您可以找到一个json格式的列表，其中有一些已知的安全相关的bug。文件本身驻留在Github存储库中。该列表可以追溯到0.3.0版本，已知的bug只出现在未列出的版本中。<a class="reference external" href="https://github.com/ethereum/solidity/blob/develop/docs/bugs.json">Github repository</a></p>
<p>还有一个名为bugs_by_version的文件。json，它可以用来检查哪些bug影响了编译器的特定版本。<a class="reference external" href="https://github.com/ethereum/solidity/blob/develop/docs/bugs_by_version.json">bugs_by_version.json</a></p>
<p>合约来源验证工具和其他与合约相关的工具应根据以下标准查阅该列表:</p>
<blockquote>
<div><ul class="simple">
<li>It is mildly suspicious if a contract was compiled with a nightly
compiler version instead of a released version. This list does not keep
track of unreleased or nightly versions.</li>
<li>It is also mildly suspicious if a contract was compiled with a version that was
not the most recent at the time the contract was created. For contracts
created from other contracts, you have to follow the creation chain
back to a transaction and use the date of that transaction as creation date.</li>
<li>It is highly suspicious if a contract was compiled with a compiler that
contains a known bug and the contract was created at a time where a newer
compiler version containing a fix was already released.</li>
</ul>
</div></blockquote>
<p>下面已知的bug的JSON文件是一个对象数组，每个bug都有一个，有以下键:</p>
<dl class="docutils">
<dt>name</dt>
<dd>Unique name given to the bug</dd>
<dt>summary</dt>
<dd>Short description of the bug</dd>
<dt>description</dt>
<dd>Detailed description of the bug</dd>
<dt>link</dt>
<dd>URL of a website with more detailed information, optional</dd>
<dt>introduced</dt>
<dd>The first published compiler version that contained the bug, optional</dd>
<dt>fixed</dt>
<dd>The first published compiler version that did not contain the bug anymore</dd>
<dt>publish</dt>
<dd>The date at which the bug became known publicly, optional</dd>
<dt>severity</dt>
<dd>Severity of the bug: very low, low, medium, high. Takes into account
discoverability in contract tests, likelihood of occurrence and
potential damage by exploits.</dd>
<dt>conditions</dt>
<dd>Conditions that have to be met to trigger the bug. Currently, this
is an object that can contain a boolean value <code class="docutils literal"><span class="pre">optimizer</span></code>, which
means that the optimizer has to be switched on to enable the bug.
If no conditions are given, assume that the bug is present.</dd>
</dl>
<div class="highlight-js"><div class="highlight"><pre><span></span><span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"OneOfTwoConstructorsSkipped"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"If a contract has both a new-style constructor (using the constructor keyword) and an old-style constructor (a function with the same name as the contract) at the same time, one of them will be ignored."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"If a contract has both a new-style constructor (using the constructor keyword) and an old-style constructor (a function with the same name as the contract) at the same time, one of them will be ignored. There will be a compiler warning about the old-style constructor, so contracts only using new-style constructors are fine."</span><span class="p">,</span>
        <span class="s2">"introduced"</span><span class="o">:</span> <span class="s2">"0.4.22"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.23"</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"very low"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"ZeroFunctionSelector"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"It is possible to craft the name of a function such that it is executed instead of the fallback function in very specific circumstances."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"If a function has a selector consisting only of zeros, is payable and part of a contract that does not have a fallback function and at most five external functions in total, this function is called instead of the fallback function if Ether is sent to the contract without data."</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.18"</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"very low"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"DelegateCallReturnValue"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"The low-level .delegatecall() does not return the execution outcome, but converts the value returned by the functioned called to a boolean instead."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"The return value of the low-level .delegatecall() function is taken from a position in memory, where the call data or the return data resides. This value is interpreted as a boolean and put onto the stack. This means if the called function returns at least 32 zero bytes, .delegatecall() returns false even if the call was successuful."</span><span class="p">,</span>
        <span class="s2">"introduced"</span><span class="o">:</span> <span class="s2">"0.3.0"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.15"</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"low"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"ECRecoverMalformedInput"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"The ecrecover() builtin can return garbage for malformed input."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"The ecrecover precompile does not properly signal failure for malformed input (especially in the 'v' argument) and thus the Solidity function can return data that was previously present in the return area in memory."</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.14"</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"medium"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"SkipEmptyStringLiteral"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"If \"\" is used in a function call, the following function arguments will not be correctly passed to the function."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"If the empty string literal \"\" is used as an argument in a function call, it is skipped by the encoder. This has the effect that the encoding of all arguments following this is shifted left by 32 bytes and thus the function call data is corrupted."</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.12"</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"low"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"ConstantOptimizerSubtraction"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"In some situations, the optimizer replaces certain numbers in the code with routines that compute different numbers."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"The optimizer tries to represent any number in the bytecode by routines that compute them with less gas. For some special numbers, an incorrect routine is generated. This could allow an attacker to e.g. trick victims about a specific amount of ether, or function calls to call different functions (or none at all)."</span><span class="p">,</span>
        <span class="s2">"link"</span><span class="o">:</span> <span class="s2">"https://blog.ethereum.org/2017/05/03/solidity-optimizer-bug/"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.11"</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"low"</span><span class="p">,</span>
        <span class="s2">"conditions"</span><span class="o">:</span> <span class="p">{</span>
            <span class="s2">"optimizer"</span><span class="o">:</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"IdentityPrecompileReturnIgnored"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"Failure of the identity precompile was ignored."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"Calls to the identity contract, which is used for copying memory, ignored its return value. On the public chain, calls to the identity precompile can be made in a way that they never fail, but this might be different on private chains."</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"low"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.7"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"OptimizerStateKnowledgeNotResetForJumpdest"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"The optimizer did not properly reset its internal state at jump destinations, which could lead to data corruption."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"The optimizer performs symbolic execution at certain stages. At jump destinations, multiple code paths join and thus it has to compute a common state from the incoming edges. Computing this common state was simplified to just use the empty state, but this implementation was not done properly. This bug can cause data corruption."</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"medium"</span><span class="p">,</span>
        <span class="s2">"introduced"</span><span class="o">:</span> <span class="s2">"0.4.5"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.6"</span><span class="p">,</span>
        <span class="s2">"conditions"</span><span class="o">:</span> <span class="p">{</span>
            <span class="s2">"optimizer"</span><span class="o">:</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"HighOrderByteCleanStorage"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"For short types, the high order bytes were not cleaned properly and could overwrite existing data."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"Types shorter than 32 bytes are packed together into the same 32 byte storage slot, but storage writes always write 32 bytes. For some types, the higher order bytes were not cleaned properly, which made it sometimes possible to overwrite a variable in storage when writing to another one."</span><span class="p">,</span>
        <span class="s2">"link"</span><span class="o">:</span> <span class="s2">"https://blog.ethereum.org/2016/11/01/security-alert-solidity-variables-can-overwritten-storage/"</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"high"</span><span class="p">,</span>
        <span class="s2">"introduced"</span><span class="o">:</span> <span class="s2">"0.1.6"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.4"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"OptimizerStaleKnowledgeAboutSHA3"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"The optimizer did not properly reset its knowledge about SHA3 operations resulting in some hashes (also used for storage variable positions) not being calculated correctly."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"The optimizer performs symbolic execution in order to save re-evaluating expressions whose value is already known. This knowledge was not properly reset across control flow paths and thus the optimizer sometimes thought that the result of a SHA3 operation is already present on the stack. This could result in data corruption by accessing the wrong storage slot."</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"medium"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.3"</span><span class="p">,</span>
        <span class="s2">"conditions"</span><span class="o">:</span> <span class="p">{</span>
            <span class="s2">"optimizer"</span><span class="o">:</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"LibrariesNotCallableFromPayableFunctions"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"Library functions threw an exception when called from a call that received Ether."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"Library functions are protected against sending them Ether through a call. Since the DELEGATECALL opcode forwards the information about how much Ether was sent with a call, the library function incorrectly assumed that Ether was sent to the library and threw an exception."</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"low"</span><span class="p">,</span>
        <span class="s2">"introduced"</span><span class="o">:</span> <span class="s2">"0.4.0"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.2"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"SendFailsForZeroEther"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"The send function did not provide enough gas to the recipient if no Ether was sent with it."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"The recipient of an Ether transfer automatically receives a certain amount of gas from the EVM to handle the transfer. In the case of a zero-transfer, this gas is not provided which causes the recipient to throw an exception."</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"low"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.4.0"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"DynamicAllocationInfiniteLoop"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"Dynamic allocation of an empty memory array caused an infinite loop and thus an exception."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"Memory arrays can be created provided a length. If this length is zero, code was generated that did not terminate and thus consumed all gas."</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"low"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.3.6"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"OptimizerClearStateOnCodePathJoin"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"The optimizer did not properly reset its internal state at jump destinations, which could lead to data corruption."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"The optimizer performs symbolic execution at certain stages. At jump destinations, multiple code paths join and thus it has to compute a common state from the incoming edges. Computing this common state was not done correctly. This bug can cause data corruption, but it is probably quite hard to use for targeted attacks."</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"low"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.3.6"</span><span class="p">,</span>
        <span class="s2">"conditions"</span><span class="o">:</span> <span class="p">{</span>
            <span class="s2">"optimizer"</span><span class="o">:</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"CleanBytesHigherOrderBits"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"The higher order bits of short bytesNN types were not cleaned before comparison."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"Two variables of type bytesNN were considered different if their higher order bits, which are not part of the actual value, were different. An attacker might use this to reach seemingly unreachable code paths by providing incorrectly formatted input data."</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"medium/high"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.3.3"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"ArrayAccessCleanHigherOrderBits"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"Access to array elements for arrays of types with less than 32 bytes did not correctly clean the higher order bits, causing corruption in other array elements."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"Multiple elements of an array of values that are shorter than 17 bytes are packed into the same storage slot. Writing to a single element of such an array did not properly clean the higher order bytes and thus could lead to data corruption."</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"medium/high"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.3.1"</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">"name"</span><span class="o">:</span> <span class="s2">"AncientCompiler"</span><span class="p">,</span>
        <span class="s2">"summary"</span><span class="o">:</span> <span class="s2">"This compiler version is ancient and might contain several undocumented or undiscovered bugs."</span><span class="p">,</span>
        <span class="s2">"description"</span><span class="o">:</span> <span class="s2">"The list of bugs is only kept for compiler versions starting from 0.3.0, so older versions might contain undocumented bugs."</span><span class="p">,</span>
        <span class="s2">"severity"</span><span class="o">:</span> <span class="s2">"high"</span><span class="p">,</span>
        <span class="s2">"fixed"</span><span class="o">:</span> <span class="s2">"0.3.0"</span>
    <span class="p">}</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
<span id="document-contributing"></span><div class="section" id="contributing">
<h2>Contributing<a class="headerlink" href="#contributing" title="Permalink to this headline">¶</a></h2>
<p>帮助总是赞赏!</p>
<p>为了开始，您可以尝试从源代码构建，以便熟悉Solidity和构建过程的组件。此外，精通于在实体中编写智能合约也很有用。<a class="reference internal" href="index.html#building-from-source"><span class="std std-ref">Building from Source</span></a></p>
<p>我们尤其需要以下方面的帮助:</p>
<ul class="simple">
<li>Improving the documentation</li>
<li>Responding to questions from other users on <a class="reference external" href="https://ethereum.stackexchange.com">StackExchange</a> and the <a class="reference external" href="https://gitter.im/ethereum/solidity">Solidity Gitter</a></li>
<li>Fixing and responding to <a class="reference external" href="https://github.com/ethereum/solidity/issues">Solidity’s GitHub issues</a>, especially those tagged as
<a class="reference external" href="https://github.com/ethereum/solidity/issues?q=is%3Aopen+is%3Aissue+label%3Aup-for-grabs">up-for-grabs</a> which are
meant as introductory issues for external contributors.</li>
</ul>
<div class="section" id="how-to-report-issues">
<h3>How to Report Issues<a class="headerlink" href="#how-to-report-issues" title="Permalink to this headline">¶</a></h3>
<p>要报告一个问题，请使用github问题跟踪器。在报告问题时，请提及以下细节:<a class="reference external" href="https://github.com/ethereum/solidity/issues">GitHub issues tracker</a></p>
<ul class="simple">
<li>Which version of Solidity you are using</li>
<li>What was the source code (if applicable)</li>
<li>Which platform are you running on</li>
<li>How to reproduce the issue</li>
<li>What was the result of the issue</li>
<li>What the expected behaviour is</li>
</ul>
<p>减少导致这个问题的最低限度的源代码总是非常有帮助的，有时甚至会澄清误解。</p>
</div>
<div class="section" id="workflow-for-pull-requests">
<h3>Workflow for Pull Requests<a class="headerlink" href="#workflow-for-pull-requests" title="Permalink to this headline">¶</a></h3>
<p>为了做出贡献，请从开发分支中分出来，并在那里进行修改。您的提交消息应该详细说明为什么您要将变更添加到您所做的工作中(除非它是一个微小的更改)。<code class="docutils literal"><span class="pre">develop</span></code><em>why</em><em>what</em></p>
<p>如果您需要在使用fork(例如，为了解决可能的合并冲突)后从开发中提取任何更改，请避免使用git mergeand，而将您的分支重新设置为git。<code class="docutils literal"><span class="pre">develop</span></code><code class="docutils literal"><span class="pre">git</span> <span class="pre">merge</span></code><code class="docutils literal"><span class="pre">git</span> <span class="pre">rebase</span></code></p>
<p>此外，如果您正在编写一个新特性，请确保您编写了适当的boost测试用例并将它们置于测试/。<code class="docutils literal"><span class="pre">test/</span></code></p>
<p>但是，如果您正在进行更大的更改，请先咨询Solidity Development Gitter通道(与上面提到的不同，这是基于编译器和语言开发而不是语言使用)。<a class="reference external" href="https://gitter.im/ethereum/solidity-dev">Solidity Development Gitter channel</a></p>
<p>最后，请确保您尊重这个项目的编码风格。此外，即使我们进行CI测试，请测试您的代码，并确保在提交请求之前在本地构建。<a class="reference external" href="https://raw.githubusercontent.com/ethereum/solidity/develop/CODING_STYLE.md">coding style</a></p>
<p>谢谢你的帮助!</p>
</div>
<div class="section" id="running-the-compiler-tests">
<h3>Running the compiler tests<a class="headerlink" href="#running-the-compiler-tests" title="Permalink to this headline">¶</a></h3>
<p>固体包括不同类型的测试。它们被包含在名为soltest的应用程序中。其中一些需要在测试模式下使用cpp-ethereum客户端，有些则需要安装libz3。<code class="docutils literal"><span class="pre">soltest</span></code><code class="docutils literal"><span class="pre">cpp-ethereum</span></code><code class="docutils literal"><span class="pre">libz3</span></code></p>
<p><code class="docutils literal"><span class="pre">soltest</span></code>soltest读取带有预期结果的测试合约。/测试/libsolidity/ syntaxtest。为了找到这些测试，必须使用-testpath命令行选项指定根测试目录，例如/build/test/soltest—testpath ./test。<code class="docutils literal"><span class="pre">./test/libsolidity/syntaxTests</span></code><code class="docutils literal"><span class="pre">--testpath</span></code><code class="docutils literal"><span class="pre">./build/test/soltest</span> <span class="pre">--</span> <span class="pre">--testpath</span> <span class="pre">./test</span></code></p>
<p>要禁用z3测试，可以使用./build/test/soltest -- -no-smt -testpath ./测试，并运行不需要cpp-ethereum的测试的子集。/build/test/soltest——no-ipc—testpath ./test。<code class="docutils literal"><span class="pre">./build/test/soltest</span> <span class="pre">--</span> <span class="pre">--no-smt</span> <span class="pre">--testpath</span> <span class="pre">./test</span></code><code class="docutils literal"><span class="pre">cpp-ethereum</span></code><code class="docutils literal"><span class="pre">./build/test/soltest</span> <span class="pre">--</span> <span class="pre">--no-ipc</span> <span class="pre">--testpath</span> <span class="pre">./test</span></code></p>
<p>对于所有其他测试，您需要安装cpp-ethereum并在测试模式下运行它:eth -test -d /tmp/testeth。<a class="reference external" href="https://github.com/ethereum/cpp-ethereum/releases/download/solidityTester/eth">cpp-ethereum</a><code class="docutils literal"><span class="pre">eth</span> <span class="pre">--test</span> <span class="pre">-d</span> <span class="pre">/tmp/testeth</span></code></p>
<p>然后运行实际的测试:./build/test/soltest——ipcpath /tmp/testeth/geth。ipc - testpath。/测试。<code class="docutils literal"><span class="pre">./build/test/soltest</span> <span class="pre">--</span> <span class="pre">--ipcpath</span> <span class="pre">/tmp/testeth/geth.ipc</span> <span class="pre">--testpath</span> <span class="pre">./test</span></code></p>
<p>要运行测试的子集，可以使用筛选器:soltest -t TestSuite/TestName——ipcpath /tmp/testeth/geth。ipc——testpath ./test，其中TestName可以是通配符*。<code class="docutils literal"><span class="pre">soltest</span> <span class="pre">-t</span> <span class="pre">TestSuite/TestName</span> <span class="pre">--</span> <span class="pre">--ipcpath</span> <span class="pre">/tmp/testeth/geth.ipc</span> <span class="pre">--testpath</span> <span class="pre">./test</span></code><code class="docutils literal"><span class="pre">TestName</span></code><code class="docutils literal"><span class="pre">*</span></code></p>
<p>或者，在脚本/测试中有一个测试脚本。如果它在路径中(但不下载它)，它将自动执行所有测试和runscpp-ethereum。<code class="docutils literal"><span class="pre">scripts/test.sh</span></code><code class="docutils literal"><span class="pre">cpp-ethereum</span></code></p>
<p>Travis CI甚至还运行了一些额外的测试(包括solc-js和测试第三方Solidity框架)，这些测试需要编译Emscripten目标。<code class="docutils literal"><span class="pre">solc-js</span></code></p>
<div class="section" id="writing-and-running-syntax-tests">
<h4>Writing and running syntax tests<a class="headerlink" href="#writing-and-running-syntax-tests" title="Permalink to this headline">¶</a></h4>
<p>如上所述，语法测试存储在单个合约中。这些文件必须包含注释，说明各自测试的预期结果。测试套件将根据给定的期望进行编译和检查。</p>
<p>例子:。/测试/ libsolidity / syntaxTests / double_stateVariable_declaration.sol<code class="docutils literal"><span class="pre">./test/libsolidity/syntaxTests/double_stateVariable_declaration.sol</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">test</span> <span class="p">{</span>
    <span class="kt">uint256</span> <span class="nx">variable</span><span class="p">;</span>
    <span class="kt">uint128</span> <span class="nx">variable</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ----</span>
<span class="c1">// DeclarationError: Identifier already declared.</span>
</pre></div>
</div>
<p>语法测试必须包含至少在测试本身下的合约，然后是seperator——。上面的附加注释用于描述预期的编译器错误或警告。这个部分可以是空的，以防止合约在没有任何错误或警告的情况下编译。<code class="docutils literal"><span class="pre">----</span></code></p>
<p>在上面的例子中，声明了状态变量变量两次，这是不允许的。这将导致声明错误，声明已经声明了标识符。<code class="docutils literal"><span class="pre">variable</span></code><code class="docutils literal"><span class="pre">DeclarationError</span></code></p>
<p>用于这些测试的工具称为隔离，可以在下面找到。/测试/工具/。它是一种交互式工具，允许使用您首选的文本编辑器进行失败的合约。让我们尝试通过删除第二个变量声明来打破这个测试:<code class="docutils literal"><span class="pre">isoltest</span></code><code class="docutils literal"><span class="pre">./test/tools/</span></code><code class="docutils literal"><span class="pre">variable</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">test</span> <span class="p">{</span>
    <span class="kt">uint256</span> <span class="nx">variable</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ----</span>
<span class="c1">// DeclarationError: Identifier already declared.</span>
</pre></div>
</div>
<p>再次运行。/测试/隔离将导致测试失败:<code class="docutils literal"><span class="pre">./test/isoltest</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">syntaxTests</span><span class="o">/</span><span class="nx">double_stateVariable_declaration</span><span class="p">.</span><span class="nx">sol</span><span class="o">:</span> <span class="nx">FAIL</span>
    <span class="nx">Contract</span><span class="o">:</span>
        <span class="kd">contract</span> <span class="nx">test</span> <span class="p">{</span>
            <span class="kt">uint256</span> <span class="nx">variable</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="nx">Expected</span> <span class="nx">result</span><span class="o">:</span>
        <span class="nx">DeclarationError</span><span class="o">:</span> <span class="nx">Identifier</span> <span class="nx">already</span> <span class="nx">declared</span><span class="p">.</span>
    <span class="nx">Obtained</span> <span class="nx">result</span><span class="o">:</span>
        <span class="nx">Success</span>
</pre></div>
</div>
<p>在获得的结果旁边打印预期的结果，但也提供了更改编辑/更新/跳过当前合约或甚至退出的方法。isoltest提供了几个失败测试的选项:<code class="docutils literal"><span class="pre">isoltest</span></code></p>
<ul class="simple">
<li>edit: <code class="docutils literal"><span class="pre">isoltest</span></code> will try to open the editor that was specified before using <code class="docutils literal"><span class="pre">isoltest</span> <span class="pre">--editor</span> <span class="pre">/path/to/editor</span></code>. If no path was set, this will result in a runtime error. In case an editor was specified, this will open it such that the contract can be adjusted.</li>
<li>update: Updates the contract under test. This will either remove the annotation which contains the exception not met or will add missing expectations. The test will then be run again.</li>
<li>skip: Skips the execution of this particular test.</li>
<li>quit: Quits <code class="docutils literal"><span class="pre">isoltest</span></code>.</li>
</ul>
<p>自动更新上面的测试将会改变它。</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">contract</span> <span class="nx">test</span> <span class="p">{</span>
    <span class="kt">uint256</span> <span class="nx">variable</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ----</span>
</pre></div>
</div>
<p>并重新运行测试。它将再次通过:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">Re</span><span class="o">-</span><span class="nx">running</span> <span class="nx">test</span> <span class="kr">case</span><span class="p">...</span>
<span class="nx">syntaxTests</span><span class="o">/</span><span class="nx">double_stateVariable_declaration</span><span class="p">.</span><span class="nx">sol</span><span class="o">:</span> <span class="nx">OK</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">请为合约文件选择一个名称，这是对所测试的内容的自我解释，例如:double_variable_. sol。不要将多个合约放入一个文件中。孤立测试目前无法单独识别它们。<code class="docutils literal"><span class="pre">double_variable_declaration.sol</span></code><code class="docutils literal"><span class="pre">isoltest</span></code></p>
</div>
</div>
</div>
<div class="section" id="running-the-fuzzer-via-afl">
<h3>Running the Fuzzer via AFL<a class="headerlink" href="#running-the-fuzzer-via-afl" title="Permalink to this headline">¶</a></h3>
<p>Fuzzing是一种技术，它可以在多或少的随机输入上运行程序，以找到异常的执行状态(分段错误、异常等)。现代的fuzzers是聪明的，并且做一个定向搜索的输入。我们有一个专门的二进制代码，叫做solfuzzer，它将源代码作为inputand，当它遇到内部编译器错误、分割错误或类似时，就会失败，但是如果代码包含错误，则不会失败。这样，就可以通过fuzzing工具找到编译器内部的问题。<code class="docutils literal"><span class="pre">solfuzzer</span></code></p>
<p>我们主要使用AFL进行fuzzing。您需要手动下载和构建AFL。接下来，用AFL作为编译器构建Solidity(或者仅仅是solfuzzer二进制文件):<a class="reference external" href="http://lcamtuf.coredump.cx/afl/">AFL</a><code class="docutils literal"><span class="pre">solfuzzer</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">cd</span> <span class="nx">build</span>
<span class="err">#</span> <span class="k">if</span> <span class="nx">needed</span>
<span class="nx">make</span> <span class="nx">clean</span>
<span class="nx">cmake</span> <span class="p">..</span> <span class="o">-</span><span class="nx">DCMAKE_C_COMPILER</span><span class="o">=</span><span class="nx">path</span><span class="o">/</span><span class="nx">to</span><span class="o">/</span><span class="nx">afl</span><span class="o">-</span><span class="nx">gcc</span> <span class="o">-</span><span class="nx">DCMAKE_CXX_COMPILER</span><span class="o">=</span><span class="nx">path</span><span class="o">/</span><span class="nx">to</span><span class="o">/</span><span class="nx">afl</span><span class="o">-</span><span class="nx">g</span><span class="o">++</span>
<span class="nx">make</span> <span class="nx">solfuzzer</span>
</pre></div>
</div>
<p>接下来，需要一些示例源文件。这将使fuzzerto查找错误变得更加容易。您可以从语法测试中复制一些文件，或者从文档或其他测试中提取测试文件:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">mkdir</span> <span class="o">/</span><span class="nx">tmp</span><span class="o">/</span><span class="nx">test_cases</span>
<span class="nx">cd</span> <span class="o">/</span><span class="nx">tmp</span><span class="o">/</span><span class="nx">test_cases</span>
<span class="err">#</span> <span class="nx">extract</span> <span class="nx">from</span> <span class="nx">tests</span><span class="o">:</span>
<span class="nx">path</span><span class="o">/</span><span class="nx">to</span><span class="o">/</span><span class="nx">solidity</span><span class="o">/</span><span class="nx">scripts</span><span class="o">/</span><span class="nx">isolate_tests</span><span class="p">.</span><span class="nx">py</span> <span class="nx">path</span><span class="o">/</span><span class="nx">to</span><span class="o">/</span><span class="nx">solidity</span><span class="o">/</span><span class="nx">test</span><span class="o">/</span><span class="nx">libsolidity</span><span class="o">/</span><span class="nx">SolidityEndToEndTest</span><span class="p">.</span><span class="nx">cpp</span>
<span class="err">#</span> <span class="nx">extract</span> <span class="nx">from</span> <span class="nx">documentation</span><span class="o">:</span>
<span class="nx">path</span><span class="o">/</span><span class="nx">to</span><span class="o">/</span><span class="nx">solidity</span><span class="o">/</span><span class="nx">scripts</span><span class="o">/</span><span class="nx">isolate_tests</span><span class="p">.</span><span class="nx">py</span> <span class="nx">path</span><span class="o">/</span><span class="nx">to</span><span class="o">/</span><span class="nx">solidity</span><span class="o">/</span><span class="nx">docs</span> <span class="nx">docs</span>
</pre></div>
</div>
<p>AFL文档说明，语料库(初始输入文件)不应该太大。这些文件本身不应该大于1 kB，而且每个功能应该有最多的一个输入文件，所以最好从一个小的ofinput文件开始。还有一种叫做afl-cmin的工具，它可以调整输入文件，从而导致二进制文件的类似行为。<code class="docutils literal"><span class="pre">afl-cmin</span></code></p>
<p>现在运行fuzzer (-m将内存大小扩展到60mb):<code class="docutils literal"><span class="pre">-m</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nx">afl</span><span class="o">-</span><span class="nx">fuzz</span> <span class="o">-</span><span class="nx">m</span> <span class="mi">60</span> <span class="o">-</span><span class="nx">i</span> <span class="o">/</span><span class="nx">tmp</span><span class="o">/</span><span class="nx">test_cases</span> <span class="o">-</span><span class="nx">o</span> <span class="o">/</span><span class="nx">tmp</span><span class="o">/</span><span class="nx">fuzzer_reports</span> <span class="o">--</span> <span class="err">/path/to/solfuzzer</span>
</pre></div>
</div>
<p>fuzzer将创建导致/tmp/fuzzer_reports失败的源文件。通常，它会发现许多类似的源文件产生相同的错误。您可以使用工具脚本/uniqueErrors。用sh过滤出唯一的错误。<code class="docutils literal"><span class="pre">/tmp/fuzzer_reports</span></code><code class="docutils literal"><span class="pre">scripts/uniqueErrors.sh</span></code></p>
</div>
<div class="section" id="whiskers">
<h3>Whiskers<a class="headerlink" href="#whiskers" title="Permalink to this headline">¶</a></h3>
<p><em>Whiskers</em>胡须是一种类似于胡子的模板系统。它在不同的地方使用它来辅助可读性，从而使代码具有可维护性和可验证性。<a class="reference external" href="https://mustache.github.io">Mustache</a></p>
<p>这种语法有很大的区别:为了帮助解析和避免与内联汇编冲突(在内联汇编中，符号&lt;和&gt;是无效的，而{和}被用来分隔块)，Mustache的模板标记{{和}}是由&lt;和&gt;组成的。另一个限制是，列表只解决了一个深度，它们不会递归。这在未来可能会改变。<code class="docutils literal"><span class="pre">{{</span></code><code class="docutils literal"><span class="pre">}}</span></code><code class="docutils literal"><span class="pre">&lt;</span></code><code class="docutils literal"><span class="pre">&gt;</span></code><a class="reference internal" href="index.html#inline-assembly"><span class="std std-ref">Inline Assembly</span></a><code class="docutils literal"><span class="pre">&lt;</span></code><code class="docutils literal"><span class="pre">&gt;</span></code><code class="docutils literal"><span class="pre">{</span></code><code class="docutils literal"><span class="pre">}</span></code></p>
<p>粗略的说明如下:</p>
<p>&lt;name&gt;的任何发生都由提供的变量名的字符串值替换，而没有任何转义和没有迭代的替换。一个区域可以通过&lt;#name&gt;…&lt;/name&gt;。它的内容与提供给模板系统的变量集一样多，每一次用它们各自的值替换任何&lt;内&gt;项。顶级变量也可以在这些区域内使用。<code class="docutils literal"><span class="pre">&lt;name&gt;</span></code><code class="docutils literal"><span class="pre">name</span></code><code class="docutils literal"><span class="pre">&lt;#name&gt;...&lt;/name&gt;</span></code><code class="docutils literal"><span class="pre">&lt;inner&gt;</span></code></p>
</div>
</div>
<span id="document-frequently-asked-questions"></span><div class="section" id="frequently-asked-questions">
<h2>Frequently Asked Questions<a class="headerlink" href="#frequently-asked-questions" title="Permalink to this headline">¶</a></h2>
<p>这个列表最初是由5个dogit编辑的。<a class="reference external" href="mailto:fivedogit%40gmail.com">fivedogit</a></p>
<div class="section" id="basic-questions">
<h3>Basic Questions<a class="headerlink" href="#basic-questions" title="Permalink to this headline">¶</a></h3>
<div class="section" id="is-it-possible-to-do-something-on-a-specific-block-number-e-g-publish-a-contract-or-execute-a-transaction">
<h4>Is it possible to do something on a specific block number? (e.g. publish a contract or execute a transaction)<a class="headerlink" href="#is-it-possible-to-do-something-on-a-specific-block-number-e-g-publish-a-contract-or-execute-a-transaction" title="Permalink to this headline">¶</a></h4>
<p>事务不保证在下一个块或任何未来的块中发生，因为它是由矿商来包含事务，而不是事务的提交者。这适用于函数调用/事务和合约创建事务。</p>
<p>如果你想安排未来的合约，你可以使用闹钟。<a class="reference external" href="http://www.ethereum-alarm-clock.com/">alarm clock</a></p>
</div>
<div class="section" id="what-is-the-transaction-payload">
<h4>What is the transaction “payload”?<a class="headerlink" href="#what-is-the-transaction-payload" title="Permalink to this headline">¶</a></h4>
<p>这只是随请求发送的字节码“数据”。</p>
</div>
<div class="section" id="is-there-a-decompiler-available">
<h4>Is there a decompiler available?<a class="headerlink" href="#is-there-a-decompiler-available" title="Permalink to this headline">¶</a></h4>
<p>没有精确的反编译，但孔隙度很接近。由于在编译过程中丢失了一些诸如变量名、注释和源代码格式等信息，因此无法完全恢复原始的源代码。<a class="reference external" href="https://github.com/comaeio/porosity">Porosity</a></p>
<p>字节码可以分解为操作码，这是由几个区块链探索者提供的服务。</p>
<p>区块链的合约如果要被第三方使用，应该有原始的sourcecode发布。</p>
</div>
<div class="section" id="create-a-contract-that-can-be-killed-and-return-funds">
<h4>Create a contract that can be killed and return funds<a class="headerlink" href="#create-a-contract-that-can-be-killed-and-return-funds" title="Permalink to this headline">¶</a></h4>
<p>首先，一个警告:杀死合约听起来是个好主意，因为“清理”总是好的，但是如上所述，它并没有真正的清理干净。此外，如果以太被送去解除合约，以太将永远消失。</p>
<p>如果您想要停用您的合约，最好是通过改变一些导致所有函数抛出的内部状态来禁用它们。这将使合约和乙醚不可能被自动退回。<strong>disable</strong></p>
<p>现在来回答这个问题:在构造函数中，msg。发送者是thecreator。保存它。然后selfdestruct(创造者);杀死并返还资金。<code class="docutils literal"><span class="pre">msg.sender</span></code><code class="docutils literal"><span class="pre">selfdestruct(creator);</span></code></p>
<p><a class="reference external" href="https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/05_greeter.sol">example</a></p>
<p>请注意，如果您在您的合约的顶部输入“必死”，并且声明的经济合约是必死的{……然后用一个编译器编译它(它包含了Remix)，然后把kill()处理给你。一旦合约是“必死的”，那么您就可以使用与myexample相同的方法了。<code class="docutils literal"><span class="pre">import</span> <span class="pre">"mortal"</span></code><code class="docutils literal"><span class="pre">contract</span> <span class="pre">SomeContract</span> <span class="pre">is</span> <span class="pre">mortal</span> <span class="pre">{</span> <span class="pre">...</span></code><a class="reference external" href="https://remix.ethereum.org/">Remix</a><code class="docutils literal"><span class="pre">kill()</span></code><code class="docutils literal"><span class="pre">contractname.kill.sendTransaction({from:eth.coinbase})</span></code></p>
</div>
<div class="section" id="can-you-return-an-array-or-a-string-from-a-solidity-function-call">
<h4>Can you return an array or a <code class="docutils literal"><span class="pre">string</span></code> from a solidity function call?<a class="headerlink" href="#can-you-return-an-array-or-a-string-from-a-solidity-function-call" title="Permalink to this headline">¶</a></h4>
<p>是的。看到array_receiver_and_returner.sol。<a class="reference external" href="https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/60_array_receiver_and_returner.sol">array_receiver_and_returner.sol</a></p>
<p>不过，有问题的是返回任何大小不一的数据(例如，像uint[]这样的变量大小的数组)，它来自于一个来自于Solidity内部的函数。这是EVM的一个限制，将通过下一个协议更新来解决。<code class="docutils literal"><span class="pre">uint[]</span></code><strong>called from within Solidity</strong></p>
<p>将变量大小的数据作为外部事务或调用的一部分返回是可以的。</p>
</div>
<div class="section" id="is-it-possible-to-in-line-initialize-an-array-like-so-string-myarray-a-b">
<h4>Is it possible to in-line initialize an array like so: <code class="docutils literal"><span class="pre">string[]</span> <span class="pre">myarray</span> <span class="pre">=</span> <span class="pre">["a",</span> <span class="pre">"b"];</span></code><a class="headerlink" href="#is-it-possible-to-in-line-initialize-an-array-like-so-string-myarray-a-b" title="Permalink to this headline">¶</a></h4>
<p>是的。但是应该注意的是，目前只处理静态大小的内存数组。您甚至可以在return语句中创建内联memoryarray。很酷,不是吗?</p>
<p>例子:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="k">pure</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint8</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span> <span class="p">{</span>
        <span class="kt">string</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="k">memory</span> <span class="nx">adaArr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"This"</span><span class="p">,</span> <span class="s2">"is"</span><span class="p">,</span> <span class="s2">"an"</span><span class="p">,</span> <span class="s2">"array"</span><span class="p">];</span>
        <span class="k">return</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="can-a-contract-function-return-a-struct">
<h4>Can a contract function return a <code class="docutils literal"><span class="pre">struct</span></code>?<a class="headerlink" href="#can-a-contract-function-return-a-struct" title="Permalink to this headline">¶</a></h4>
<p>是的，但仅限于内部函数调用。<code class="docutils literal"><span class="pre">internal</span></code></p>
</div>
<div class="section" id="if-i-return-an-enum-i-only-get-integer-values-in-web3-js-how-to-get-the-named-values">
<h4>If I return an <code class="docutils literal"><span class="pre">enum</span></code>, I only get integer values in web3.js. How to get the named values?<a class="headerlink" href="#if-i-return-an-enum-i-only-get-integer-values-in-web3-js-how-to-get-the-named-values" title="Permalink to this headline">¶</a></h4>
<p>在ABI中不支持Enums，它们只是被Solidity支持。你必须自己做映射，我们可能会提供一些帮助。</p>
</div>
<div class="section" id="can-state-variables-be-initialized-in-line">
<h4>Can state variables be initialized in-line?<a class="headerlink" href="#can-state-variables-be-initialized-in-line" title="Permalink to this headline">¶</a></h4>
<p>是的，这对于所有类型都是可能的(甚至对于struct)。但是，对于数组，应该注意到必须将它们声明为静态内存数组。</p>
<p>例子:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kd">struct</span> <span class="nx">S</span> <span class="p">{</span>
        <span class="kt">uint</span> <span class="nx">a</span><span class="p">;</span>
        <span class="kt">uint</span> <span class="nx">b</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">S</span> <span class="k">public</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">S</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="kt">string</span> <span class="nx">name</span> <span class="o">=</span> <span class="s2">"Ada"</span><span class="p">;</span>
    <span class="kt">string</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="nx">adaArr</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"This"</span><span class="p">,</span> <span class="s2">"is"</span><span class="p">,</span> <span class="s2">"an"</span><span class="p">,</span> <span class="s2">"array"</span><span class="p">];</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">D</span> <span class="p">{</span>
    <span class="nx">C</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">C</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="how-do-structs-work">
<h4>How do structs work?<a class="headerlink" href="#how-do-structs-work" title="Permalink to this headline">¶</a></h4>
<p>看到struct_and_for_loop_tester.sol。<a class="reference external" href="https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/65_struct_and_for_loop_tester.sol">struct_and_for_loop_tester.sol</a></p>
</div>
<div class="section" id="how-do-for-loops-work">
<h4>How do for loops work?<a class="headerlink" href="#how-do-for-loops-work" title="Permalink to this headline">¶</a></h4>
<p>非常类似于JavaScript。不过，有一点值得注意:</p>
<p>如果你用for (var i = 0;我&lt; a.length;i ++) {a[i] = i;}，我将从0中推断出i的类型，它的类型是uint8。这意味着如果a有超过255个元素，那么您的循环将不会终止，因为我只能将值保持到255。<code class="docutils literal"><span class="pre">for</span> <span class="pre">(var</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">a.length;</span> <span class="pre">i</span> <span class="pre">++)</span> <span class="pre">{</span> <span class="pre">a[i]</span> <span class="pre">=</span> <span class="pre">i;</span> <span class="pre">}</span></code><code class="docutils literal"><span class="pre">i</span></code><code class="docutils literal"><span class="pre">0</span></code><code class="docutils literal"><span class="pre">uint8</span></code><code class="docutils literal"><span class="pre">a</span></code><code class="docutils literal"><span class="pre">255</span></code><code class="docutils literal"><span class="pre">i</span></code><code class="docutils literal"><span class="pre">255</span></code></p>
<p>更好地使用(uint i = 0;我&lt; a.length……<code class="docutils literal"><span class="pre">for</span> <span class="pre">(uint</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">a.length...</span></code></p>
<p>看到struct_and_for_loop_tester.sol。<a class="reference external" href="https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/65_struct_and_for_loop_tester.sol">struct_and_for_loop_tester.sol</a></p>
</div>
<div class="section" id="what-are-some-examples-of-basic-string-manipulation-substring-indexof-charat-etc">
<h4>What are some examples of basic string manipulation (<code class="docutils literal"><span class="pre">substring</span></code>, <code class="docutils literal"><span class="pre">indexOf</span></code>, <code class="docutils literal"><span class="pre">charAt</span></code>, etc)?<a class="headerlink" href="#what-are-some-examples-of-basic-string-manipulation-substring-indexof-charat-etc" title="Permalink to this headline">¶</a></h4>
<p>stringUtils中有一些字符串实用函数。未来将会扩展。此外，蛛形纲动物也有书写凝固的能力。<a class="reference external" href="https://github.com/ethereum/dapp-bin/blob/master/library/stringUtils.sol">stringUtils.sol</a><a class="reference external" href="https://github.com/Arachnid/solidity-stringutils">solidity-stringutils</a></p>
<p>现在，如果您想修改一个字符串(即使您只想知道它的长度)，您应该始终将它转换为一个字节:<code class="docutils literal"><span class="pre">bytes</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">string</span> <span class="nx">s</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">append</span><span class="p">(</span><span class="kt">byte</span> <span class="nx">c</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">bytes</span><span class="p">(</span><span class="nx">s</span><span class="p">).</span><span class="nx">push</span><span class="p">(</span><span class="nx">c</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">set</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">i</span><span class="p">,</span> <span class="kt">byte</span> <span class="nx">c</span><span class="p">)</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">bytes</span><span class="p">(</span><span class="nx">s</span><span class="p">)[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">c</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="can-i-concatenate-two-strings">
<h4>Can I concatenate two strings?<a class="headerlink" href="#can-i-concatenate-two-strings" title="Permalink to this headline">¶</a></h4>
<p>你现在必须手动操作。</p>
</div>
<div class="section" id="why-is-the-low-level-function-call-less-favorable-than-instantiating-a-contract-with-a-variable-contractb-b-and-executing-its-functions-b-dosomething">
<h4>Why is the low-level function <code class="docutils literal"><span class="pre">.call()</span></code> less favorable than instantiating a contract with a variable (<code class="docutils literal"><span class="pre">ContractB</span> <span class="pre">b;</span></code>) and executing its functions (<code class="docutils literal"><span class="pre">b.doSomething();</span></code>)?<a class="headerlink" href="#why-is-the-low-level-function-call-less-favorable-than-instantiating-a-contract-with-a-variable-contractb-b-and-executing-its-functions-b-dosomething" title="Permalink to this headline">¶</a></h4>
<p>如果你使用的是实际的函数，编译器会告诉你，你的参数是否匹配，如果函数不可见，它会为你做参数的包装。</p>
<p>看到平。索尔andpong.sol。<a class="reference external" href="https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/45_ping.sol">ping.sol</a><a class="reference external" href="https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/45_pong.sol">pong.sol</a></p>
</div>
<div class="section" id="is-unused-gas-automatically-refunded">
<h4>Is unused gas automatically refunded?<a class="headerlink" href="#is-unused-gas-automatically-refunded" title="Permalink to this headline">¶</a></h4>
<p>是的，它是即时的，即作为交易的一部分完成。</p>
</div>
<div class="section" id="when-returning-a-value-of-say-uint-type-is-it-possible-to-return-an-undefined-or-null-like-value">
<h4>When returning a value of say <code class="docutils literal"><span class="pre">uint</span></code> type, is it possible to return an <code class="docutils literal"><span class="pre">undefined</span></code> or “null”-like value?<a class="headerlink" href="#when-returning-a-value-of-say-uint-type-is-it-possible-to-return-an-undefined-or-null-like-value" title="Permalink to this headline">¶</a></h4>
<p>这是不可能的，因为所有类型都使用了完整的值范围。</p>
<p>您可以选择抛出错误，这也将还原整个事务，如果遇到意外情况，这可能是个好主意。<code class="docutils literal"><span class="pre">throw</span></code></p>
<p>如果你不想扔，你可以返回一对:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="nx">counters</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">getCounter</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">index</span><span class="p">)</span>
        <span class="k">public</span>
        <span class="k">view</span>
        <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">counter</span><span class="p">,</span> <span class="kt">bool</span> <span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">counters</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="p">(</span><span class="nx">counters</span><span class="p">[</span><span class="nx">index</span><span class="p">],</span> <span class="kc">false</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">checkCounter</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">index</span><span class="p">)</span> <span class="k">public</span> <span class="k">view</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="p">(</span><span class="nx">counter</span><span class="p">,</span> <span class="nx">error</span><span class="p">)</span> <span class="o">=</span> <span class="nx">getCounter</span><span class="p">(</span><span class="nx">index</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="are-comments-included-with-deployed-contracts-and-do-they-increase-deployment-gas">
<h4>Are comments included with deployed contracts and do they increase deployment gas?<a class="headerlink" href="#are-comments-included-with-deployed-contracts-and-do-they-increase-deployment-gas" title="Permalink to this headline">¶</a></h4>
<p>不，在编译期间，不需要执行的所有操作都被删除。其中包括注释、变量名称和类型名称。</p>
</div>
<div class="section" id="what-happens-if-you-send-ether-along-with-a-function-call-to-a-contract">
<h4>What happens if you send ether along with a function call to a contract?<a class="headerlink" href="#what-happens-if-you-send-ether-along-with-a-function-call-to-a-contract" title="Permalink to this headline">¶</a></h4>
<p>它被添加到合约的总余额中，就像你在创建合约时发送乙醚。您只能将以太发送到具有可支付修饰符的函数，否则将抛出异常。<code class="docutils literal"><span class="pre">payable</span></code></p>
</div>
<div class="section" id="is-it-possible-to-get-a-tx-receipt-for-a-transaction-executed-contract-to-contract">
<h4>Is it possible to get a tx receipt for a transaction executed contract-to-contract?<a class="headerlink" href="#is-it-possible-to-get-a-tx-receipt-for-a-transaction-executed-contract-to-contract" title="Permalink to this headline">¶</a></h4>
<p>不，从一个合约到另一个合约的函数调用并不创建它自己的事务，您必须查看整个事务。这也是为什么severalblock explorer没有正确地显示合约之间的醚。</p>
</div>
<div class="section" id="what-is-the-memory-keyword-what-does-it-do">
<h4>What is the <code class="docutils literal"><span class="pre">memory</span></code> keyword? What does it do?<a class="headerlink" href="#what-is-the-memory-keyword-what-does-it-do" title="Permalink to this headline">¶</a></h4>
<p>Ethereum虚拟机有三个可以存储项目的区域。</p>
<p>第一个是“存储”，所有的合约状态变量都在其中。每个合约都有自己的存储空间，而且在功能调用和使用成本之间存在持久性。</p>
<p>第二个是“内存”，这是用来保存临时值的。它在(外部)函数调用之间消除，并且使用起来更便宜。</p>
<p>第三个是栈，它用来保存小的局部变量。它几乎可以免费使用，但只能保留有限的值。</p>
<p>对于几乎所有类型，您不能指定它们应该存储在哪里，因为它们在每次使用时都被复制。</p>
<p>所谓存储位置重要的类型是结构和数组。如果你在函数调用中传递这样的变量，它们的数据就不会被复制，如果它可以留在内存中或者保存在内存中。这意味着您可以在调用函数中修改其内容，在调用者中仍然可以看到这些修改。</p>
<p>存储位置的默认值取决于它所关注的变量类型:</p>
<ul class="simple">
<li>state variables are always in storage</li>
<li>function arguments are in memory by default</li>
<li>local variables of struct, array or mapping type reference storage by default</li>
<li>local variables of value type (i.e. neither array, nor struct nor mapping) are stored in the stack</li>
</ul>
<p>例子:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="nx">data1</span><span class="p">;</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="nx">data2</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">appendOne</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">append</span><span class="p">(</span><span class="nx">data1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">appendTwo</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">append</span><span class="p">(</span><span class="nx">data2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">append</span><span class="p">(</span><span class="kt">uint</span><span class="p">[]</span> <span class="k">storage</span> <span class="nx">d</span><span class="p">)</span> <span class="k">internal</span> <span class="p">{</span>
        <span class="nx">d</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数append可以在data1和data2上工作，它的修改将永久保存。如果删除了存储关键字，则defaultis将使用内存作为函数参数。这是在append(data1)或append(data2)被调用的时候，在内存中创建状态变量的独立副本，并在该副本上操作(不支持。push——但这是另一个问题)。对该独立副本的修改不会返回到data1或data2。<code class="docutils literal"><span class="pre">append</span></code><code class="docutils literal"><span class="pre">data1</span></code><code class="docutils literal"><span class="pre">data2</span></code><code class="docutils literal"><span class="pre">storage</span></code><code class="docutils literal"><span class="pre">memory</span></code><code class="docutils literal"><span class="pre">append(data1)</span></code><code class="docutils literal"><span class="pre">append(data2)</span></code><code class="docutils literal"><span class="pre">append</span></code><code class="docutils literal"><span class="pre">.push</span></code><code class="docutils literal"><span class="pre">data1</span></code><code class="docutils literal"><span class="pre">data2</span></code></p>
<p>一个常见的错误是声明一个本地变量，并假设它将在内存中创建，尽管它将在存储中创建:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="cs">/// THIS CONTRACT CONTAINS AN ERROR</span>

<span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="nx">someVariable</span><span class="p">;</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="nx">data</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="nx">x</span><span class="p">;</span>
        <span class="nx">x</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
        <span class="nx">data</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>本地变量x的类型是uint[]存储，但是sincestorage不是动态分配的，它必须在使用之前分配froma状态变量。因此，存储空间中的空间不会分配给x，而是作为存储中的已存在变量的别名。<code class="docutils literal"><span class="pre">x</span></code><code class="docutils literal"><span class="pre">uint[]</span> <span class="pre">storage</span></code><code class="docutils literal"><span class="pre">x</span></code></p>
<p>将会发生的是，编译器将x解释为一个storagepointer，并在默认情况下将其指向存储槽0。它的作用是，可以通过x.push(2)修改someVariable(驻留在storageslot 0中的)。<code class="docutils literal"><span class="pre">x</span></code><code class="docutils literal"><span class="pre">0</span></code><code class="docutils literal"><span class="pre">someVariable</span></code><code class="docutils literal"><span class="pre">0</span></code><code class="docutils literal"><span class="pre">x.push(2)</span></code></p>
<p>正确的做法是:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span> <span class="nx">someVariable</span><span class="p">;</span>
    <span class="kt">uint</span><span class="p">[]</span> <span class="nx">data</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="kt">uint</span><span class="p">[]</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span>
        <span class="nx">x</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="advanced-questions">
<h3>Advanced Questions<a class="headerlink" href="#advanced-questions" title="Permalink to this headline">¶</a></h3>
<div class="section" id="how-do-you-get-a-random-number-in-a-contract-implement-a-self-returning-gambling-contract">
<h4>How do you get a random number in a contract? (Implement a self-returning gambling contract.)<a class="headerlink" href="#how-do-you-get-a-random-number-in-a-contract-implement-a-self-returning-gambling-contract" title="Permalink to this headline">¶</a></h4>
<p>获得随机性通常是加密项目中至关重要的部分，而大多数故障都是由随机数生成器造成的。</p>
<p>如果你不希望它是安全的，你就会建立类似于flipperbut的东西，而不是使用一个提供随机性的合约，比如RANDAO。<a class="reference external" href="https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/35_coin_flipper.sol">coin flipper</a><a class="reference external" href="https://github.com/randao/randao">RANDAO</a></p>
</div>
<div class="section" id="get-return-value-from-non-constant-function-from-another-contract">
<h4>Get return value from non-constant function from another contract<a class="headerlink" href="#get-return-value-from-non-constant-function-from-another-contract" title="Permalink to this headline">¶</a></h4>
<p>关键的一点是，调用合约需要知道它打算调用的函数。</p>
<p>看到平。soland pong.sol。<a class="reference external" href="https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/45_ping.sol">ping.sol</a><a class="reference external" href="https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/45_pong.sol">pong.sol</a></p>
</div>
<div class="section" id="get-contract-to-do-something-when-it-is-first-mined">
<h4>Get contract to do something when it is first mined<a class="headerlink" href="#get-contract-to-do-something-when-it-is-first-mined" title="Permalink to this headline">¶</a></h4>
<p>使用构造函数。当合约第一次被开采时，它里面的任何东西都将被执行。</p>
<p>看到replicator.sol。<a class="reference external" href="https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/50_replicator.sol">replicator.sol</a></p>
</div>
<div class="section" id="how-do-you-create-2-dimensional-arrays">
<h4>How do you create 2-dimensional arrays?<a class="headerlink" href="#how-do-you-create-2-dimensional-arrays" title="Permalink to this headline">¶</a></h4>
<p>看到2 d_array.sol。<a class="reference external" href="https://github.com/fivedogit/solidity-baby-steps/blob/master/contracts/55_2D_array.sol">2D_array.sol</a></p>
<p>请注意，在撰写本文时，在10x10平方英寸的uint8 +合约创建过程中使用了超过80万的天然气。17 x17花了2000000。有了314万的限制，你现在就能创造出一个很低的上限。<code class="docutils literal"><span class="pre">uint8</span></code><code class="docutils literal"><span class="pre">800,000</span></code><code class="docutils literal"><span class="pre">2,000,000</span></code></p>
<p>注意，仅仅“创建”数组是免费的，成本是用来填充的。</p>
<p>Note2:优化存储访问可以大大降低气体成本，因为uint8值可以存储在一个槽中。问题是，这些优化不会跨循环工作，而且还存在边界检查问题。不过，你将来可能会得到更好的结果。<code class="docutils literal"><span class="pre">uint8</span></code></p>
</div>
<div class="section" id="what-happens-to-a-struct-s-mapping-when-copying-over-a-struct">
<h4>What happens to a <code class="docutils literal"><span class="pre">struct</span></code>’s mapping when copying over a <code class="docutils literal"><span class="pre">struct</span></code>?<a class="headerlink" href="#what-happens-to-a-struct-s-mapping-when-copying-over-a-struct" title="Permalink to this headline">¶</a></h4>
<p>这是一个非常有趣的问题。假设我们有一个这样的合约字段:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="k">mapping</span><span class="p">(</span><span class="kt">string</span> <span class="o">=&gt;</span> <span class="kt">string</span><span class="p">)</span> <span class="nx">comments</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">somefunction</span> <span class="k">public</span> <span class="p">{</span>
   <span class="nx">User</span> <span class="nx">user1</span><span class="p">;</span>
   <span class="nx">user1</span><span class="p">.</span><span class="nx">comments</span><span class="p">[</span><span class="s2">"Hello"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"World"</span><span class="p">;</span>
   <span class="nx">User</span> <span class="nx">user2</span> <span class="o">=</span> <span class="nx">user1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在这种情况下，由于没有“映射键列表”，所以将结构复制到userList的映射被忽略。因此，不可能发现应该复制哪些值。</p>
</div>
<div class="section" id="how-do-i-initialize-a-contract-with-only-a-specific-amount-of-wei">
<h4>How do I initialize a contract with only a specific amount of wei?<a class="headerlink" href="#how-do-i-initialize-a-contract-with-only-a-specific-amount-of-wei" title="Permalink to this headline">¶</a></h4>
<p>目前的方法有点丑陋，但是却没有什么可以改进它的方法。如果是合约a的一个新实例B，括号必须使用新的B，因为B。value指的是被称为值的B成员。你需要确保两个合约都知道对方的存在，并且合约B有一个可支付的构造函数。在这个例子中:<code class="docutils literal"><span class="pre">contract</span> <span class="pre">A</span></code><code class="docutils literal"><span class="pre">contract</span> <span class="pre">B</span></code><code class="docutils literal"><span class="pre">new</span> <span class="pre">B</span></code><code class="docutils literal"><span class="pre">B.value</span></code><code class="docutils literal"><span class="pre">B</span></code><code class="docutils literal"><span class="pre">value</span></code><code class="docutils literal"><span class="pre">contract</span> <span class="pre">B</span></code><code class="docutils literal"><span class="pre">payable</span></code></p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">B</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">B</span><span class="p">()</span> <span class="k">public</span> <span class="k">payable</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="kd">contract</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="kt">address</span> <span class="nx">child</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">child</span> <span class="o">=</span> <span class="p">(</span><span class="k">new</span> <span class="nx">B</span><span class="p">).</span><span class="nx">value</span><span class="p">(</span><span class="mi">10</span><span class="p">)();</span> <span class="c1">//construct a new B with 10 wei</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="can-a-contract-function-accept-a-two-dimensional-array">
<h4>Can a contract function accept a two-dimensional array?<a class="headerlink" href="#can-a-contract-function-accept-a-two-dimensional-array" title="Permalink to this headline">¶</a></h4>
<p>这还没有实现外部调用和动态数组——您只能使用一个级别的动态数组。</p>
</div>
<div class="section" id="what-is-the-relationship-between-bytes32-and-string-why-is-it-that-bytes32-somevar-stringliteral-works-and-what-does-the-saved-32-byte-hex-value-mean">
<h4>What is the relationship between <code class="docutils literal"><span class="pre">bytes32</span></code> and <code class="docutils literal"><span class="pre">string</span></code>? Why is it that <code class="docutils literal"><span class="pre">bytes32</span> <span class="pre">somevar</span> <span class="pre">=</span> <span class="pre">"stringliteral";</span></code> works and what does the saved 32-byte hex value mean?<a class="headerlink" href="#what-is-the-relationship-between-bytes32-and-string-why-is-it-that-bytes32-somevar-stringliteral-works-and-what-does-the-saved-32-byte-hex-value-mean" title="Permalink to this headline">¶</a></h4>
<p>类型bytes32可以持有32 (raw)字节。在赋值bytes32 samevar = "stringliteral"中，字符串文字被解释为原始字节形式，如果你检查somevar，并看到一个32字节的十六进制值，那么这就是十六进制的“stringliteral”。<code class="docutils literal"><span class="pre">bytes32</span></code><code class="docutils literal"><span class="pre">bytes32</span> <span class="pre">samevar</span> <span class="pre">=</span> <span class="pre">"stringliteral";</span></code><code class="docutils literal"><span class="pre">somevar</span></code><code class="docutils literal"><span class="pre">"stringliteral"</span></code></p>
<p>类型字节是类似的，只是它可以改变它的长度。<code class="docutils literal"><span class="pre">bytes</span></code></p>
<p>最后，字符串基本上与字节完全相同，只是为了保持一个真正字符串的UTF-8编码。由于字符串将数据存储在UTF-8编码中，因此计算字符串中的字符数非常昂贵(一些字符的编码比单个字节要多)。因为这个，字符串s;年代。长度不受支持，甚至不支持索引访问[2]。但是如果要访问字符串的低级字节编码，可以使用字节。长度和字节(s)[2]，这将导致字符串的UTF-8编码的字节数(不是字符数)和UTF-8编码字符串的第二个字节(不是字符)。<code class="docutils literal"><span class="pre">string</span></code><code class="docutils literal"><span class="pre">bytes</span></code><code class="docutils literal"><span class="pre">string</span></code><code class="docutils literal"><span class="pre">string</span> <span class="pre">s;</span> <span class="pre">s.length</span></code><code class="docutils literal"><span class="pre">s[2]</span></code><code class="docutils literal"><span class="pre">bytes(s).length</span></code><code class="docutils literal"><span class="pre">bytes(s)[2]</span></code></p>
</div>
<div class="section" id="can-a-contract-pass-an-array-static-size-or-string-or-bytes-dynamic-size-to-another-contract">
<h4>Can a contract pass an array (static size) or string or <code class="docutils literal"><span class="pre">bytes</span></code> (dynamic size) to another contract?<a class="headerlink" href="#can-a-contract-pass-an-array-static-size-or-string-or-bytes-dynamic-size-to-another-contract" title="Permalink to this headline">¶</a></h4>
<p>确定。请注意，如果您跨越了内存/存储边界，将创建独立的副本:</p>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">16</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">uint</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="nx">x</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="k">public</span> <span class="p">{</span>
        <span class="nx">g</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="nx">h</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">g</span><span class="p">(</span><span class="kt">uint</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="nx">y</span><span class="p">)</span> <span class="k">internal</span> <span class="k">pure</span> <span class="p">{</span>
        <span class="nx">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">h</span><span class="p">(</span><span class="kt">uint</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="k">storage</span> <span class="nx">y</span><span class="p">)</span> <span class="k">internal</span> <span class="p">{</span>
        <span class="nx">y</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>对g(x)的调用不会对x产生影响，因为它需要在内存中创建一个独立的存储值副本(默认的存储位置是内存)。另一方面，h(x)成功地修改了x，因为只有一个引用而不是一个副本被通过。<code class="docutils literal"><span class="pre">g(x)</span></code><code class="docutils literal"><span class="pre">x</span></code><code class="docutils literal"><span class="pre">h(x)</span></code><code class="docutils literal"><span class="pre">x</span></code></p>
</div>
<div class="section" id="sometimes-when-i-try-to-change-the-length-of-an-array-with-ex-arrayname-length-7-i-get-a-compiler-error-value-must-be-an-lvalue-why">
<h4>Sometimes, when I try to change the length of an array with ex: <code class="docutils literal"><span class="pre">arrayname.length</span> <span class="pre">=</span> <span class="pre">7;</span></code> I get a compiler error <code class="docutils literal"><span class="pre">Value</span> <span class="pre">must</span> <span class="pre">be</span> <span class="pre">an</span> <span class="pre">lvalue</span></code>. Why?<a class="headerlink" href="#sometimes-when-i-try-to-change-the-length-of-an-array-with-ex-arrayname-length-7-i-get-a-compiler-error-value-must-be-an-lvalue-why" title="Permalink to this headline">¶</a></h4>
<p>您可以使用arrayname调整存储中的动态数组(即在协议级别声明的数组)。长= &lt;一些新长度&gt;;如果您获得了“lvalue”错误，您可能正在做两件错误的事情之一。<code class="docutils literal"><span class="pre">arrayname.length</span> <span class="pre">=</span> <span class="pre">&lt;some</span> <span class="pre">new</span> <span class="pre">length&gt;;</span></code></p>
<ol class="arabic simple">
<li>You might be trying to resize an array in “memory”, or</li>
<li>You might be trying to resize a non-dynamic array.</li>
</ol>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="c1">// This will not compile</span>

<span class="k">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">18</span><span class="p">;</span>

<span class="kd">contract</span> <span class="nx">C</span> <span class="p">{</span>
    <span class="kt">int8</span><span class="p">[]</span> <span class="nx">dynamicStorageArray</span><span class="p">;</span>
    <span class="kt">int8</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="nx">fixedStorageArray</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">f</span><span class="p">()</span> <span class="p">{</span>
        <span class="kt">int8</span><span class="p">[]</span> <span class="k">memory</span> <span class="nx">memArr</span><span class="p">;</span>        <span class="c1">// Case 1</span>
        <span class="nx">memArr</span><span class="p">.</span><span class="nx">length</span><span class="o">++</span><span class="p">;</span>             <span class="c1">// illegal</span>

        <span class="kt">int8</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="k">storage</span> <span class="nx">storageArr</span> <span class="o">=</span> <span class="nx">fixedStorageArray</span><span class="p">;</span>   <span class="c1">// Case 2</span>
        <span class="nx">storageArr</span><span class="p">.</span><span class="nx">length</span><span class="o">++</span><span class="p">;</span>                             <span class="c1">// illegal</span>

        <span class="kt">int8</span><span class="p">[]</span> <span class="k">storage</span> <span class="nx">storageArr2</span> <span class="o">=</span> <span class="nx">dynamicStorageArray</span><span class="p">;</span>
        <span class="nx">storageArr2</span><span class="p">.</span><span class="nx">length</span><span class="o">++</span><span class="p">;</span>                     <span class="c1">// legal</span>


    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Important note:</strong>重要提示:在Solidity中，从您可能用于在C或Java中声明它们的方式来声明数组维度，但是它们可以访问为inC或Java。</p>
<p>例如,int8[][5]somearray;是5个动态的int8数组。<code class="docutils literal"><span class="pre">int8[][5]</span> <span class="pre">somearray;</span></code><code class="docutils literal"><span class="pre">int8</span></code></p>
<p>原因是T[5]始终是一个5 T的数组，不管T本身是否是一个数组(这不是C或Java中的情况)。<code class="docutils literal"><span class="pre">T[5]</span></code><code class="docutils literal"><span class="pre">T</span></code><code class="docutils literal"><span class="pre">T</span></code></p>
</div>
<div class="section" id="is-it-possible-to-return-an-array-of-strings-string-from-a-solidity-function">
<h4>Is it possible to return an array of strings (<code class="docutils literal"><span class="pre">string[]</span></code>) from a Solidity function?<a class="headerlink" href="#is-it-possible-to-return-an-array-of-strings-string-from-a-solidity-function" title="Permalink to this headline">¶</a></h4>
<p>还没有，因为这需要两个级别的动态数组(字符串是动态数组本身)。<code class="docutils literal"><span class="pre">string</span></code></p>
</div>
<div class="section" id="if-you-issue-a-call-for-an-array-it-is-possible-to-retrieve-the-whole-array-or-must-you-write-a-helper-function-for-that">
<h4>If you issue a call for an array, it is possible to retrieve the whole array? Or must you write a helper function for that?<a class="headerlink" href="#if-you-issue-a-call-for-an-array-it-is-possible-to-retrieve-the-whole-array-or-must-you-write-a-helper-function-for-that" title="Permalink to this headline">¶</a></h4>
<p>一个数组类型的公共状态变量的自动getter函数只能返回单个的元素。如果您想要返回完整的数组，那么就需要编写一个函数来完成这个任务。<a class="reference internal" href="index.html#getter-functions"><span class="std std-ref">getter function</span></a></p>
</div>
<div class="section" id="what-could-have-happened-if-an-account-has-storage-value-s-but-no-code-example-http-test-ether-camp-account-5f740b3a43fbb99724ce93a879805f4dc89178b5">
<h4>What could have happened if an account has storage value(s) but no code?  Example: <a class="reference external" href="http://test.ether.camp/account/5f740b3a43fbb99724ce93a879805f4dc89178b5">http://test.ether.camp/account/5f740b3a43fbb99724ce93a879805f4dc89178b5</a><a class="headerlink" href="#what-could-have-happened-if-an-account-has-storage-value-s-but-no-code-example-http-test-ether-camp-account-5f740b3a43fbb99724ce93a879805f4dc89178b5" title="Permalink to this headline">¶</a></h4>
<p>构造函数所做的最后一件事是返回合约的代码。天然气的成本取决于代码的长度，可能是供气不足。这种情况是唯一一个“不使用天然气”的例外情况不会使国家发生变化，即。在这种情况下，状态变量的初始化。</p>
<p><a class="reference external" href="https://github.com/ethereum/wiki/wiki/Subtleties">https://github.com/ethereum/wiki/wiki/Subtleties</a></p>
<p>在成功地创建操作的子执行之后，如果操作返回x，则在创建合约之前，从剩余的气体中减去5 * len(x)气体。如果剩余的气体小于5 * len(x)，则没有气体被减去，所创建的合约的代码就变成了空字符串，但是这并没有被视为异常情况——没有发生任何恢复。</p>
</div>
<div class="section" id="what-does-the-following-strange-check-do-in-the-custom-token-contract">
<h4>What does the following strange check do in the Custom Token contract?<a class="headerlink" href="#what-does-the-following-strange-check-do-in-the-custom-token-contract" title="Permalink to this headline">¶</a></h4>
<div class="highlight-Solidity"><div class="highlight"><pre><span></span><span class="nb">require</span><span class="p">((</span><span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]</span> <span class="o">+</span> <span class="nx">_value</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nx">balanceOf</span><span class="p">[</span><span class="nx">_to</span><span class="p">]);</span>
</pre></div>
</div>
<p>Solidity(以及大多数其他与机器相关的编程语言)的整数被限制在一定范围内。对于uint256，这是0到2**256 - 1。如果在这些数字上的某些操作的结果不适合这个范围，那么它将被截断。这些截断可能会产生严重的后果，因此像上述代码一样的代码对于避免某些攻击是必要的。<code class="docutils literal"><span class="pre">uint256</span></code><code class="docutils literal"><span class="pre">0</span></code><code class="docutils literal"><span class="pre">2**256</span> <span class="pre">-</span> <span class="pre">1</span></code><a class="reference external" href="https://en.bitcoin.it/wiki/Value_overflow_incident">serious consequences</a></p>
</div>
<div class="section" id="more-questions">
<h4>More Questions?<a class="headerlink" href="#more-questions" title="Permalink to this headline">¶</a></h4>
<p>如果你有更多的问题，或者你的问题没有回答，请与我们讨论，或者提出一个问题。<a class="reference external" href="https://gitter.im/ethereum/solidity">gitter</a><a class="reference external" href="https://github.com/ethereum/solidity/issues">issue</a></p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<footer>
<hr/>
<div role="contentinfo">
<p>版权©2016 - 2018,Ethereum。修订267年b605f。<span class="commit">
          Revision <code>267b605f</code>.
        </span></p>
</div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
</div>
</div>
</section>
</div>
<div aria-label="versions" class="rst-versions" data-toggle="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span class="fa fa-book"> Read the Docs</span>
      v: latest
      <span class="fa fa-caret-down"></span>
</span>
<div class="rst-other-versions">
<dl>
<dt>Versions</dt>
<dd><a href="/en/latest/">latest</a></dd>
<dd><a href="/en/stable/">stable</a></dd>
<dd><a href="/en/v0.4.23/">v0.4.23</a></dd>
<dd><a href="/en/v0.4.22/">v0.4.22</a></dd>
<dd><a href="/en/v0.4.21/">v0.4.21</a></dd>
<dd><a href="/en/v0.4.20/">v0.4.20</a></dd>
<dd><a href="/en/v0.4.19/">v0.4.19</a></dd>
<dd><a href="/en/v0.4.18/">v0.4.18</a></dd>
<dd><a href="/en/v0.4.17/">v0.4.17</a></dd>
<dd><a href="/en/v0.4.16/">v0.4.16</a></dd>
<dd><a href="/en/v0.4.15/">v0.4.15</a></dd>
<dd><a href="/en/v0.4.14/">v0.4.14</a></dd>
<dd><a href="/en/v0.4.13/">v0.4.13</a></dd>
<dd><a href="/en/v0.4.12/">v0.4.12</a></dd>
<dd><a href="/en/v0.4.11/">v0.4.11</a></dd>
<dd><a href="/en/v0.4.10/">v0.4.10</a></dd>
<dd><a href="/en/v0.4.9/">v0.4.9</a></dd>
<dd><a href="/en/v0.4.8/">v0.4.8</a></dd>
<dd><a href="/en/v0.4.7/">v0.4.7</a></dd>
<dd><a href="/en/v0.4.6/">v0.4.6</a></dd>
<dd><a href="/en/v0.4.5/">v0.4.5</a></dd>
<dd><a href="/en/v0.4.4/">v0.4.4</a></dd>
<dd><a href="/en/v0.4.3/">v0.4.3</a></dd>
<dd><a href="/en/v0.4.2/">v0.4.2</a></dd>
<dd><a href="/en/v0.4.1/">v0.4.1</a></dd>
<dd><a href="/en/v0.4.0/">v0.4.0</a></dd>
<dd><a href="/en/v0.3.6/">v0.3.6</a></dd>
<dd><a href="/en/v0.3.5/">v0.3.5</a></dd>
<dd><a href="/en/v0.3.4/">v0.3.4</a></dd>
<dd><a href="/en/v0.3.3/">v0.3.3</a></dd>
<dd><a href="/en/v0.3.2/">v0.3.2</a></dd>
<dd><a href="/en/v0.3.1/">v0.3.1</a></dd>
<dd><a href="/en/v0.3.0/">v0.3.0</a></dd>
<dd><a href="/en/v0.2.2/">v0.2.2</a></dd>
<dd><a href="/en/v0.2.1/">v0.2.1</a></dd>
<dd><a href="/en/v0.2.0/">v0.2.0</a></dd>
<dd><a href="/en/v0.1.7/">v0.1.7</a></dd>
<dd><a href="/en/v0.1.6/">v0.1.6</a></dd>
<dd><a href="/en/v0.1.5/">v0.1.5</a></dd>
<dd><a href="/en/v0.1.4/">v0.1.4</a></dd>
<dd><a href="/en/v0.1.3/">v0.1.3</a></dd>
<dd><a href="/en/v0.1.2/">v0.1.2</a></dd>
<dd><a href="/en/develop/">develop</a></dd>
</dl>
<dl>
<dt>Downloads</dt>
<dd><a href="//readthedocs.org/projects/solidity/downloads/pdf/latest/">pdf</a></dd>
<dd><a href="//readthedocs.org/projects/solidity/downloads/htmlzip/latest/">htmlzip</a></dd>
<dd><a href="//readthedocs.org/projects/solidity/downloads/epub/latest/">epub</a></dd>
</dl>
<dl>
<dt>On Read the Docs</dt>
<dd>
<a href="//readthedocs.org/projects/solidity/?fromdocs=solidity">Project Home</a>
</dd>
<dd>
<a href="//readthedocs.org/builds/solidity/?fromdocs=solidity">Builds</a>
</dd>
</dl>
<hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org">Read the Docs</a>.

    </div>
</div>
<script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.4.24',
            LANGUAGE:'en',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
<script src="_static/jquery.js" type="text/javascript"></script>
<script src="_static/underscore.js" type="text/javascript"></script>
<script src="_static/doctools.js" type="text/javascript"></script>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
</body>
</html>